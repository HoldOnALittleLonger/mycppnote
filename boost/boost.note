C++ Boost 1.84.0

foreach >
    BOOST_FOREACH : <boost/foreach.hpp>
      It iterates over sequences for us,freeing us from having to deal directly with
      iterators or write predicates.
      Advantages :
        no dynamic allocations
        makes no virtual function calls or calls through function pointers
        makes no calls that are not transparent to the compiler's optimizer

      Syntax :
        BOOST_FOREACH(iterator, sequence)
        {
          ...  //  loop body
        }
        @iterator : <type> <id-expression>
                    everytime entered the loop body,@id-expression represents
                    the element in @sequence.
        @sequence : the sequence for loop.
                    if it is a function invocation,the return value must be
                    proper type and the function only be called once.

        //  if typeof(@iterator) != typeof(@element)
              convert type of @element to type of @iterator

        e.g.
          std::string hello("hello, world!");
          BOOST_FOREACH(char ch, hello)
          {
            std::cout << ch;
          }  //  hello, world!
  
          @ch : the object that Iterator refers to.
                @ch can be a predeclared variable.
          @hello : the target to BOOST_FOREACH
          { ... } : what to do for each @ch

      supported sequence types :
        stl containers
        arrays
        null-terminated strings(char and wchar_t)
        std::pair of iterators

      loop keywords is able to be used in the body of BOOST_FOREACH :
        return
        continue
        break
        /*  BOOST_FOREACH is a macro function implemented via "for-loop"  */

      BOOST_FOREACH is possible to be nested :
        e.g.
          std::vector<std::string> vs;
          ...
          BOOST_FOREACH(std::string s, vs)
          {
            ...
            BOOST_FOREACH(char ch, s)
            {
              ...
            }
            ...
          }

      !  use a C++ macro to define BOOST_FOREACH is possible but discourage,
         because that maybe cause name conflicts.
         #  i.e. Qt defined a macro named "foreach".

      BOOST_REVERSE_FOREACH(@iterator, @sequence) :
        iterating over collections in reverse order.

boost.iostreams >
    purpose :
      1>  make it easy to create standard C++ streams and stream buffers for
          accessing new sources and sinks
      2>  provide a framework for defining filters and attaching them to
          standard streams and stream buffers
      3>  provide a collection of ready-to-use filters,sources and sinks

    source:  provides read access to a sequence of characters
    sink:    provides write access to a sequence of characters
    inputfilter:  filters input read from a source
    outputfilter: filters output written to a sink
    devices:  refinements of sources and sinks
    filters:  refinements of inputfilter and outputfilter 

    class template stream_buffer and stream implement standard stream buffers
    and streams which perform i/o by delegating to a contained device.

    class template filterintg_streambuf and filtering_stream contain chains of
    filters and devices.

    Writing Devices :
      model the concept of the device to a class,
      transfer the class of the device to stream or stream_buffer as a template
      argument.
      e.g.
        #include<boost/iostreams/stream.hpp>
        #include<boost/iostreams/stream_buffer.hpp>
          class device_keyboard {
            ...
          };
          namespace io = boost::iostreams;

          //  stream_buffer<device_keyboard> inherits from 
          //  std::basic_streambuf and io::stream<device_keyboard>
          io::stream_buffer<device_keyboard> keyboard_io_streambuffer;

          //  stream<device_keyboard> inherits from std::basic_istream,
          //  std::basic_ostream or std::basic_iostream depending on the
          //  mode of @device_keyboard
          io::stream<device_keyboard> keyboard_io_stream;

      in practice,boost::iostreams::stream_buffer is more used frequently than
      boost::iostreams::stream,provides boost::iostreams::stream as a convenience.
      stream_buffer is able to be combined together with standard C++ io stream
      templates.
      e.g.
        boost::iostreams::stream_buffer<device_keyboard> keyboard_stream_buffer;
        keyboard_stream_buffer.open("/dev/input/by-id/usb-VENDOR_USB_Keyboard-event");
        ...
        std::istream input(&keyboard_stream_buffer);
        //  read from the keyboard.
        //  the underlying data source is stream_buffer @keyboard_stream_buffer
        //  thus read from @input is equivalence read from the keyboard.

      !!  boost iostreams provides the regular file type which is defined in
          <boost/iostreams/device/file.hpp> as a class template basic_file_source.
          using file_source = basic_file_source<char>;
          using wfile_source = basic_file_source<wchar_t>;

    Writing a container_source :
      in boost iostreams library,"source" means the device only support reading
      from it refuse writ into it.
      as the name,container_source is a "source" and the underlying data stream
      if come from a container.

      <boost/iostreams/categories.hpp>
        /*  source_tag - structure source_tag used as C++ trait to represents
         *               a "source".
         *  derive:      public {
         *                 @device_tag
         *                 @input 
         *               }
         */
        struct source_tag : device_tag, input {};

        e.g.
          class the_device {
          public:
            typedef source_tag category;
            ...
          };

          //  member type category indicates what the device is.
          //  @soure_tag means the device is a source,conversely,
          //  @sink_tag means the device is a sink.

      <boost/iostreams/concepts.hpp>
        /*  type-definition - specialization of class template @device with @input
         *                    is source type.
         */
        typedef device<input> source;

        e.g.
          //  C++ "is-a"
          class the_device : public source { ... };
        
          //  class @the_device is a "source".

      container_source :  //  device is type of source
        <boost/iostreams/categories.hpp>
        ...

        template<typename _TContainer>
        class container_source {
        public:
          typedef _TContainer::value_type char_type;
          typedef source_tag category;
          //  tell to boost iostreams library that class container_source
          //  is a model of "source".

          container_source(_TContainer &container);  //  constructor

          std::streamsize read(char_type *des, std::streamsize n);  //  read-op

        ...
        };

        template<typename _TContainer, typename _TDestination>
        std::streamsize getline(container_source<_TContainer> &src, _TDestination *des)
        {
          if (!des)
            return -1;
   
          //  member function source.getNextLineLength() maybe undefined,just provide a 
          //  abstract primitive on there.
          return src.read(des, src.getNextLineLength());
        }

        //  overload
        template<typename _TContainer>
        std::streamsize getline(container_source<_TContainer> &src, _TContainer &des)
        {
          ...
        }

        //  or use the library feature
        //    std::string input("Hello world");
        //    std::string output;
        //    
        //    //  stream on device container_source<string>
        //    boost::iostreams::stream<container_source<string>> in(input);
        //    getline(in, output);  //  libaray function
        //    

        !!  instances of boost::iterator_range can be added directly to
            filtering streams and stream buffers,thus there is a easier way
            to read from an STL container:
              e.g.
                <boost/iostreams/filtering_stream.hpp>
                <boost/range/iterator_range.hpp>
                <string>

                string input("Hello world");
                string output;

                //  combine boost iostreams filtering stream with
                //  boost iterator range.
                //  make an iterator,which moving in the range defined by @input.
                //  install the new iterator to filtering_istream object for replace
                //  the older one.
                boost::iostreams::filtering_istream in(boost::make_iterator_range(input));
                getline(in, output);

    Writing a container_sink :
      a sink is a device which support write operation only.
      
      <boost/iostreams/categories.hpp>
        //  sink_tag - tag used indicates that the device contains it
        //             is a sink.
        struct sink_tag : device_tag, output {};

        e.g.
          class the_device {
          public:
            typedef sink_tag category;
          ...
          };

      <boost/iostreams/concepts.hpp>
        //  type-definition - specialization of class template @device with
        //                    template parameter @output is a sink.
        //  #  class derived from this type is also a sink.
        typedef device<output> sink;

        e.g.
          class the_device : public sink {};

      container_sink :  //  device is type of sink

        //  the underlying container is specified by template parameter
        //  @_TContainer
        template<typename _TContainer>
        class container_sink {
        public:
          typdef _TContainer::value_type char_type;  //  character type
          typedef sink_tag category;  //  category of this device
                                      //  tell boost iostreams that the
                                      //  device container_sink is a
                                      //  model of Sink.

          container_sink(_TContainer &container);  //  constructor

          //  write - member function write,write characters from @s
          //          to the underlying container with size @n
          //  @src:   source data
          //  @n:     size to write
          //  return: size have been written
          //          -1  =>  EOF or other errror
          std::streamsize write(const char_type *src, std::streamsize n);
        };
        
        template<typename _TContainer, typename _TCharacter = char>
        std::streamsize operator<<(container_sink<_TContainer> &sink, const _TCharacter *src)
        {
          if (!src)
            return -1;
          return sink.write(src, strlen(src));
        }

        //  operator overload can not modify the basic rule of that operator.

        template<typename _TContainer>
        std::streamsize operator<<(container_sink<_TContainer> &sink, const _TContainer &source)
        {
          //  read_data just a primitive used to retrieve the real underlying buffer of @source
          return sink.write(source.real_data(), source.length());
        }

        //  or use the library feature
        //    std::string destination;
        //
        //    //  stream on device container_sink<std::string>.
        //    boost::iostreams::stream<container_sink<std::string>> out(destination);
        //    out << "Hello world";  //  read and write into @out
        //                           //  @out had been linked to @destination
        //                           //  operator<< overload provides by iostreams library
        //    out.flush();  //  flush

        !!  boost iostreams library provides buffering by default.

        !!  OutputIterators can be added directly
            to filtering streams and stream buffers of boost iostreams library.
            e.g.
              <iterator>
              <boost/iostreams/filtering_stream.hpp>

              string destination;       //  as underlying container
              
              //  construct an object is type of filtering_ostream,initialize it with
              //  a back_insert obtained from @destination
              boost::iostreams::filtering_ostream out(back_insert(destination));
              out << "Hello world";
              out.flush();

            //  <boost/iostreams/device/back_inserter.hpp> provides a back_inserter
            //  more efficient than C++ Standard Library back_inserter.
            //    boost::iostreams::back_inserter()

    Writing a container_device :
      suppose a device support to input and output,in order for combined
      reading and writing to be useful,then it must supports to seek.

      several types of devices which combine reading and writing,the different
      is: 
        there are two separate character sequences for input and output or only
        a character sequence for input and output
        there are separate position indicators for reading and writing or only
        a single read/write position indicator

      boost iostreams library provides several modes to specify what the device
      is.

      <boost/iostreams/positioning.hpp>
        //  type-definition - stream offset type.
        typedef boost::intmax_t stream_offset;

      <boost/iostreams/categories.hpp>
        //  seekable_device_tag - tag to indicates the device contains this tag
        //                        is a seekable device,it supports input/output
        //                        on a single character sequence with a single
        //                        position indicator.
        struct seekable_device_tag : virtual device_tag, seekable { };

        e.g.
          class the_seekable_device {
          public:
            typedef seekable_device_tag category;
            ...

            std::streamsize read(char *s, std::streamsize n);
            std::streamsize write(const char *s, std::streamsize n);

            //  seek - seek stream position to @base + @off 
            //  @off:  offset to @base
            //  @base: where to start
            //         std::io_base::beg
            //         std::io_base::cur
            //         std::io_base:end
            //  return: the new stream position
            stream_offset seek(stream_offset off, std::io_base::seekdir base);
          };

      //  I have not find out the type-definition about seekable_device in
      //  <boost/iostreams/concepts.hpp> .
      //  but i think the type-definition should be
      //    typedef device<seekable> seekable_device;
      //  
      //  make @the_seekable_device public inherits("is-a") from such
      //  specifialized class is easy way to indicates the class is a
      //  seekable device.

      container_device :
        <boost::iostreams::categories.hpp>
        <boost::iostreams::positioning.hpp>
        ...

        //  the C++ head <iterator> contains several iterators with
        //  different type,and the STL container selects a kind of
        //  them as its iterator.
        //  because this device is seekable(base + offset),thus the
        //  container at least selected std::random_access_iterator
        //  as its iterator.
        template<typename _TContainer>
        class container_device {
        public:
          typedef _TContainer::value_type char_type;
          typedef seekable_device_tag category;  //  container_device is a model
                                                 //  of seekable device.

          container_device(_TContainer &container);

          //  a seekable device must supports input and output

          //  reading starts at current position
          std::streamsize read(char *des, std::streamsize n);

          //  writing starts at current position
          std::streamsize write(const char *src, std::streamsize n);

          //  a seekable device must supports to seek position
          //  the problem new position exceed end of container how to be
          //  solved is according to design,just throw an exception or
          //  extend the size of underlying container are OK.
          stream_offset seek(stream_offset offset, std::io_base::seekdir base);

        ...
        };

        e.g.
          <string>
          <ios>
          <boost/iostreams/stream.hpp>

          std::string str1;
          std::string str2;

          //  construct a stream @io_device on container_device<std::string>,and
          //  the underlying container of the device is @str1.
          boost::iosteams::stream<container_device<std::string>> io_device(str1);

          io_device << "Hello world";
          io_device.flush();  //  @str1 contains "Hello world"

          io_device.seek(0, BOOST_IOS::beg);  //  seek to beg + 0

          getline(io_device, str2);  //  read from @io_device write into @str2


    The Modes that device could be :
      the modes defined in <boost/iostreams/categories.hpp>

      struct any_tag { };

      Input                             single sequence of characters
                                        - input on sc1

      struct input : virtual any_tag { };

      Output                            single sequence of characters
                                        - output on sc1

      struct output : virtual any_tag { };

      Bidirectional                     two separate sequences of characters
                                        - input on s1
                                        - output on sc2

      struct bidirectional 
          : virtual input,
            virtual output,
            detial::two_sequence
          { };

      Input-seekable                    single sequence of characters
                                        - input on sc1
                                        - I-seekable

      struct input_seekable : virtual input, virtual detail::random_access { };

      Output-seekable                   a single sequence of characters
                                        - output on sc1
                                        - O-seekable

      struct output_seekable : virtual output, virtual detail::random_access { };

      Seekable                          single sequence of characters
                                        - input on sc1
                                        - output on sc2
                                        - I/O-seekable

      struct seekable
          : virtual input_seekable,
            virtual output_seekable,
            detail::one_head
          { };

      Dual-seekable                     single sequence of characters
                                        - input on sc1
                                        - output on sc2
                                        - I-seekable AND O-seekable

      struct dual_seekable
          : virtual input_seekable
            virtual output_seekable
            detail::two_head
          { };

      Bidirectional-seekable            two separate sequences of characters
                                        - input on sc1
                                        - ouput on sc2
                                        - I-seekable AND O-seekable

      struct bidirectional_seekable
          : input_seekable,
            output_seekable,
            bidirectional,
            detail::two_head
          { };

    InputFilters,OutputFilters and Filter Helpers :
      filters are used to modify character sequences.
      of course,filters can do nothing except just observe the characters.

                                 +-------+
      unfiltered characters ===> |Filters| ===> filtered characters
                                 +-------+
                                  | | |
                                  | | +-------> observer => do nothing
                                  | +---------> cryptor  => encrypt characters
                                  +-----------> replacer => replace X to Y

      InputFilters and OutputFilters :
        InputFilter and OutputFilter are the basic filters in iostreams.

        InputFilters represent a "pull" model of filtering >
          a source of unfiltered data is provided--represented as a "source",
          it is expected to generate a certain number of characters of the 
          filtered sequence.

          InputData => InputFilter => sequence of characters(filtered)
                                      as "Source" for reading

          //  InputFilter is a observer

        OutputFilters represent a "push" model of filtering >
          a sequence of unfiltered characters and a "Sink" are provided,
          it is expected to filter the characters and write them to the "Sink".

          OutputData => OutputFilter => sequence of characters(filtered)
                                        as "Sink" for writing

          //  OutputFilter is a observer

      Filter Helpers :
        helpers are the utilities provided by iostreams to writing a filter
        easier.
        
                            //  usage scenario
        aggregate_filter > (high-memory usage, well-defined end)
          for define filter by reading unfiltered data from std::vector,
          and writing filtered data to another std::vector.

        stdio_filter > (high-memory usage, well-defined end)
          for defing filter by reading unfiltered data from STDIN,
          and writing filtered data to STDOUT.

        symmetric_filter > (C-Language APIs such zlib,OpenSSL)
          for define filter by reading unfiltered data from one array,
          and writing filtered data to another array.


                                      +------+                    
        std::vector ==> InputData ==> |Filter| ==> OutputData ==> std::vector
        STDIN---+ |                   +------+                    STDOUT
        Array-+ | |                    | | |                      Array
              | | |                    | | +-----+
              | | |                    | +-----+ |
              | | |                    +-----+ | |
              | | |                          | | |
              | | |                          | | |
              | | +------>aggregate_filter<--+ | |
              | +--------->stdio_filter<-------+ |
              +----------->symmetric_filter<-----+


        finite_state_filter >
          for define filter as a finite state machine.
          //  it is not currently an official part of the library.

    Some examples about how to use filters :
      filters are usually used in conjunction with filtering streams and 
      stream buffers.

      filtering_ostream example :
        <boost/iostreams/device/file_descriptor.hpp>
        <boost/iostreams/filtering_stream.hpp>

        boost::iostreams::filtering_ostream out;
    
        out.push(streamAction(FIRST));    //  push a character processor,
                                          //  which take an action FIRST
                                          //  on all characters in the stream.
        out.push(streamAction(SECOND));   //  as same as FIRST

        out.push(file_sink("/dev/null")); //  push a Sink,finally,all characters
                                          //  in the stream would be written
                                          //  into "/dev/null" .

        //  filtering_ostream maintains an internal chain of
        //  Filters and Devices.when data is written to this
        //  chain,it flows through the components in the order
        //  they were pushed.
        //  the last component could be a Sink,or std::ostream
        //  Sink such std::cout .

      filtering_istream as same as filtering_ostream,a differences that is
      it acts on InputData,not OutputData and the order is reverse to the
      components they are pushed.

      class constructor file_sink() construct a Sink through a file pathname.
      class constructor file_source() consruct a Source through a file pathname.

      //  in <boost/iostreams/device/file_descriptor.hpp>,
      //  file_descriptor_sink() and file_descriptor_source()
      //  do the same things as what file_sink() and file_source() do,
      //  but "descriptor" means they require a file descriptor,and they would
      //  not process code conversion.
      //  as usually,"descriptor" version provides open() method .
      //            Linux use file descriptor
      //            Windows use file handle 
      
      !!  FILE OPERATIONS REQUIRE SUPPORT FROM BOOST LIBRARY,BECAUSE DIFFERENT
          SYSTEM IMPLEMENTS FILE-SYSTEM IN A DIFFERENT WAY.

                    PUSH: C1, C2, ... , Cn, SINK
      OutputData => filtering_ostream { C1 => C2 => ... => Cn => SINK } => real Sink

                    PUSH: C1, C2, ... , Cn, SOURCE
      InputData => { SOURCE => Cn => ... => C2 => C1 } => filtering_istream => buffer



asio >
    Boost.Asio may be used to perform both synchronous and asynchronous operations
    on I/O objects.

    Synchronous operations :
      Program ->
      I/O Object ->
      I/O Execution Context ->
      Operating System
      <- Operating System
      <- I/O Execution Context
      <- I/O Object
         Program

    Asynchronous operations :
      Program -> {
        I/O Object
        Completion Handler
      }
      I/O Object ->
      I/O Execution Context ->
      Operating System
      <- Operating System
      <- I/O Eexcution Context
      <- Completion Handler
         Program

    I/O Object :
      the specific I/O object such socket,file,pipe, etc.
      e.g.
        boost::asio::ip::tcp::socket object

    I/O Execution Context :
      it represents the link of program to the operating system's I/O services.
      the program at least one I/O execution context,such as an
        boost::asio::io_context object
        boost::asio::thread_pool object
        boost::asio::system_context object

    Completion Handler :
      a function or function object with the signature 
        void <completion_handler_name>(const boost::system::error_code &);

    any request program initiates on a specific I/O object,the corresponding I/O Execution Context
    object will as an agent submits this request to Operating System.
    after the action for the request accmoplished by Operating System,it returns the result of the
    operation to I/O execution context.
    I/O Execution Context translates any error resulting from the operation into an object of
    type boost::system::error_code,the result is then forwarded back up to the I/O object.
    I/O object throws an exception of type boost::system::system_error if the operation failed.
    /*  Some overloaded version of action-methods does not throw an exception,as instead,such methods
     *  requires an object of type boost::system::system_error as the additional parameter.
     *  e.g.
     *    boost::asio::ip::tcp::socket s(boost::asio::io_context{});
     *    s.connect(server_endpoint);      //  throw
     *    boost::system::system_error ec;
     *    s.connect(server_endpoint, ec);  //  no throw
     */

    the advantage for boost.asio library that is :
      >  portability
           boost has different implementations to different Operating System
      >  scalability
           facilitate concurrent connections
      >  efficiency
           support some special techniques allow programs to minmise data copying
      >  model concepts from established APIs
           such BSD sockets
      >  ease of use
           it is complex but ease of to learn how to use them
      >  basis for further abstraction
           permit the development of other libraries that provide higher levels of abstraction

      /*  I figure that boost.asio is another wraper of POSIX.1 I/O APIs,the POSIX.1 I/O APIs
       *  are flexible to composing,feature require on demand.
       *  but even POSIX.1 is a standard about system features,might a special system does not
       *  support some particular features.
       *  and new to such OS have to learn the POSIX.1 features on that OS,it maybe spend a lot of
       *  times.
       *  another problem is resource manage,the object holds relative resource its lifetime is
       *  unclear,some resource have to be manually recycled by programmer.
       *  high-level abstract layer such boost.asio will eliminates the problems occurred on the
       *  low-level interace.
       *  e.g.
       *    POSIX.1 API :
       *      int socket = -1;
       *      errno = 0;
       *      socket = socket(AF_INET, SOCK_STREAM, IPPROT_TCP);
       *      if (socket < 0) {
       *              fprintf(stderr, "Failed to acquire a socket in tcp protocol.\n");
       *              exit(errno);
       *      }
       *      errno = 0;
       *      if (connect(socket, server_endpoint, server_endpoint_length) < 0) {
       *              fprintf(stderr, "Failed to establish connection with server.\n");
       *              exit(errno);
       *      }
       *      ...
       *      shutdown(socket, SHUT_RDWR);  //  if @socket is a local variable,and returned from
       *                                    //  a special worker but did not release the resource
       *                                    //  it represents,then the resource will be existing until
       *                                    //  program exit and recycled by kernel.
       *      ...
       *    
       *    Boost.Asio :
       *      boost::asio::ip::tcp::socket socket(boost::asio::io_context{});
       *      boost::system::system_error ec;
       *      socket.connect(server_endpoint, ec);
       *      ...
       *      //  connection will be released when the I/O object is destructing.(RAII)
       *      //  programmer need not to manage resource manually.
       *      //  programmer need not to learn about the low-level APIs on a specific system,just
       *      //  learn about APIs of boost.asio as well.
       */

    Tutorial :
      Using a timer synchronously :
        header <boost/asio.hpp>
        I/O Execution context => boost::asio::io_context

        !!  library list :
              boost_thread(boost thread) pthread(posix event)
              //  boost library system had became head-only since 1.6.69

        boost::asio::steady_timer :
          an asio core class.
          it is a type definition of (selected automatically)
            boost::asio::basic_waitable_timer<chrono::steady_clock>  //  C++
            boost::asio::basic_waitable_timer<boost::chrono::steady_clock>  //  boost

          one of waitable_timer constructors :
            /**
             * basic_waitable_timer - the class template of waitable timer
             * @ex:                   boost asio I/O execution context pointer
             * @expiry_time:          boost time_point pointer for time to wait
             */
            basic_waitable_timer(const executor_type &ex, const time_point &expiry_time)
            : impl_(0, ex)  //  implementation
            {
              ...
            }

          member method :
            /**
             * wait - member method wait to request @impl_ call to
             *        its wait primitive through get_service() API
             *        to wait time duration specifed by @expiry_time
             * throw: type boost::system::error_code,error set by
             *        @impl_.get_service().wait().
             */
            void wait();

          attributes :
            disabled copy-construction
            disabled assignment

        <boost/asio/chrono.hpp>
          //  boost wrapper
          using boost::asio::chrono::seconds = std::seconds;

        <chrono>
           template<typename _Clock, typename _Dur>
           struct time_point :
             it is a C++ template struct used to product a time duration.

           template<typename _Rep, typename _Period>
           struct duration :
             it is a C++ template struct used to represent a time duration.
             the default value of @_Period is "ratio<1>".

             type definitions :
               using rep = _Rep;
               using period = typename _Period::type;

             private data member :
               rep __r;

             one of duration constructors :
               template<typename _Rep2, typename = _Require<
                                        is_convertible<const _Rep2&, rep>,
                                        __or_<_is_float<rep>,
                                        __not_<__is_float<_Rep2>>>>>
               constexpr explicit duration(const _Rep2 &__rep)
               : __r(static_cast<rep>(__rep)) { } 

           using seconds = duration<_GLIBCXX_CHRONO_INT64_T>;

        usage :
          create an I/O Execution Context,and used it to create a boost timer
          with a specified time duration.
          call wait() on it to wait time expired synchronously.

          e.g.
            boost::asio::steady_timer timer(boost::asio::io_context{},
                                            boost::asio::chrono::seconds(SECONDS));
            ...
            timer.wait();
            ...

      Using a timer asynchronously :
        boost ASIO asynchronously defines a completion token,which determines how
        the result will be delivered to a completion handler when an asynchronous
        operation completes.
        //  similar to Linux signal mechanism.
        
        the ASIO steady_timer also support to asynchronous operations.
        the member method wait() is synchronous,constray,the method async_wait()
        is asynchronous.

        the method run() of boost ASIO io_context is used to tell the 
        asynchronous waiter a completion event.and ASIO provides a guarantee that
        completion handlers will only be called from threads that are currently
        calling boost::asio::io_context::run().
        //  run() return to caller thread unless completion handler has returned,
            and there is no more thing to does.
        //  if no completion handler have been registered,then run() returns
        //  immediately from the invocation.

        <boost/asio/basic_waitable_timer.hpp>
          ////
          //  async_wait - the template member method of class basic_waitable_timer
          //               to processes an asynchronously waiting
          //  @TP1:        type template parameter boost asio completion token
          //  @TP2:        non-type template parameter specified default handler
          //  
          //  @token:      rvalue of completion handler which is a function or a
          //               function object in type void (*)(boost::system::error_code)
          //               # parameter in type "const boost::system::error_code &" is okay
          //  return:      a template class async_result instance
          //  # this function used tail return type definition
          //    template function async_initiate() is defined in
          //    <boost/asio/async_result.hpp>
          //  # this function does not suspend caller
          template<BOOST_ASIO_COMPLETION_TOKEN(void (boost::system::error_code))
                   WaitToken = default_completion_token_t<executor_type>
                  >
          auto
          waitable_timer::async_wait(WaitToken &&token =
                                     default_completion_token_t<executor_type>())
          -> decltype(async_initiate<WaitToken, void (boost::system::error_code)>(
                      declval<initiate_async_wait>(), token));

        <boost/asio/io_context.hpp>
          typedef std::size_t count_type;

        <boost/asio/impl/io_context.ipp>
          ////
          //  run - complete an asynchronous waiting,call to completion handler
          //  return:   return value of run() the private io_context::impl_ call to
          io_context::count_type io_context::run();

      Binding arguments to a completion handler :
        C++ std::bind primitive is able to bind arguments for a function or a
        function object.

        <boost/asio/basic_waitable_timer.hpp>
          ////
          //  expires_at - sets the expiry time(accurate time point)
          //               any pending asynchronous wait operations will be
          //               cancelled
          //               the handler for each cancelled operation will be
          //               invoked with the boost::asio::error::operation_aborted
          //               error code
          //  @expiry_time:        asynchronous wait expires at @expiry_time
          //  return:              the number of asynchronous operations that
          //                       were cancelled
          //  throw:               boost::system::system_error
          //  # asynchronous wait already expired when expires_at() called,
          //    then the handlers for asynchronous wait operations will
          //    have already been invoked or have been queued for invocation in
          //    near furture
          //    ! these can not be cancelled.
          //  # this method come with several overload versions.
          std::size_t basic_waitable_timer::expires_at(const time_point &expiry_time);

          ////
          //  expires_after - similar to expires_at() method,but this method
          //                  require a time duration
          //
          std::size_t basic_waitable_timer::expires_after(const duration &expiry_time);

          ////
          //  expiry - obtain the timer's current expiry time
          //
          time_point basic__waitable_timer::expiry() const;

          e.g.
            tick at each second,maximum counter is 8 :
              namespace basio = boost::asio;

              void tick_second(boost::system::system_error ec,
                               basio::steady_timer *t,
                               std::size_t *counter)
              {
                if (*counter < 5) {
                  ...
                  ++*counter;
                  // adjust expiry time,these works can be done before next time tick comes
                  t->expires_at(t->expiry() + basio::chrono::seconds(1));
                  // initiate a new asynchronous wait operation
                  t->async_wait(std::bind(tick_second, basio::placeholders::error,
                                          t, counter));
                  /**
                   * the function wrapper created by std::bind is the correct type that
                   * @WaitToken required(function signature)
                   * call to handler :
                   *   WaitToken &&token(error_code from io_context);
                   *   -> token(error_code from io_context, steady_timer *bound2,
                   *            counter *bound3);
                   *   operator() overload on function object.
                   */
                }
                // no more asynchronous wait operation to be initiated,run() return
                   to caller.
              }

SmartPtr >
    Boost.SmartPtr: The Smart Pointer Library

    smart pointer class templates:
      scoped_ptr:  used to contain ownership of a dynamically allocated object
                   to the current scope.
      scoped_array:  provides scoped ownership for a dynamically allocated array.
      shared_ptr:  a versatile tool for managing shared ownership of an object or
                   or array.
      weak_ptr:  a non-owning observer to a shared_ptr-managed object that can be
                 promoted temporarily to shared_ptr.
      intrusive_ptr:  a pointer to objects with an embedded reference count.
      local_shared_ptr:  providing shared ownership within a single thread.

      //  shared_ptr and weak_ptr are part of the C++ standard from C++11.

    utility functions and classes:
      make_shared(),allocate_shared():  factory functions for creating objects 
                                        that return a shared_ptr.
      make_unique():  factory function returning std::unique_ptr.
      allocate_unique():  factory function for creating objects using an allocator
                          that return a std::unique_ptr.
      enable_shared_from_this:  helper base class that enables the acquisition
                                of a shared_ptr pointing to this.
      enable_shared_from:  a newer and better replacement for enable_shared_from_this.
      pointer_to_other:  helper trait for converting one smart pointer type to
                         another.
      static_pointer_cast:  generic smart pointer casts.
      intrusive_ref_counter:  helper base class containing a reference count.
      atomic_shared_ptr:  helper class implementing the interface of std::atomic
                          for a value of type shared_ptr.

      !  the destructor or operator delete for an object managed by pointers in
         the library are not allowed to throw exceptions.

    scoped_ptr :
      scoped_ptr is a simple solution for simple needs,supplies a basic
      "resource acquisition is initialization" facility,without shared-ownership
      or transfer-of-ownership semantics.
      
      scoped_ptr - noncopyable
                   cannot be used in C++ Standard Library containers.
                   cannot correctly hold a pointer to a dynamically allocated array

      <boost/smart_ptr/scoped_ptr.hpp>
        namespace boost {
          template<class T>
          class scoped_ptr {
            ...
          };
        }
        
        element type :
          typedef T element_type;
        
        construct and destruct :
          explicit scoped_ptr(T *p = 0) noexcept;
  
          /*  the destructor or the operator delete of the object is type of T
           *  forbid throw exception.
           *  and T must be a complete type.(Succeed to constructed)
           */
          ~scoped_ptr() noexcept;
  
        member functions :
          /*  reset - member function reset @pointer to @p.
           *          the previous object pointed by @pointer
           *          will automatically freed.
           */
          void reset(T *p = 0) noexcept;
  
          /*  operator* - overload operator *  */
          T &operator*() const noexcept;
          
          /*  operator-> - overload member-accessing operator  */
          T *operator->() const noexcept;
  
          /*  get - returns the raw pointer.  */
          T *get() const noexcept;
  
          /*  operator bool - overload type converting,enforce explicit.  */
          explicit operator bool() const noexcept;
          
          /*  swap - swap two scoped_ptr objects.
           *  @b:    another,it will swap to this.
           */
          void swap(scoped_ptr &b) noexcept;
  
        free functions :
          template<class T>
          void swap(scoped_ptr<T> &a, scoped_ptr<T> &b) noexcept;
  
          template<class T>
          bool operator==(scoped_ptr<T> const &p, std::nullptr_t) noexcept;
      
          template<class T>
          bool operator==(std::nullptr_t, scoped_ptr<T> const &p) noexcept;
          
          template<class T>
          bool operator!=(scoped_ptr<T> const &p, std::nullptr_t) noexcept;
          
          template<class T>
          bool operator!=(std::nullptr_t, scoped_ptr<T> const &p) noexcept;
  
      e.g.
        void func(void)
        {
          boost::scoped_ptr<int> pInt(new int(10));  //  explicit construct.
          if (pInt == NULL)                   //  free function calls.
            throw std::abort();
        }  //  @pInt dead,and the memory of a int object with value 10 freed automatically.

      !!  the primary reason to use scoped_ptr rather than std::auto_ptr or std::unique_ptr
            1>  "resource acquisition is initialization" to be applied only for
                the current scope and have no intent to transfer ownership.
            2>  prevent a later maintenance programmer from adding a function
                that transfers ownership by returning the auto_ptr,because
                saw auto_ptr,and assumed ownership could safely be transferred.

    scoped_array :
      the scoped_array class template stores a pointer to a dynamically allocated array.
      it is similar to scoped_ptr,but it is designed for array.

      scoped_array - noncopyable
                     cannot be used in C++ standard library containers
                     cannot correctly hold a pointer to single object
                     no more space overhead than a built-in array pointer
      //  need an array in C++ standard library containers?
      //  see shared_ptr<T[]>

      !  std::vector is an alternative to scoped_array that is a bit heavier
         duty but far more flexible.
         boost::array is an alternative that does not use dynamic allocation.

      <boost/smart_ptr/scoped_array.hpp>
        namespace boost {
          template<class T>
          class scoped_array {
            ...
          };
        }
  
        element type :
          typedef T element_type;
  
        construct and destruct :
          /*  storing a copy of p,which must have been allocated via a
           *  C++ new[] expression or be 0.
           *  T is not required be a complete type.
           */
          explicit scoped_array(T *p = 0) noexcept;
  
          /*  T must be complete,and delete[] on the stored pointer must not
           *  throw exceptions.
           */
          ~scoped_array() noexcept;
  
        member functions :
          /*  reset - reset the internal array pointer to newer.
           *  @p:     the new array address with element type T.
           */
          void reset(T *p = 0) noexcept;
  
          /*  operator[] - overload random access operator.  */
          T &operator[](std::ptrdiff_t i) const noexcept;
  
          /*  get - get the raw array address.  */
          T *get() const noexcept;
  
          /*  operator bool - overload converting,enforce explicit calling.  */
          explicit operator bool() const noexcept;
  
          /*  swap - swap current array to another.
           *  @b:    referrence to a scoped_array object.
           *  #  T need not be a complete type.
           */
          void swap(scoped_array &b) noexcept;
  
        free functions :
          template<class T>
          void swap(scoped_array<T> &a, scoped_array<T> &b) noexcept;
  
          template<class T>
          bool operator==(scoped_array<T> const &p, std::nullptr_t) noexcept;
  
          template<class T>
          bool operator==(std::nullptr_t, scoped_array<T> const &p) noexcept;
  
          template<class T>
          bool operator!=(scoped_array<T> const &p, std::nullptr_t) noexcept;
  
          template<class T>
          bool operator!=(std::nullptr_t, scoped_array<T> const &p) noexcept;

      e.g.
        void func(void)
        {
          boost::scoped_array<int> paV(new int[5]);
          if (paV == nullptr)
            throw std::abort();
          paV[0] = 3;
        }

    shared_ptr :
      it is a class template stores a pointer to a dynamically allocated object.

      shared_ptr deletes the exact pointer that has been passed at construction
      time,complete with its original type,regardless of the template parameter.
      e.g.
        std::shared_ptr<void> p(new int(5));
        //  @p destruct,"delete __interPointer" __interPointer points to a
            int object with value 5 but it is type of void *.

      shared_ptr - copyconstructible
                   moveconstructible
                   copyassignable
                   moveassignable
                   can be used in standard library containers
                   comparison operators are supplied

      !  because the implementation uses reference counting,cycles of shared_ptr
         instances will not be reclaimed.
         e.g.
           struct A {
             std::shared_ptr<A> __interPointer;
             ...
           };

           void func(void)
           {
             A *pA = new A;
             std::shared_ptr<A> spA(pA);
             spA->__interPointer.reset(pA);
             //  A's use count will be 2.
             //  @spA destructed,A will be leaved dangling with a use count of 1.
             //  "weak_ptr" can "break cycles".
           }

      shared_ptr<T> can be implicitly converted to shared_ptr<U> whenever T*
      can be implicitly converted to U* .
      in particular,shared_ptr<T> is implicitly convertible to shared_ptr<T const>,
      to shared_ptr<U> where U is an accessible base of T,and to shared_ptr<void>.

      !  shared_ptr can be used to hold a pointer to a dynamically allocated array.
         this is accomplished by using an array type (T[] or T[N]) as the template
         parameter.
         if template-parameter = T[N]
           operator[] index range checking will be enabled.

      !  avoid using unnamed shared_ptr tempraries to save typing.

      <boost/smart_ptr/shared_ptr.hpp> "or <memory>  /*  C++11  */"
        namespace boost {
          class bad_weak_ptr : public std::exception;
          template<class T> class weak_ptr;
          template<class T>
          class shared_ptr {
            ...
          };
        }

        element type :
          /*  element_type is T when T is not an array type,and U when T
           *  is U[] or U[N].
           */
          typedef ... element_type;

        construct and destruct :
          /*  these two constructors construct an empty shared_ptr  */
          constexpr shared_ptr() noexcept;
          constexpr shared_ptr(std::nullptr_t) noexcept;

          /*  Y must be a complete type.
           *  delete p or delete[] p cannot throw exceptions.
           *  when T is U[N],Y(*)[N] must be convertible to T* ,
           *  when T is U[],Y(*)[] must be convertible to T*,
           *  otherwise,Y* must be convertible to T* .
           *  the constructor is a template in order to remember the 
           *  actual pointer type passed,the destructor will call delete with
           *  the same pointer,complete with its original type,even when
           *  T does not have a virtual destructor or is void.
           */
          template<class Y>
          explicit shared_ptr(Y *p);

          /*  unique_ptr constructor  */
          template<class Y, class D>
          shared_ptr(std::unique_ptr<Y, D> &&r);
          
          ...
          
          /*  if *this is empty,or shares ownership with another shared_ptr
           *  instance(use_count() > 1),there are no side effects.
           *  if *this owns a pointer p and a deleter d,d(p) is called.
           *  if *this owns a pointer p,and have no deleter d,delete p is called.
           */
          ~shared_ptr() noexcept;

        member functions :
          /*  reset - no parameter,do nothing.  */
          void reset() noexcept;

          /*  reset - reset internal pointer to a new pointer.
           *  @p:     the new pointer.
           */
          template<class Y>
          void reset(Y *p);

          /*  reset - reset internal pointer to new pointer and also
           *          replace deleter.
           *  @p:     new pointer.
           *  @d:     deleter.
           */
          template<class Y, class D>
          void reset(Y *p, D d);

          /*  operator* - overload pointer deref operator.  */
          T &operator*() const noexcept;

          /*  operator-> - overload member accessing operator.  */
          T *operator->() const noexcept;

          /*  operator[] - overload random accessing operator.  */
          element_type &operator[](std::ptrdiff_t i) const noexcept;

          /*  get - get the raw pointer.  */
          element_type *get() const noexcept;

          /*  unique - if use_count() == 1.  */
          bool unique() const noexcept;

          /*  use_count - return the number of local_shared_ptr objects,
           *              *this included,that share ownership with *this
           *              or 0 when *this is empty.
           */
          long use_count() const noexcept;

          /*  operator bool - overload bool converting and enforce explicit.  */
          explicit operator bool() const noexcept;

          /*  operator shared_ptr<Y> - convert T* to Y* .  */
          template<class Y>
          operator shared_ptr<Y>() const noexcept;

          /*  operator weak_ptr<Y> - returns a copy of the owned shared_ptr.
          template<class Y>
          operator weak_ptr<Y>() const noexcept;

          /*  swap - exchange *this to b.  */
          void swap(local_shared_ptr &b) noexcept;

          /*  owner_before - it be like of operator< .  */
          template<class Y>
          bool owner_before(shared_ptr<T> const &r) const noexcept;
          template<class Y>
          bool owner_before(weak_ptr<Y> const &r) const noexcept;

          /*  owner_equals - true if and only if *this and @r share ownership
           *                 or are both empty.
           */
          template<class Y>
          bool owner_equals(weak_ptr<Y> const &r);
          template<class Y>
          bool owner_equals(shared_ptr<Y> const &r) const noexcept;

          /*  owner_hash_value - returns an unspecified hash value such that
           *                     two instances that share ownership have the
           *                     same hash value.
           */
          std::size_t owner_hash_value() const noexcept;

        free functions :
          template<class T, class U>
          bool operator==(shared_ptr<T> const &a, shared_ptr<U> const &b) noexcept;
                                                  //  std::nullptr_t
                          //  std::nullptr_t

          template<class T, class U>
          bool operator!=(shared_ptr<T> const &a, shared_ptr<U> const &b) noexcept;
                                                  //  std::nullptr_t
                          //  std::nullptr_t

          template<class T, class U>
          bool operator<(shared_ptr<T> const &a, shared_ptr<U> const &b) noexcept;

          template<class T>  
          void swap(shared_ptr<T> &a, shared_ptr<T> &b) noexcept;

          template<class T>
          typename shared_ptr<T>element_type *
          get_pointer(shared_ptr<T> const &p) noexcept;

          template<class T, class U>
          shared_ptr<T> static_pointer_cast(shared_ptr<U> const &r) noexcept;

          template<class T, class U>
          shared_ptr<T> const_pointer_cast(shared_ptr<U> const &r) noexcept;

          template<class T, class U>
          shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const &r) noexcept;

          template<class T, class U>
          shared_ptr<T> reinterpret_pointer_cast(shared_ptr<U> const &r) noexcept;

          template<class E, class T, class Y>
          std::basic_ostream<E, T> &
          operator<<(std::basic_ostream<E, T> &os, shared_ptr<Y> const &p);

          template<class D, class T>
          D *get_deleter(shared_ptr<T> const &p) noexcept;

          //  atomic accessing
          template<class T>
          bool atomic_is_lock_free(shared_ptr<T> const *p) noexcept;

          template<class T>
          shared_ptr<T> atomic_load(shared_ptr<T> const *p) noexcept;
          template<class T>
          shared_ptr<T> atomic_load_explicit(shared_ptr<T> const *p, int) noexcept;

          template<class T>
          void atomic_store(shared_ptr<T> *p, shared_ptr<T> r) noexcept;
          template<class T>
          void atomic_store_explicit(shared_ptr<T> *p, shared_ptr<T> r, int) noexcept;

          template<class T>
          shared_ptr<T> atomic_exchange(shared_ptr<T> *p, shared_ptr<T> r) noexcept;
          template<class T>
          shared_ptr<T>
          atomic_exchange_explicit(shared_ptr<T> *p, shared_ptr<T> r, int) noexcept;

          template<class T>
          bool atomic_compare_exchange(shared_ptr<T> *p, shared_ptr<T> *v,
                                       shared_ptr<T> w) noexcept;
          template<class T>
          bool atomic_compare_exchange_explicit(shared_ptr<T> *p, shared_ptr<T> *v,
                                                shared_ptr<T> w) noexcept;

      e.g.
        void func(void)
        {
          //  these two statements call to copy-constructor.
          shared_ptr<int> pI0(make_shared<int>(3));
          auto pI1(pI0);
          //  use_count() == 2

          //  this statement call to move-constructor.
          shared_ptr<int> pIMoved(std::move(pI1));
          //  use_count() still equal to 2,but @pI1 is in undefined state.

          //  just one memory space for a int object had been allocated.
        }  //  all shared_ptr<int> instances will be destroyed before returns
           //  control to the caller,of couse,the memory space will be recycled.

    weak_ptr :
      the weak_ptr class template stores a "weak reference" to an object that is
      already managed by a shared_ptr.
      to access the object,a weak_ptr can be converted to a shared_ptr using the
      shared_ptr constructor taking weak_ptr,or the weak_ptr member function lock.
      when the last shared_ptr to the object goes away and the object is deleted,
      the attempt to obtain a shared_ptr from the weak_ptr instances that refer
      to the deleted object will fail: constructor throws boost::bad_weak_ptr,
      weak_ptr::lock() returns an empty shared_ptr.

      weak_ptr - copyconstructible
                 assignable
                 can be used in C++ standard library containers
                 comparison operators are supplied
                 operations never throw exceptions

      <boost/smart_ptr/weak_ptr.hpp>
        namespace boost {
          template<class T>
          class weak_ptr {
            ...
          };
        }

        element type :
          /*  element_type is T when T is not an array type,and U when
           *  T is U[] or U[N].
           */
          typedef ... element_type;

        construct and destruct :
          /*  default constructor,constructs an empty weak_ptr.  */
          weak_ptr() noexcept;

          /*  constructs a weak_ptr object from a shared_ptr<Y> object.  */
          template<class Y>
          weak_ptr(shared_ptr<Y> const & r) noexcept;

          /*  aliasing constructor.
           *  create weak_ptr from @r as if by using the corresponding 
           *  converting/copy/move/ constructor,but stores p instead.
           *  use_count() == r.use_count()
           *  when !expired(),shared_ptr<T>(*this).get() == p
           *  !  extension.
           */
          template<class Y>
          weak_ptr(shared_ptr<Y> const & r, element_type *p) noexcept;
          
          /*  template-bound copy-constructor.  */
          weak_ptr(weak_ptr const &r) noexcept;

          /*  template-unbound copy-constructor.  */
          template<class Y>
          weak_ptr(weak_ptr<Y> const &r) noexcept;

          /*  move-constructor.  */
          weak_ptr(weak_ptr &&r) noexcept;

          /*  destructor,destroys this weak_ptr but has no effect on the
           *  object its stored pointer points to.
           */
          ~weak_ptr() noexcept;

        member functions :
          /*  operator=& - copy assignment operator.  */
          weak_ptr &operator=(weak_ptr const &r) noexcept;

          /*  operator=&& - move assignment operator.  */
          weak_ptr &operator=(weak_ptr &&r) noexcept;

          /*  use_count - returns 0(empty weak_ptr) or the number
           *              of shared_ptr objects that share ownership
           *              with *this.
           */
          long use_count() const noexcept;

          /*  expired - if *this has been expired?(if use_count == 0)  */
          bool expired() const noexcept;

          /*  empty - if *this is empty?
           *  #  this function is an extension,not present in std::weak_ptr .
           */
          bool empty() const noexcept;

          /*  lock - convert *this to a shared_ptr object,returned by value.  */
          shared_ptr<T> lock() const noexcept;

          /*  reset - reset *this to another shared_ptr or NULL.  */
          void reset() noexcept;

          /*  swap - exchange *this and @b.  */
          void swap(weak_ptr &b) noexcept;

          /*  owner_before - if *this < @r?  */
          template<class Y>
          bool owner_before(weak_ptr<Y> const &r) const noexcept;
          template<class Y>
          bool owner_before(shared_ptr<Y> const &r) const noexcept;

          /*  owner_equals - if *this and @r share ownership or both empty?  */
          template<class Y>
          bool owner_equals(weak_ptr<Y> const &r) const noexcept;x
          template<class Y>
          bool owner_equals(shared_ptr<Y> const &r) const noexcept;

          /*  owner_hash_value - hash *this and return a hash value.  */
          std::size_t owner_hash_value() const noexcept;

        free functions :
          /*  operator< - operator overload.  */
          template<class T, class U>
          bool operator<(weak_ptr<T> const &a, weak_ptr<U> const &b) noexcept;

          /*  swap - exchange @a and @b.  */
          template<class T>
          void swap(weak_ptr<T> &a, weak_ptr<T> &b) noexcept;

      e.g.
        template<class T>
        void g(const shared_ptr<T> &v)
        {
          boost::weak_ptr<T> w(v);  //  sPInt.use_count() == w.use_count() == 1
          auto sp(w.lock());        //  sPInt.use_count() == sp.use_count() == 2
        }  //  decrease sPInt.use_count(),because @sp destroyed,now it is equal to 1.
           //  destroy @w do not affect @sPInt.

        void f(void)
        {
          boost::shared_ptr<int> sPInt(make_shared<int>(3));  //  sPInt.use_count() == 1
          g(sPInt);
          int *x = new int(10);
          boost::weak_ptr<decltype(*x)> w(sPInt, x);  //  call to aliasing-constructor
                                                      //  no shared_ptr object was created,
                                                      //  w.use_count == sPint.use_count,
                                                      //  but weak_ptr object do not destroy the object
                                                      //  it managed when destructor was called.
          delete x;                                   //  thus have to delete @x
        }

    intrusive_ptr :
      the intrusive_ptr class template stores a pointer to an object with an 
      embedded reference count,every new intrusive_ptr instance increments the
      reference count by using an unqualified call to the function intrusive_ptr_add_ref(),
      passing it the pointer as an argument.
      when an intrusive_ptr is destroyed,it calls intrusive_ptr_release(),this
      function is responsible for destroying the object when its reference count
      drops to zero.

      !  USER HAVE TO PROVIDE intrusive_ptr_add_ref() and intrusive_ptr_release()
         IN NAMESPACE,OTHERWISE,THE BOOST'S HELPER BASE CLASS TEMPLATE intrusive_ref_counter
         MAY HELP ADDING SUPPORT FOR intrusive_ptr TO THE USER TYPES.

      reasons for intrusive_ptr to be used :
        1>  some existing frameworks or OSes provide objects with embedded
            reference counts.
        2>  the memory footprint of intrusive_ptr is the same as the corresponding
            raw pointer.
        3>  intrusive_ptr<T> can be constructed from an arbitrary raw pointer
            of type T*.

      <boost/smart_ptr/intrusive_ptr.hpp>
        namespace boost {
          template<class T>
          class intrusive_ptr {
          ...
          };
        }

        element type :
          typedef T element_type;

        construct and destruct :
          /*  default constructor,construct empty intrusive_ptr object.  */
          intrusive_ptr() noexcept;

          /*  construct instrusive_ptr object with a pointer @p,and add ref_counter
           *  in the object @p points to.
           *  #  if add_ref == false
           *       do not call to intrusive_ptr_add_ref()
           */
          intrusive_ptr(T *p, bool add_ref = true);

          /*  copy-constructor  */
          intrusive_ptr(intrusive_ptr const &r);

          template<class Y>
          intrusive_ptr(intrusive_ptr<Y> const &r);

          /*  move-constructor  */
          intrusive_ptr(intrusive_ptr &&r);
        
          template<class Y>
          intrusive_ptr(intrusive_ptr<Y> &&r);

          /*  destructor,intrusive_ptr_release() would be called.  */
          ~intrusive_ptr();

        member functions :
          /*  assignment  */
          intrusive_ptr &operator=(intrusive_ptr const &r);

          template<class Y>
          intrusive_ptr &operator=(intrusive_ptr<Y> const &r);

          /*  move-assignment  */
          intrusive_ptr &operator(intrusive_ptr &&r);

          template<class Y>
          intrusive_ptr &operator=(intrusive_ptr<Y> &&r);

          /*  reset - reset get() to @r.  */
          void reset();     //  reset to an empty intrusive_ptr.
          void reset (T *r);
          void reset(T *r, bool add_ref);

          /*  member accessing  */
          T &operator*() const noexcept;
          T *operator->() const noexcept;

          /*  get - get the raw pointer.  */
          T *get() const noexcept;

          /*  detach - escapes the safety of automatic referrence counting
           *           provided by intrusive_ptr.it should be used only
           *           where strictly necessary,and when the implications are
           *           thoroughly understood.
           *  #  when use detach() to an instrusive_ptr object,the ref_counter
           *     of the object would not release.
           */
          T *detach() noexcept;

          /*  operator bool - convert intrusive_ptr to bool value and enforce
           *                  explicitly call.
           */
          explicit operator bool() const noexcept;
          
          /*  swap - exchange *this and @b.  */
          void swap(intrusive_ptr &b) noexcept;

        free functions :
          template<class T, class U>
          bool operator==(intrusive_ptr<T> const &a, intrusive_ptr<U> const &b) noexcept;
                                                     //  U *b
                          //  T *a

          template<class T, class U>
          bool operator!=(intrusive_ptr<T> const &a, intrusive_ptr<U> const &b) noexcept;
                                                     //  U *b
                          //  T *a

          template<class T>
          bool operator<(intrusive_ptr<T> const &a, intrusive_ptr<T> const &b) noexcept;

          template<class T>
          void swap(intrusive_ptr<T> &a, intrusive_ptr<T> &b) noexcept;

          template<class T>
          T *get_pointer(intrusive_ptr<T> const &p) noexcept;

          template<class T, class U>
          intrusive_ptr<T>
          static_pointer_cast(intrusive_ptr<U> const &r) noexcept;

          template<class T, class U>
          intrusive_ptr<T>
          const_pointer_cast(intrusive_ptr<U> const &r) noexcept;

          template<class T, class U>
          intrusive_ptr<T>
          dynamic_pointer_cast(intrusive_ptr<U> const &r) noexcept;

          template<class E, class T, class Y>
          std::basic_ostream<E, T> &operator<<(std::basic_ostream<E, T> &os,
                                               intrusive_ptr<Y> const &p);

      e.g.
        struct A {
          int v;
          ssize_t ref_counter;
        };

        void intrusive_ptr_add_ref(A *a)
        {
          ++a->ref_counter;
        }

        void intrusive_ptr_release(A *a)
        {
          --a->ref_counter;
        }

        void func(void)
        {
          A a(0);
          boost::intrusive_ptr<A> intrusive1(&a);   //  a.ref_counter == 1
          boost::intrusive_ptr<A> intrusive2(&a);   //  a.ref_counter == 2
          intrusive1->v = 3;  //  intrusive2.get() == intrusive1.get()
        }
