                                                        The C++ Standard Library 2

Callable Objects :
    objects that can be used to call some functionality >
      1> a function,where additional args are passed to as arguments
      2> a pointer to a member function,which is called for the object passed
         as the first additional argument(reference or pointer) and gets the
         remaining argument as member function parameters
      3> a function object(operator() for a passed object),where additional args
         are passed as arguments
      4> a lambda,which strictly speaking is a kind of function object

    function :
      void func(int a, float b, char c);
      func(1, 1.1, 'c');

    member function :
      void Class::func(Class &obj, int a, float b, char c);
                    /* |                         */
      Class obj;    /* +-> can omit in prototype */
      obj.func(1, 1.1, 'c');

    function object :
      std::function<void (int a, float b, char c)> func(function);
      func(1, 1.1, 'c');

    lambda :
      auto function = [](int a, float b, char c) -> void { ... };
      function(1, 1.1, 'c');

    std::bind :
      the stuff bind of namespace std can be used to bind arguments with callable a object.
      the expression of std::bind returns a callable object,the detail is defined in header
      <tr1/functional>. // just include header <functional> as well

      <tr1/functional>
        template<typename _Functor, typename... _ArgTypes>
        inline _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>
        bind(_Functor __f, _ArgTypes... _args);

        /* another version returns _Bind_result object */

    std::async :
      the stuff async of namespace std can be used to start a new background task in two ways,
      one is async,another one is deferred.std::async is based on C++ promise,it is part of
      C++ future introduced in C++ 11.the header is <future>.

      <future>
        template<typename _Fn, typename... _Args>
        future<__async_result_of<_Fn, _Args...>>
        async(launch __policy, _Fn&& __fn, _Args&&... __args);

        /* launch could be @async,@deferred */

        template<typename _Fn, typename... _Args>
        future<__async_result_of<_Fn, _Args...>>
        async(_Fn&& __fn, _Args&&... __args);

Concurrency and Multithreading :
    Since C++ 11,language core supporting concurrency.
      Introduced memory model
        - it guarantees that updates on two different objects used by two different
          threads are independent of each other
      Introduced new keyword thread_local
        - define thread-specific variables and objects
      /**
       * In Linux,multithreading is implemented by POSIX thread model,the new thread is
       * a lightweight process cloned from the original process,they share the same
       * process address space,but the ip register for them has different instruction
       * position,sp register as the same,and so on.
       */

    The General Concurrency Guarantees of the C++ Standard Library :
      > modifying an object of a standard library type that is sharted between threads
        risks undefined behavior unless objects of that type are explicitly specified
        as being sharable without data races or user supplies a locking mechanism.
      > during the construction of an object in one thread,using it in another thread
        results in undefined behavior,without loss of generality,destruction as the same.
        /* this applies to objects are provided for thread synchronization */
      
      For STL containers :
        > concurrent read-only access is possible
        > concurrent access to different elements of the same container is possible
          (except for vector<bool>)
          /* read/write different elements has different positions in the container,
           * follow this view point,each element in the container is similar to a
           * variable in different memory position
           */    

      For formatted I/O to a _standard stream_ :
        > synchronized with C I/O,concurrent access is possible,although it might
          result in interleaved characters
          /* default behavior for std::cout, std::cin, std::cerr */
          /* std::ios::sync_with_stdio(bool value) is a trigger for such sync */

      > concurrent calls of atexit() and at_quick_exit() are synchronized,and more
        include set_new_handler(),set_unexpected(),set_terminate() and the corresponding
        geters
      > for all member functions of the default allocator except destructor,concurrent
        access is synchronized

      ! the library guarantees that C++ standard library has no "hidden" side effects
        that break concurrent access to different objects.      

Allocators :
    C++ standard library use special objects to handle the allocation and deallocation of
    memory in several places,such object is called "Allocator".they represent a special
    memory model and are used as an abstraction to translate the "need" to use memory
    into a raw "call" for memory.
    /* allocator is part of STL used to solve pointer type problem on PCs,but now as
     * the base for technical solution that use certain memory models withou changing
     * the interfaces.
     */

    the C++ allocator base is defined in <ext/new_allocator.h> inside to namespace std :
      template<typename _Tp>
      class new_allocator;  // allocator for global new

      typedef _TP value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      // more type definitions if __cplusplus <= 201703L
      
      member method allocate() is used to allocate a memory space with aligned specified size.
      member method deallocate() is used to deallocate the memory allocated previously.

    and an alias for std::allocator is introduced in <"architecture depend directory"/bits/c++allocator.h> :
      template<typename _Tp>
        using __allocator_base = __gnu_cxx::new_allocator<_Tp>;  // need __cplusplus >= 201103L

Pairs :
    a type used to treat two values as single unit,the most normal case is key/value pairs.
    the structure pair is defined in <utility> inside to namespace std.

    // the detail is defined in <bits/stl_pair.h>
    template<typename T1, typename T2>
    struct pair {
      ...
    };

    the structure allows :
      copy  move  assign  swap  compare
                                |
                                +--> A.first == B.first && A.second == B.second // operator<
                                 |
                                 +-> A.first < B.first || (!(A.first < B.first) &&
                                 |   A.second < B.second) // operator<
                                 +-> !(A < B) // operator<=
    type definitions :
      typedef _T1 first_type;
      typedef _T2 second_type;

    shortcut :
      /**
       * make_pair - shortcut for make up a pair
       * @_T1:       first type
       * @_T2:       second type
       * @__x:       forward reference to first object
       * @__y:       forward reference to second object
       * return:     value of an object is type of pair<_T1, _T2>{__x, __y}
       * # make_pair() "decay"s and "strip"s _T1 and _T2 for produce types
       *   of @first and @second.for example "a" and "ab" as parameters will
       *   get type const char *,not the const char[2] and const char[3]
       * # because of forward reference,make_pair() can combine with std::move()
       *   when move semantics is applied,and can combine with std::ref() when
       *   reference semantics is applied
       */
      template<typename _T1, typename _T2>
      constexpr pair<_T1, _T2>
      make_pair(_T1 &&__x, __T2 &&__y);

      /**
       * __pair_get - shortcut for get element in a pair object,only specializations
       *              _Int := 0 and _Int := 1 been defined
       */
      template<std::size_t _Int>
      struct __pair_get;

      // get value in pair object,more overloaded versions
      template<std::size_t _Int, class _Tp1, class _Tp2>
      constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type &
      get(std::pair<_Tp1, _Tp2>& __in) noexcept;

    ! because std::tuple is the extend for std::pair,thus template methods std::tuple_size
      and std::tuple_element can be used on an object is type of std::pair.
    ! C++ language rule request an explicit call of a default constructor also initializes
      fundamental data types,for the pair,the constructors first() and second() will be
      called by pair().
    ! since C++ 11,a std::pair using a type that has only a nonconstant copy constructor
      will no longer compile.

    a special constructor of std::pair :
      /**
       * pair - a constructor for std::pair introduced for the situation that @first_type and/or
       *        @second_type is std::tuple
       * @_Args1:    template parameter pack for tuple1
       * @_Args2:    template parameter pack for tuple2
       * @piecewise_construct_t:    void structure used as an identifier
       * @tuple objects:    std::tuple for @first and/or @second
       * # if the type of data member is not tuple,then implicit type conversion will
       *   take place during construct the object
       */
      template<typename... _Args1, typename... _Args2>
      _GLIBCXX20_CONSTEXPR
      pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

Tuples :
    extend pairs to represent a heterogeneous list  of elements for which the types are specified
    or deduced at compile time.
    for tuple apply C++ 98 features,the implementation defined at least ten template parameters,that
    is the maximum number of elements.the newer C++ 11 supported template parameter pack,thus there
    can have more than ten elements in a tuple.

    <tuple>
      /* tuple - tuple is a container extended std::pair */
      /* tuple is in namespace std */
      template<typename... _Elements>
      class tuple : public _Tuple_impl<0, _Elements...>
      {
        ...
      };

    shortcut :
      /* make_tuple - template function used to makeup a tuple object and return it */
       * # because make_tuple() is a template function,thus automatically type deduce
       *   will process
       * # std::ref() and std::cref() combined with make_tuple() is possible to
       *   let tuple include an element whose type is a lvalue reference or a const lvalue
       *   reference.by using reference with make_tuple(),allow extract values of a tuple
       *   back to some other variable
       */
      template<typename... _Elements>
      constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
      make_tuple(_Elements&&... __args);

      /* tie - makeup a tupe with lvalue references and return it
       * # for const lvalue reference,the types pass to template should with const quantifier
       * # std::ignore can be used as a placeholder to tell tie() do not process reference
       *   binding on "this" element
       */
      template<typename... _Elements>
      constexpr tuple<_Elements&...>
      tie(_Elements&... __args) noexcept;


      /* __get_helper - this implementation applied a special programming technique to extract
       *                the specified __i-th element in a tuple object
       * # used template metaprogramming technique
       */
      template<std::size_t __i, typename _Head, typename... _Tail>
      constexpr _Head&
      __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
      { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

      /* get - get @__i-th element in a tuple,this routine returns std::__get_helper<__i>(__t) */
      template<std::size_t __i, typename... _Elements>
      constexpr __tuple_element_t<__i, tuple<_Elements...>>&
      get(tuple<_Elements...>& __t) noexcept;

      ! because get() returns a value is constexpr,that means it is compile-time constant,thus
        index __i can not be a variable is not constexpr.
        e.g.
          int i(0); // @i is not a constexpr value,that it is runtime variable
          auto t(make_tuple(1, 1.1, 'c');
          auto x = get<i>(t);
      ! pass an invalid index also throw a compile-time error.

    Allowed operations :
      assign  copy  move  swap  compare
                                |
                                +--> A.@all == B.@all
                                 |
                                 +-> A1 < B1 || (!(A1 < B1) && (A2 < B2 || .. // lexicographical comparison
                                 |
                                 +-> !(A < B)
    
    Tuple and Initializer lists :
      std::tuple<@types> t(@arguments);      //  OK,call to copy constructor
      std::tuple<@types> t1{@arguments};     //  OK,call to copy constructor
      std::tuple<@types> t2 = {@arguments};  //  ERROR,call to assignment operator
                                             //  for process assignment,the rvalue must been constructred
                                             //  t2 = std::tuple<@types>{@arguments}; => OK

      std::vector<std::tuple<int, float>> v{{1, 1.1}, {2, 1.2}};  // ERROR
      // but it is OK when @value_type is std::pair<int, float> or std::vector
      // it is OK when combine std::make_tuple() with initializer list
      //   std::vector<std::tuple<int, float>> v{std::make_tuple(1, 1.1), std::make_tuple(2, 2.2)};

      return {1, 2, 3}; in a function which returns a value is type of std::tuple<int, int, int>.
      // ERROR for std::tuple,but it is OK for std::vector

    Additional Tuple Features :
      /**
       * tuple_size - structure template in namespace std used to calculate the number of elements
       *              in std::tuple object
       * # operator sizeof...() is a compiler feature used to get number of types in template
       *   parameter pack
       * # integral_constant::value is the number of elements of "this" tuple object
       */
      template<typename... _Elements>
      struct tuple_size<tuple<_Elements...>>
      : public integral_constant<std::size_t, sizeof...(_Elements)> { };

      /**
       * tuple_element - structure template in namespace std used to get the type of a specified
       *                 element in std::tuple object
       * # recursive derive itself,used template metaprogramming technique
       * # type definition "typedef _Head type;" is introduced in the specialization that __i := 0,
       *   @type is the type of that @__i-th element 
       */
      template<std::size_t __i, typename _Head, typename... _Tail>
      struct tuple_element<__i, tuple<_Head, _Tail...>>
      : tuple_element<__i - 1, tuple<_Tail...>> { };

      /**
       * tuple_cat - function template in namespace std used to concatenates multiple tuples into
       *             one tuple
       * # this function template receive forward reference
       * # this function applied trailing return type function definition
       */
      template<typename... _Tpls,
               typename = typename enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
      constexpr auto
      tuple_cat(_Tpls&&... __tpls)
      -> typename __tuple_cat_result<_Tpls...>::__type
      {
        ...
      }
        
    I/O for Tuples :
      std::tuple does not provide operator<< overload for output values to standard output through
      std::cout(nor standard error std::cerr).

      if you want it,then you have to implement it.

      e.g.
        // use compile-time recursion to traverse every element
        // in the tuple object,and print them to standard output
        // *template metaprogramming*
        
        template<std::size_t IDX, std::size_t MAX, typename... _TupleTypes>
        struct PrintTuple {
          static void print(std::tuple<_TupleTypes...> &t)
          {
            std::cout << std::get<IDX>(t) << " ";
            PrintTuple<IDX + 1, MAX, _TupleTypes...>::print(t); // print next one
          }
        };

        // partial specialization to end the recursion
        template<std::size_t MAX, typename... _TupleTypes>
        struct PrintTuple<MAX, MAX, _TupleTypes...> {
          static void print(std::tuple<_TupleTypes...> &t)
          { }
        }

        // caller
        template<typename... _TupleTypes>
        void printTuple(std::tuple<_TupleTypes> &t)
        {
          PrintTuple<0, std::tuple_size(t), _TupleTypes...>::print(t);
        }

        std::tuple<@types> x(std::make_tuple<@type>{@arguments});
        printTuple(x);

    Conversions between tuples and pairs :
      for convert std::tuple to std::pair,should construct the std::pair by special
      constructor piecewise_construct_t as its first parameter.

      for convert std::pair to std::tuple,should instantiate a partial specialization
      2-element tuple template.that partial specialization includes construction and
      assignment from a std::pair.
      <tuple>
        template<typename _T1, typename _T2>
        class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
        {
          ...
        };

        // construction for a 2-elements tuple from a pair
        // function definition outside to class definition
        template<typename _T1, typename _T2>
        template<typename _U1, typename _U2, _ImpliciCtor<true, const _U1&, const _U2&> = true>
        constexpr
        tuple<_T1, _T2>::tuple(const pair<_U1, _U2> &__in)
        noexcept(__nothrow_constructible<const _U1 &, const _U2 &>())
        : _Inherited(__in.first, __in.second)
        { }

Smart Pointers :
    header - <memory>

    shared_ptr :
      pointer that can be shared by several owners,and memory is recycled when the reference
      count become _zero_.

      the destructor of shared_ptr call to "delete" as a default behavior,thus,if used it
      with array together,must define an array-specified destruction policy.
      for do this,should pass it a callable object that the callback function,it will be
      called in destructor.
      define a deleter :
        std::shared_ptr<int> pInt(new int[10], [](int *p) -> void { delete[] p; });

      a helper officially provided for std::unique_ptr for array-deleting also can be
      used with std::shared_ptr.
        std::default_delete<@type[]>()

      destruction policy :
        of couse,the deleter of std::shared_ptr can be an object of a user-defined class.
        in this case,operator() must be overloaded.
        the object will be called in destructor of std::shared_ptr through @obj(@type pointer)
        function calling.

        ! notice that,the destruction policy is not deallocate memory only.it could do everything
          that we want.but at the last,it must deallocate the memory.the overload operator()
          can pass the pointer to another function,hand over the deallocating to them.this is
          useful when handle system share resources such shared memory.

      ! can not create several std::shared_ptr objects refer to the same one object,this will bring
        a problem that the object is deallocated more than once.
        # copy an existed std::shared_ptr object is OK
        # keep only one group of shared pointers owns an object
      ! std smart pointer stuff class template std::enable_shared_from_this can pass the "this"
        pointer in a class method to the outside place.
        e.g.
          class A : public std::enable_shared_from_this<A>
          {
          public:
            void func(std::vector<A> &vec)
            {
              ...
              vec.push_back(shared_from_this()); // OK
              ...
            }
            ...
          };
          /* if no std::enable_shared_from_this,then send @this to another std::shared_ptr group is
           * an error
           * another way,is pass the pointer of class object as additional parameter for that method,
           * but that is not elegant.
           * !! CAN NOT shared_from_this() WHEN AN OBJECT IS CONSTRUCTING,OF COURSE DESTRUCTING.
           */

      ! deleter of std::shared_ptr would be called after methods reset(),operator=(&),operator=(&&)
        if this shared_ptr is the last owner of the original pointer.

      ! deleter that passed to constructor shall not throw.
    
      some member methods :
        shared_ptr(sp2, ptr)     /* alias constructor,creates a shared pointer "sharing" ownership
                                  * of @sp2 but referring to @ptr
                                  * useful when we want get a pointer points to a member of a
                                  * structure,this can prevent unexpected destorying to the
                                  * structure object when we using its member
                                  */
        swap(sp2)                /* exchange raw pointer */
        reset()                  /* reset raw pointer to nullptr */
        reset(new)               /* reset raw pointer to @new */
                                 !! after called reset() method, the std::weak_ptr
                                    created from the std::shared_ptr will be invalidated,
                                    operation on the std::weak_ptr will throw exception
                                    bad_weak_ptr,std::weak_ptr::expired() returns true
        operator*()              /* derefer */
        operator->()             /* member access on pointer */
        use_count()              /* how many instances are existing */
        unique()                 /* if use_count() == 1 ? */
        get()                    /* get the raw pointer */
        operator bool()          /* raw pointer == nullptr ? false : true */
        owner_before(sp2)        /* provide a strict weak ordering with another shared pointer */
        owner_before(wp)         /* provide a strict weak ordering with a weak pointer */

      logical operations :
        ==  !=  <  <=  >=  >
        /* logical operations are use the raw pointer as the real operand */

      some std stuffs :
        make_shared(...)
        allocate_shared(@allocator, ...)
        swap(sp1, sp2)
        static_pointer_cast      /* for convert a shared_ptr of @type1 to @type2,should use this
                                  * static casting,not the static_cast<@type2*>(sp)
                                  */
        dynamic_pointer_cast     
        const_pointer_cast
        get_deleter(sp)
        operator<<(sp)           /* output raw pointer got by @sp.get() */       

      some atomic interfaces :
        atomic_is_lock_free(&sp) /* whether atomic operations on @sp is lock-free */
        atomic_load(&sp)         /* return *@sp */
        atomic_store(&sp, sp2)   /* *@sp = sp2 */
        atomic_exchange(&sp, sp2) /* exchange *@sp and @sp2 */

    weak_ptr :
      std::weak_ptr is introduced for solve the following two problems they might happens when using
      std::shared_ptr :
        1> cyclic references
             A -> B
             B -> A
        2> explicitly share but not own an object
           semantics : the lifetime of a reference to an object outlives the object it refers to
           /* dangling pointer */

      std::weak_ptr,allows sharing but now owning an object.for use this class,require a shared
      pointer,whenever the last shared pointer owning the object lose its ownership,any std::weak_ptr
      automatically becomes empty.so,except default and copy constructors,std::weak_ptr provides
      only a constructor taking a std::shared_ptr object.

      ! dereference operator and member access operator are not supported by std::weak_ptr,for
        do these operations,must use the std::weak_ptr to create a std::shared_ptr at first.
        in this way we can :
          1> checks whether the pointer is NULL,if it is,then throw an exception or create
             empty std::shared_ptr object
          2> we are using the referred object,that the object referred by the std::shared_ptr
             will not be deallocated unexpectedly

      some member methods :
        weak_ptr(sp)                /* create std::weak_ptr from @sp */
        weak_ptr(wp2)               /* create std::weak_ptr from @wp2,sharing ownership of @wp2 */
        operator=(sp)               /* give up original ownership,and get new */
        operator=(wp2)              /* give up original ownership,and get new */
        swap(wp2)                   /* exchange */
        reset()                     /* give up current ownership,then this become empty */
        use_count()                 /* number of shared owners or 0 if this is empty */
        expired()                   /* whether this weak ptr is empty,that use_count() == 0 */
        lock()                      /* create a std::shared_ptr from this */
        owner_before(wp2)           /* provide a strict weak ordering with another weak pointer */
        owner_before(sp)            /* provide a strict weak ordering with a shared pointer */

      usage :
        std::shared_ptr<int> pInt(new int(10));

        std::weak_ptr<int> weakPInt(pInt);
        std::shared_ptr<int> weakPIntOP(weakPInt);

        *weakPIntOP = 20;

    unique_ptr :
      smart pointer that exclusive ownership,used for RAII to prevent resource leak.

      template<typename _Tp, typename _Dp = default_delete<_Tp>>
      class unique_ptr {
        template<typename _Up>
        using _DeleterConstraint = 
          typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

        __uniq_ptr_data<_Tp, _Dp> _M_t;
      public:
        using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
        using element_type = _Tp;
        using deleter_type = _Dp;
        ...
      }; /**
          * struct __uniq_ptr_impl<>
          * struct __uniq_ptr_data<> : public __uniq_ptr_impl<>
          *
          * struct default_delete<>
          * struct default_delete<>::operator()(@type *__ptr) const -> void
          * # just do static assert,and "delete" @__ptr
          * # a specification of default_delete is @type = _Tp[]
          */

      std::unique_ptr<> disallow to be initialized through assignment syntax.
        std::unique_ptr<int> pInt = new int(10);  /* ERROR */

      default constructor for std::unique_ptr<> will create an object with nullptr.
        std::unique_ptr<@type> up;  /* @up is nullptr */

      a runtime error should to be prevented :
        int *x = new int(10);
        std::unique_ptr<int> up1(x);  /* OK */
        std::unique_ptr<int> up2(x);  /* ERROR,@up1 and @up2 own same data */

      unique pointer can be used with array :
        std::unique_ptr<int[]> up(new int[4](0));
    
        /* do not need to define deleter suit to array destroying.
         * but std::unique_ptr<> also support to custom deleter.
         * pass it a customized deleter as the second template parameter
         * can let std::unique_ptr<> make use of new deleter.
         * the deleter must be callable!
         * # _Dp could be std::function<>,that means lambda function is legal
         */

      disallow :
        copy  assignment

      allow :
        move  swap  "assign nulltpr"
        
        /* allow "swap" means std::swap(up1, up2) is OK */
      special constructor :
        unique_ptr<...>(@ptr, @del) /* owns @ptr,use @del as deleter */
                                    /* @del is rvalue,then it must be MoveConstructible
                                     * @del is lvalue,then it must be CopyConstructible
                                     */
        special format make use of this constructor :
          std::unqiue_ptr<@type, @deleter&> up(@ptr @del);  /* @del is a lvalue type of @deleter */

          ! disallow pass deleter as the second parameter is rvalue but @_Dp is a lvalue reference.
              std::unique_ptr<@type, const @deleter&> up(@ptr, @del-expression-produce-rvalue);

      some member methods :
        reset()                /* reset to nullptr */
        reset(newp)            /* give up to original,get new ownership of @newp */
        release()              /* give up to original,and return the raw pointer */
        get()                  /* get raw pointer */
        get_deleter()          /* get return the lvalue reference to the deleter */
                               /* this method actually call to _M_t._M_deleter(),
                                * and that method is come from __uniq_ptr_impl.
                                */
        operator bool()        /* get() == pointer() ? false : true
                                * pointer() will create a nullptr
                                */
        operator*()
        operator->()
        operator[](@idx)

      logical operations :
        ==  !=  <  <=  >=  >

      resource destroyed if :
        lifetime of the std::unique_ptr object is end
        reset() method is called
        either operator=(nullptr) or operator=(&&) is called

Numeric Limits :
    template class numeric_limits<> is provided by C++,C++ make use of it to replace and
    supplement the ordinary preprocessor C constants which are available in headers
    <climits> and <limits.h>,floating-point types are available in headers <cfloat> and
    <float.h>.

    Advantages of numeric limits :
      1> offers more type safety
      2> enables a programmer to write templates that evaluate these limits
         /* so any error can be detected during compile-time */

    Minimum Size of Built-In Types :
      the minimum guaranteed precision of types.

      char 1B
      short int 2B
      int 2B
      long int 4B
      long long int 8B
      float 4B
      double 8B
      long double 8B

      /* these limits are platform-independent */

    Class numeric_limits<> :
      it is a common interface that is implemented for each type.

      <limits>
        struct __numeric_limits_base;
        
        template<typename _Tp>
        struct numeric_limits : public __numeric_limits_base
        {
          /* this bool variable is a static member in __numeric_limits_base,used to
           * indicates whether the specified type has a specialization exists
           */
          static _GLIBCXX_USE_CONSTEXPR bool __numeric_limits_base::is_specialized;

          /* methods used to return minimum value and maximum value of @_Tp */
          static _GLIBCXX_CONSTEXPR _Tp
          min() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

          static _GLIBCXX_CONSTEXPR _Tp
          max() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

          /* each specialization re-defined these two methods by return
           * __glibcxx_min(@type),and __glibcxx_max(@type)
           */
          ...
        };

        /* partial specializations const @_Tp and volatile @_TP,const volatile @_Tp are void */
        /* for each built-in type,header <limits> specialized one template for it. */

        /* rounding style for floating-point types */
        enum float_round_style {
          round_indeterminate = -1,
          round_toward_zero = 0,
          round_to_nearest = 1,
          round_toward_infinity = 2,
          round_toward_neg_infinity = 3
        };

        /* de-normalization for floating-point types */
        enum float_denorm_style {
          denorm_indeterminate = -1,
          denorm_absent = 0,
          denorm_present = 1
        };

      some useful data members :
        is_specialized    /* if specialization exist */
        is_signed         /* signed */
        is_integer        /* integer */
        is_exact          /* calculations produce no rounding erros */
        digits            /* character/integer - number of bits,excluding sign */
        radix             /* integer - base of the representation(almost always 2)
                           * floating point - base of the exponent representation
                           */
        has_denorm        /* whether type allows denormalized values */
        has_denorm_loss   /* loss of accuracy is detected as a denormalization loss rather
                           * than as an inexact result
                           */

      some useful methods :
        lowest()          /* maximum negative finite value(meaningful if @is_bounded */
        epsilon()         /* difference of 1 and least value greater than 1,C constant FLT_EPSLION, ... */
        round_style()     /* rounding style */
        round_error()     /* measure of the maximum rounding error(ISO/IEC 10967-1)
        infinity()        /* positive infinity,if available */
        quiet_NaN()       /* quiet "Not a Number",if available */
        signaling_NaN()   /* signaling "Not a Number",if available */
        denorm_min()      /* minimum positive denormalized value */

Type Traits and Type Utilities :
    Purpose of Type Traits :
      a type trait provides a way to deal with the _peroperties_ of a type.
      it is a template,which at compile time yields a specific type or value based
      on one or more passed template arguments,which are usually types.
      type traits are building blocks for generic code.

    std::is_pointer<> :
      <type_traits>
        /**
         * integral_constant<> has a static member,its type will be the
         * first template parameter,and its value will be the second
         * template parameter,and its name is @value
         * of course,it has a type-definition "typedef integral_constant<_Tp, __v> type",
         * thus ::type can be used for class deriving
         * operator () been overloaded in the structure,it returns @value.
         */

        typedef integral_constant<bool, false> false_type;
        typedef integral_constant<bool, true> true_type;

        // no(match everything) template parameter specialization
        // this means,except pointer type,any others are
        // get false
        template<typename>
        struct __is_pointer_helper : public false_type
        { };

        ! of course,similar to function,we can accept function parameter,
          but do not name it,that means we do not want to make use of it,
          just as an indicator

        // pointer type template parameter specialization
        template<typename _Tp>
        struct __is_pointer_helper<_Tp *> : public true_type
        { };

        template<typename _Tp>
        struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
        { };

      e.g.
        // it's OK,because @value is static linkage and declared with
        // constexpr
        // compiler will optimizes this if-else statement depends on the @type
        if (std::is_pointer<@type>::value) {
          ...
        } else {
          ...
        }

      !! can not use std::is_pointer<> in expression "@cond ? @v1 : @v2" .
      !! std::is_pointer<> can be used as an argument of a function's parameter,
         which type either is std::true_type or std::false_type,can be used as an
         calling indicator.
         e.g.
           template<typename T>
           void func(@params, std::false_type) { ... }

           template<typename T>
           void func(@params, std::true_type) { ... }

           template<typename T>
           void call_to_func_is_int(@params)
           {
             func(@params, std::is_integral<T>());
           }

    Processing the Common Type :
      type traits can be used to solve the problem process the "common type" of two or more types.
      because,the function can only returns the value with one type,if we want it to return the
      value with a common type from its parameters,then we can make use of type traits to determine
      which type should be returned.
      by make use of template metaprogramming technique,we can determine the real return type of
      such function through find common type of the types of its parameters during compile-time.

      ! if these types have no common type,then attempt to find a common type is an error.

      std::common_type<> : (header <type_traits>)
        // no detail,because we use this
        // as the Prototype for specializations
        template<typename... _Tp>
        struct common_type;

        // Partial-Specialization
        // sizeof...(T) == 0
        template<>
        struct common_type<>
        { };

        // Partial-Specialization
        // sizeof...(T) == 1 => common type is T
        template<typename _Tp0>
        struct common_type<_Tp0> : public common_type<_Tp0, _Tp0>
        { };

        // Partial-Specialization
        // sizeof...(T) == 2
        template<typename _Tp1, typename _Tp2>
        struct common_type<_Tp1, _Tp2> : public __common_type_impl<_Tp1, _Tp2>::type
        { };

        // Partial-Specialization
        // sizeof...(T) > 2
        // recursive checks
        // common_type<common_type<_Tp1, _Tp2>::type, _Rp...> ... 
        template<typename _Tp1, typename _Tp2, typename... _Rp>
        struct common_type<_Tp1, _Tp2, _Rp...>
        : public __common_type_fold<common_type<_Tp1, _Tp2>, __common_type_pack<_Rp...>>
        { };

        // Prototype
        // impl of common type when sizeof...(T) == 2
        template<typename _Tp1, typename _Tp2,
                 typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
        struct __common_type_impl
        {
          using type = common_type<_Dp1, _Dp2>;
        };

        // Partial-Specialization
        // impl of common type when sizeof...(T) == 2
        // and _Dp1 == _Tp1, and _Dp2 == _Tp2
        // evaluate common type of _Tp1 and _Tp2
        template<typename _Tp1, typename _Tp2>
        struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
        : private __do_common_type_impl
        {
          using type = decltype(_S_test<Tp1, _Tp2>(0));
        }

        /**
         * structure __do_common_type_impl defined an alias
         *   template<typename _Tp, typename _Up>
         *   using __cond_t = decltype(true? std::declval<_Tp>() : std::declval<_Up>());
         *   # "@cond ? @v1 : @v2" expression produce a value @v1 or @v2,and the value
         *     can be used by decltype keyword to produce the exact type
         *   # keyword declval
         *       introduced since C++ 11
         *       produce a rvalue reference to the type T,but do not evaluate it
         *                                                           (no real object makeup)
         * and defined template methods _S_test<>(),_S_test_2<>() and their overloaded 
         * versions for find common type of the given types
         */

    Unary Type Predicates : (result in std::true_type or std::false_type)
      is_void<T>
      is_integral<T>
      is_floating_point<T>
      is_arithmetic<T>
      is_signed<T>
      is_unsigned<T>
      is_const<T>
      is_volatile<T>
      is_array<T>
      is_enum<T>
      is_union<T>
      is_class<T>
      is_function<T>
      is_reference<T>
      is_lvalue_reference<T>
      is_rvalue_reference<T>
      is_pointer<T>
      is_member_point<T>
      is_member_object_pointer<T>
      is_member_function_pointer<T>
      is_fundamental<T>                void,integral,floating-point,std::nullptr_t
      is_scalar<T>                     integral,floating-point,enumeration,pointer,member point,std::nullptr_t
      is_object<T>                     any type except void,function,reference
      is_compound<T>                   array,enumeration,union,class,function,reference,pointer
      is_trivial<T>
      is_trivially_copyable<T>
      is_standard_layout<T>
      is_pod<T>
      is_literal_type<T>

      is_empty<T>
      is_polymorphic<T>
      is_abstract<T>
      has_virtual_destructor<T>

      is_default_constructible<T>
      is_copy_constructible<T>
      is_move_constructible<T>
      is_copy_assignable<T>
      is_move_assignable<T>
      is_destructible<T>

      is_trivially_default_constructible<T>
      is_trivially_copy_constructible<T>
      is_trivially_move_constructible<T>
      is_trivially_copy_assignable<T>
      is_trivially_move_assignable<T>
      is_trivially_destructible<T>

      is_nothrow_default_constructible<T>
      is_nothrow_copy_constructible<T>
      is_nothrow_move_constructible<T>
      is_nothrow_copy_assignable<T>
      is_nothrow_move_assignable<T>
      is_nothrow_destructible<T>

    Traits for Relations : (result in std::true_type or std::false_type)
      is_same<T1, T2>
      is_base_of<T, D>
      is_convertible<T, T2>
      is_constructible<T, Args...>
      is_trivially_constructible<T, Args...>
      is_nothrow_constructible<T, Args...>
      
      is_assignable<T, T2>
      is_trivially_assignable<T, T2>
      is_nothrow_assignable<T, T2>
      uses_allocator<T, Alloc>

    Traits for Type Modifications : (produce a type)
      remove_const<T>
      remove_volatile<T>
      remove_cv<T>
      add_const<T>
      add_volatile<T>
      add_cv<T>
      make_signed<T>
      make_unsigned<T>
      remove_reference<T>
      add_lvalue_reference<T>
      add_rvalue_reference<T>
      remove_pointer<T>
      add_pointer<T>

    Other Type Traits :
      rank<T>                                number of dimensions of an array type(or 0)
      extent<T, I = 0>                       extent of dimension I(or 0)
      remove_extent<T>
      remove_all_extents<T>
      uderlying_type<T>                      underlying type of an enumeration type
      decay<T>                               transfers to corresponding "by-value" type
                                             T &, T &&, T * => T
      enable_if<B, T = void>                 yields T only if B is TRUE
      conditional<B, T, F>                   B ? T : F
      common_type<T1, ...>
      result_of<F, ArgTypes>                 type of calling F with argument types ArgTypes
      alignment_of<T>                        alignof(T)
      aligned_storage<Len>
      aligned_storage<Len, Align>
      aligned_union<Len, Types...>

Reference Wrappers :
    class std::reference_wrapper<> decalred in header <functional>,which is used primarily to "feed"
    references to function templates that take their parameter by value.
    std::reference_wrapper<> can also be used in some STL containers such std::vector<>,std::pari<>,
    std::tuple<> and std::array<>,etc.for specify that type of element is the reference to type T.
    /* just use template argument @type& will failed on compile */

    <bits/refwrap.h> /* implementation file */
      // base of ref wrapper
      template<typename _Tp>
      struct _Reference_wrapper_base
      : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>
      { };

      // memfun ref wrapper base
      template<typename _Tp, bool = is_member_function_pointer<_Tp>::value>
      struct _Reference_wrapper_base_memfun
      : _Reference_wrapper_base<_Tp>
      { };

      // memfun ref wrapper base partial specialization
      template<typename _MemFunPtr>
      struct _Reference_wrapper_base_memfun<_MemFunPtr, true>
      : _Mem_fn_traits<_MemFunPtr>::__maybe_type
      {
        using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
      }

      // primary reference_wrapper
      template<typename _Tp>
      class reference_wrapper
      : public _Reference_wrapper_base_memfun<typename remove_cv<_Tp>::type>
      {
        _Tp *_M_data; // private data member
                      // used to store the real object of type @_Tp
        
        _GLIBCXX20_CONSTEXPR
        static _Tp *_S_fun(_Tp &__r) noexcept
        { return std::__addressof(__r); }

        static void _S_fun(_Tp&&) = delete;

        // used to checks whether the type parameter of constructor is same to @_Tp
        // default T of std::enable_if<> is void,if @_Tp is not same as @_Up,then
        // is_same<> get false_type,and __not_same get type void
        template<typename _Up, typename _Up2 = __remove_cvref_t<_Up>>
        using __not_same = typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;

      public:
        typedef _Tp type;

        // constructor
        // @__uref:    forward reference parameter to the argument.when makeup reference_wrapper,
        //             a lvalue / rvalue to the argument is pass to constructor,and @_M_data then
        //             points to the object(address get through _S_fun())
        template<typename _Up, typename = __not_same<_Up>,
                 typename = decltype(reference_wrapper::_S_fun(std::declval<_Up>()))>
        _GLIBCXX20_CONSTEXPR
        reference_wrapper(_Up &&__uref)
        noexcept(noexcept(reference_wrapper::_S_fun(std::declval<_Up>())))
        : _M_data(reference_wrapper::_S_fun(std::forward<_Up>(__uref)))
        { }

        ...
        _GLIBCXX20_CONSTEXPR
        _Tp& get() const noexcept
        {
          return *_M_data;
        }
        _GLIBCXX20_CONSTEXPR operator _Tp&() const noexcept
        {
          return this->get();
        }
        ...

        #if __cpp_deducation_guides
        template<typename _Tp>
        reference_wrapper(_Tp &) -> reference_wrapper<_Tp>;
        #endif

        // produce a lvalue reference
        template<typename _Tp>
        _GLIBCXX20_CONSTEXPR
        inline reference_wrapper<_Tp>
        ref(reference_wrapper<_Tp> __t) noexcept
        {
          return __t;
        }

        // produce a const lvalue reference
        template<typename _Tp>
        _GLIBCXX20_CONSTEXPR
        inline reference_wrapper<const _Tp>
        cref(reference_wrapper<_Tp> __t) noexcept
        {
          return { __t.get() };
        }
      };

    so we can easy to know that,std::reference_wrapper<> is converted to @_Tp& when
    where the @_Tp& is required.it use a pointer points to the original object,and
    convert *@_M_data to @_Tp&.
    such STL container std::vector<std::reference_wrapper<int>>,element type will be
    std::reference_wrapper<int>.when construct an element,a int object should be
    passed to the constructor of std::reference_wrapper<int> as forward reference
    parameter,then @_M_data points to the int object.when we need a reference to int,
    operator int&() will be invoked,which return *@_M_data.

    std::ref() and std::cref() is call to the member functions ref() and cref() of
    std::reference_wrapper<>,respectively.an object is type of std::reference_wrapper<@_Tp>
    or of std::reference_wrapper<const @_Tp> as the result returns to caller.
    the type @_Tp of the std::reference_wrapper<> object returned by cref() will becomes const @_Tp,
    thus operator _Tp&() => operator const @type&() .

Auxiliary Functions :
  Minimum and Maximum :
    header <algorithm>
    namespace std
      min(a, b)                      a < b ? a : b
      min(a, b, cmp)                 minimum between @a and @b,comparing with @cmp
      min(init-list)                 minimum between @init-list,comparing with "<"
      min(init-list, cmp)            minimum between @init-list,comparing with @cmp
      max(a, b)                      a > b ? a : b
      max(a, b, cmp)                 maximum between @a and @b,comparing with @cmp
      max(init-list)                 maximum between @init-list,comparing with ">"
      max(init-list, cmp)            maximum between @init-list,comparing with @cmp
      minmax(a, b)                   minimum and maximum of @a and @b,comparing with "<"
        /* std::pair<int, int> minmax(std::minmax(3, 7)); */
      minmax(a, b, cmp)              minimum and maximum of @a and @b,comparing with @cmp
      minmax(init-list)              minimum and maximum of @init-list,comparing with "<"
      minmax(init-list, cmp)         minimum and maximum of @init-list,comparing with @cmp

  Swap :
    header <utility>
    namespace std
      swap(a, b)                     exchange contents of @a and @b
                                     ! if either operand is a class type,then member method
                                       swap() must be defined,and which receive an operand
                                       is type of another parameter of swap(@a, @b)
                                       if both operands are class type,then each other must
                                       defined swap() member method with another type

  Comparison :
    header <utility>
    namespace std::rel_ops
      operator!= <> (a, b)             !(@a == @b)
      operator> <>  (a, b)             @b < @a
      operator<= <> (a, b)             !(@b < @a)
      operator>= <> (a, b)             !(@a < @b)

    the purpose is to reduce the number of operator overloading definitions of a class type.
    by use of these four template function,a class can only defines operator== and operator<
    as well.

    e.g.
      class c {
      public:
        bool operator<(const c &p1, const c &p2) const
        { return p1.__data < p2.__data; }

        bool operator==(const c &p1, const c &p2) const
        { return p1.__data == p2.__data; }

        ...
      private:
        int __data;
        ...
      };

      using namespace std::rel_ops;

      c c1(8), c2(16);

      /* from clas definition */
      c1 < c2;
      c1 == c2;

      /* implemented by rel_ops */
      c1 > c2;
      c1 != c2;
      c1 >= c2;
      c1 <= c2;

  Compile-Time Fractional Arithmetic :
    header <ratio>
    namespace std
      template<intmax_t _Num, intmax_t _Den = 1>
        struct ratio {
          static_assert(_Den != 0, "denominator cannot be zero");
          static_assert(_Num >= -__INTMAX_MAX__ && _Den >= -__INTMAX_MAX__,
                        "out of range");

          /**
           * header <ratio>
           * template<intmax_t _Pn>
           * __static_sign : integral_constant<intmax_t, (_Pn < 0) ? -1 : 1>
           * { };
           *
           * template<intmax_t _Pn>
           * __static_abs : integral_constant<intmax_t, __Pn * __static_sign<_Pn>::value>
           * { };
           *
           * template<intmax_t _Pn, intmax_t _Qn>
           * struct __static_gcd : __static_gcd<_Qn, (_Pn % _Qn)>
           * # stopped when either @_Pn or @_Qn becomes _zero_
           * # @_Pn == 0 => derive integral_constant<intmax_t, __static_abs<_Qn>::value>
           * # @_Qn == 0 => derive integral_constant<intmax_t, __static_abs<_Pn>::value>
           */
          static constexpr intmax_t num =
            _Num * __static_sign<_Den>::value / __static_gcd<_Num, _Den>::value;

          static constexpr intmax_t den =
            __static_abs<_Den>::value / __static_gcd<_Num, _Den>::value;

          typedef ratio<num, den> type;
        };

        usage :
          typedef std::ratio<64, 8> sfe; /* 64/8 */
          auto num(sfe::num); /* @num == 8 */
          auto den(sfe::den); /* @den == 1 */

        ratio_add<@ratio1, @ratio2>                => using ratio_add = typename __ratio_add<@ratio1, @ratio2>::type
                                                      returns ratio<>
        ratio_subtract<@ratio1, @ratio2>           => using raiot_subtract = typename __ratio_subtract<@ratio1, @ratio2>::type
                                                      returns ratio<>
        ratio_multiply<@ratio1, @ratio2>           => using ratio_multiply = typename __ratio_multiply<@ratio1, @ratio2>::type
                                                      returns ratio<>
        ratio_divide<@ratio1, @ratio2>             => using ratio_divide = typename __ratio_divide<@ratio1, @ratio2>::type
                                                      returns ratio<>

        ratio_equal<@ratio1, @ratio2>              @ratio1 == @ratio2 <-> @num1 == @num2 AND @den1 == @den2
        ratio_not_equal<@ratio1, @ratio2>          @ratio1 != @ratio2 => !(@ratio1 == @ratio2)
        ratio_less<@ratio1, @ratio2>               @ratio1 < @ratio2
        ratio_less_equal<@ratio1, @ratio2>         @ratio1 <= @ratio2 => @ratio1 < @ratio2 AND @ratio1 == @ratio2
        ratio_greater<@ratio1, @ratio2>            @ratio1 > @ratio2 =>  !(@ratio1 < @ratio2) AND !(@ratio1 == @ratio2)
        ratio_greater_equal<@ratio1, @ratio2>      @ratio1 >= @ratio2 => !(@ratio1 < @ratio2)
                                                   /* comparison returns std::false_type or std::true_type */

Clocks and Timers :
    Chrono Libraray :
      header <chrono>
      namespace std::chrono

      design purpose - timers and clocks might be different on different systems and improve over
                       time in precision,reduce the number of interfaces that needed for switch
                       time precision.
                       provide precision-neutral concept by separating duration and point of time
                       from specific clocks.

      time duration - a time duration is defined as a specific number of ticks over a time unit.
      time point    - a time point is defined as combination of a duration and a beginning of time(epoch)
      
      ! the concept of a timepoint is parametrized by a clock,which is the object that defines the epoch of
        a timepoint.different clocks have different epochs.

          +--> timepoint          +--> timepoint          +--> timepoint
          |                       |                       |
      [ - - - - - - - - - - - - - - - - - - - - - - - - - - ]
                        |                   |
                        +----> duration <---+
                        |
                        +--> epoch of a clock 

    Durations :
      a duration is a combination of a _value_ representing the number of ticks and a _fraction_
      representing the unit in seconds.ratio<> is used to specify the fraction.

      <chrono>
        /**
         * duration - struct template used to represent time duration
         * @_Rep:     type of tick
         * @_Period:  period of ticks
         *            # ratio<60> => 60/1 seconds -> 1 tick is 60/1 seconds(1minute)
         *              ratio<1> => 1/1 second   -> 1 tick is 1 second
         *              ratio<1, 1000> => 1/1000 seconds -> 1 tick is 1/1000 second == 1ms
         * # @_Rep is floating-point type allows we pass arguments such 0.3, 0.5, and so on
         *   values to duration's construction.
         */
        template<typename _Rep, typename _Period = ratio<1>>
        struct duration;

        type-definition :
          using rep = _Rep;
          using period = typename _Period::type;

        private-data :
          rep __r;

        constructor :
          constexpr duration() = default;

          template<typename _Rep2, typename = _Require<is_convertible<const _Rep2&, rep>,
                                                       __or_<is_float<rep>,
                                                       __not_<__is_float<_Rep2>>>>>
          constexpr explict duration(const _Rep2 &__rep)
          : __r(static_cast<rep>(__rep)) { }

        copy-constructor :
          duration(const duration &) = default;

          template<typename _Rep2, typename _Period2,
                   typename = _Require<is_convertible<const _Rep2 &, rep>,
                                       __or_<__is_float<rep>,
                                             __and_<is_harmonic<_Period2>,
                                                    __not_<__is_float<_Rep2>>>>>
          constexpr duration(const duration<_Rep2, _Period2> &__d)
          : __r(duration_cast<duration>(__d).count()) { }
                // cast type of @__d to type of this duration object

        some useful methods :
          count()           =>        return @__r

          /* these three methods are wrappers of the same name methods from
           * struct template duration_values<_Rep>
           */
          zero()            =>        return rep(0)
                                      duration of zero length
          min()             =>        return numeric_limits<rep>::lowest()
                                      minimum possible duration of this type

          max()             =>        return numeric_limits<rep>::max()
                                      maximum possible duration of this type

          operator=(d)      =>        *this = @d
          operator+         =>        +this_duration
          opeartor-         =>        -this_duration

          operator++()      
          operator++(int)   
          operator--()
          operator--(int)
          operator+=(d)     =>        @__r += @d.count()
          operator-=(d)     =>        @__r -= @d.count()
          operator*=(r)     =>        @__r *= @r
          operator/=(r)     =>        @__r /= @r

          template <typename _Rep2 = rep>
          operator%=(d || r)
                            =>        @__r %= @d.count() || @__r %= @r

          /* there are two non-member methods used to implement "add" and "subtract" */
          operator+(d1, d2) =>        let ctd as common_type<d1_type, d2_type>
                                      return ctd(ctd(@d1).count() + ctd(@d2).count())

          operator-(d1, d2) =>        let ctd as common_type<d1_type, d2_type>
                                      return ctd(ctd(@d1).count() - ctd(@d2).count())

          !! when assign a duration to another duration,the tick types of them one
             are different,such one is integral,another is floating-point,must explicit
             convert tick type before assignment.
             e.g.
               std::chrono::seconds halfmin;
               std::chrono::duration<double, std::ratio<60>> thirtyseconds(0.5);
               halfmin = thirtyseconds; // ERROR
               halfmin = std::chrono::duration_cast<std::chrono::seconds>(thirtyseconds); // OK

             # this rule should also be followed when period is different,such 1/1 and 60/1,
               1/1 => 1 tick is 1s,60/1 => 1 tick is 60s(1 minute).
               e.g.
                 std::chrono::seconds s(55);
                 std::chrono::minutes m;
                 m = s; // ERROR
                 m = std::chrono::duration_cast<std::chrono::minutes>(s); // OK

             # std::chrono::duration_cast<> is used to cast duration type

        pre-defined special duration :
          using nanoseconds = duration<_GLIBCXX_CHRONO_INT64_T, nano>;
          using microseconds = duration<_GLIBCXX_CHRONO_INT64_T, micro>;
          using milliseconds = duration<_GLIBCXX_CHRONO_INT64_T, milli>;
          using seconds = duration<_GLIBCXX_CHRONO_INT64_T>;
          using minutes = duration<_GLIBCXX_CHRONO_INT64_T, ratio<60>>;
          using hours = duration<_GLIBCXX_CHRONO_INT64_T, ratio<3600>>;
          using days = duration<_GLIBCXX_CHRONO_INT64_T, ratio<86400>>;
          using weeks = duration<_GLIBCXX_CHRONO_INT64_T, ratio<604800>>;
          using months = duration<_GLIBCXX_CHRONO_INT64_T, ratio<2629746>>;
          using years = duration<_GLIBCXX_CHRONO_INT64_T, ratio<31556952>>;

    Clocks and Timepoints :
      relationship between clock and timepoint -
        a clock defines an epoch and a tick period,and a clock provides a type for any timepoint
        specified according to this clock.
        a timepoint represents a specific point in time by associating a positive or negative
        duration to a given clock.

      type definition and static member for each clock -
        clock::duration        duration type of this clock
        clock::rep             tick type of this clock
        clock::period          unit type of this clock  /* duration::period */
        clock::time_point      timepoint of this clock
        clock::is_steady       is it steady?
        clock::now()           yield a time_point for the current point in time

      C++ standard library clocks :
        std::system_clock - <chronon> as a structure
          represents timepoints associated with the usual real-time clock of the current system
          /**
           * provides static member methods for map to C api
           *   static std::time_t to_time_t(const time_point &__t) noexcept;
           *   # implementation make use of duration_cast<> and force type convert std::time_t()
           *   static time_point from_time_t(std::time_t __t) noexcept;
           *   # implementation make use of time_point_cast<>
           */

        std::steady_clock - <chronon> as a structure
          steady clock,never gets adjusted,thus timepoint values never decrease as the physical
          time advances,and they advance at a steady rate relative to real time
          /* monotonic clock */
        
        std::high_resolution_clock - <chronon> as a structure
          represents a clock with the shortest tick period possible on the current system
          /* using high_resolution_clock = system_clock; */

        ! standard does not provide requirements for the precision,the epoch,the range of the
          clocks.
        ! the durations of system_clock and steady_clock are the same chrono::nanoseconds.
        ! if a program have to compare or compute the difference of two times,should make use of
          steady_clock than system_clock,because steady_clock never adjusted.
      
      the time_point object :
        <chrono>
          namespace - std::chrono

          template<typename _Clock, typename _Dur>
          struct time_point {
            typedef _Clock clock;
            typedef _Dur duration;
            typedef typename duration::rep rep;
            typedef typename duration::period period;

            // default constructor
            constexpr time_point() : __d(duration::zero())
            { }

            // constructor
            constexpr explicit time_point(const duration &__dur)
            : __d(__dur)
            { }

            // copy-constructor
            template<typename _Dur2, typename = _Require<is_convertible<_Dur2, _Dur>>>
            constexpr time_point(const time_point<clock, _Dur2>& __t)
            : __d(__t.time_since_epoch())
            { }

            // observer
            constexpr duration
            time_since_epoch() const
            { return __d; }

            ...
        
          private:
            duration __d;
          };

          some useful operations :
            min()                    -    time_point(duration::min())
            max()                    -    time_point(duration::max())
            operator+=(__dur)        -    @__d += @__dur   
            operator-=(__dur)        -    @__d -= @__dur

            // the following methods are make use of time_since_epoch() method
            operator+(tp, dur)       -    @tp.time_since_epoch() + @dur
            operator+(dur, tp)       -    @dur + @tp.time_since_epoch()
            operator-(tp, dur)       -    @tp.time_since_epoch() - @dur
            operator-(tp1, tp2)      -    @tp1.time_since_epoch() - @tp2.time_since_epoch()
            operator==(tp1, tp2)     -    @tp1 == @tp2
            operator!=(tp1, tp2)     -    !(@tp1 == @tp2)
            operator<(tp1, tp2)      -    @tp1 < @tp2
            operator<=(tp1, tp2)     -    @tp1 <= @tp2
            operator>(tp1, tp2)      -    @tp1 > @tp2
            operator>=(tp1, tp2)     -    @tp1 >= @tp2

          time_point_cast :
            /**
             * time_point_cast<> - cast time_point
             * @_ToDur:            duration of the time_point that convert to
             * @_Dur:              duration of the time_point that is original
             * @_Clock:            clock of the time_point(s)
             * @__t:               original time_point object
             * return:             a new time_point<_Clock, _ToDur> object
             * # function make use of methods duration_cast<> and __t.time_since_epoch()
             */
            template<typename _ToDur, typename _Clock, typename _Dur>
            constexpr typename enable_if<__is_duration<_ToDur>::value,
                                         time_point<_Clock, _ToDur>>::type
            time_point_cast(const time_point<_Clock, _Dur>& __t);

      ! timepoint can not less than its epoch or greater than its maximum duration.
      ! C++ does not defined time stamp string casting routines in addition,because
        C library provided routine ctime() to handle this work.
        but only the timepoint of system_clock is able to be converted to time_t type.
      ! time_point always associated with a clock,only a timepoint without clock is no sense.
      ! C library routine gmtime() can get UTC time stamp from time_t type,the result is
        stored in structure tm.

The Standard Template Library :
    STL Components :
      containers - used to manage collections of objects of a certain kind.
      iterators  - used to step through the elements of collections of objects.
                   major advantage :
                     offer a small but common interface for any arbitraty container type.
      algorithms - used to process the elements of collections.
                   and programmer is able to supply certain auxiliary functions called by
                   the algorithms to suit needs even if that needs is very special or complex.

      the concept of the STL is based on a separation of data and operations. /* generic */
                                                                              /* object-oriented */
      the data is managed by container classes,and the operations are defined by configurable
      algorithms.iterators are the glue between these two components,they let any algorithm
      interact with any container.
      /* thanks to template,we can delay type determining to compile-time,compiler will produce
       * the appropriate code for us.
       */

      all components are templates for any type,provided that type is able to perform the required
      operations.
      containers and algorithms are generic for arbitrary types and classes,respectively.

    Containers :
      container classes(containers) manage a collection of elements.

      C++ STL containers -
        Sequence Containers :
          ordered collections in which every elements has a certain position,this position depends
          on the time and place of the insertion,but it is independent of the value of the element.
            array
            vector
            deque(circularity)
            list(doubly-linked)
            forward-list


        Associative Containers :
          sorted collections in which the position of an element depends on its value(or key - key/value pair)
          due to a certain sorting criterion.
            set
            multi set
            map
            multi map
          ! the criterion of sorting takes the form of a function that compares either the value or,
            if it is a key/value pair,the key.
            the default comparison is operator<,but support to customized comparison routine.
          ! typically implemented as binary tree,key of left child < key of parent < key of right child.
            time complexity for reading is O(logN).
          ! support type and duplicates handling are depend on the container.
          ! for containers map and multimap,the element type is std::pair<>,thus,methods first() and second()
            of std::pair<> are able to be called on the element of these containers.
          ! since C++11,for elements that have the same key,newly inserted elements are inserted at the end of
            equivalent elements that multisets and multimaps already contain.
            in addition,the order of equivalent lements is guaranteed to remain stable if insert(),emplace(),
            or erase() is called.
            

        Unordered Containers : (unordered associative containers)
          unordered collections in which the position of an element does not matter.the only important question
          is whether a specific element is in such a collection.value and order of insertion have no influence
          on the position,and the position might change over the lifetime of the container.
            unordered set
            unordered multi set
            unordered map
            unordered multi map

          ! features provided since C++11.
          ! a specific element is "somewhere" in the container.
          ! typically implemented as a hash table,array of linked lists.
          ! use of unordered containers provides amortized constant complexity(access O(1)),provided
            that it has a good function.


        ! STL collection types are completely distinct from one another and have very different implementations
          that are not derived from one another.
        ! automatic sorting is only a useful "side effect" of the implementation of an associative container,
          designed to enable better performance;but sequence containers also support to manually sorting.

      Sequence Container - vector : <vector>
        a vector manages its elements in a dynamic array.
          enable random access operator[]
          appending and removing elements at the end of the array is very fast
          // appending elements is amortized very fast,an individual append may be slow when
             a vector has to reallocate new memory and to copy existing elements into the new memory.
             # but such reallocations are rather rare.
               actually,vector reallocate memory the size is 2 * old_size .
          inserting an element in the middle or at the beginning of the array takes time(must move following elements)

      Sequence Container - deque : <deque>
        deque is an abbreviation for "double-ended queue".
          implemented in a dynamic array and can grow in both directions
          inserting elements at the end and at the beginning is fast
          inserting elements in the middle takes time(must move following elements)
          # because queue follows the rule FIFO,thus,it should not be used to insert element in the middle;
            new element is queued in the end,and old element dequeued from head.

      Sequence Container - array : <array>
        an array(object of class array<>) manages its elements in an array of fixed size.
          size of array can not be changed
          values of elements are changeable
          must specify the size of array at creation time
          enable random access operator[]
        /**
         * the traditional C array is a pointer,thus we can specify the size of array during running-time.
         * for resize an array,must invoke C library routines realloc() or reallocarray().
         */

      Sequence Container - list : <list> / <forward_list>
        since C++11,two different list containers are provided by the STL -
          1> class list<>         // ordinary list
          2> class forward_list<> // forward list
             /* just a restricted list,and in practice,this difference is not so important */
        
        a list<> is implemented as a doubly linked list of elemtns.
          disable random access
          to successor or to predecessor by make use of the links(constant time)
          insert a new element and remove a existed element in the list at any position are very fast
          move element from old position to new position is very fast

        a forward_list<> is implemented as a singly linked list of elements.
          disable random access
          only allow to successor by make use of the link
          because only a link to successor,insertion have to know the element in the front of given position
          /* remove is the same */
          do not support move backward operations and others that would cause a performance penalty
          /* do not provide push_back() and size() member methods */

      Associative Container - set : <set>
        a set is a collection in which elements are sorted according to their own values,and
        duplicates are not allowed.
        
        e.g.
          std::set<int> int_set{1, 2, 3, 7, 5, 4, 9, 8, 6};  // initializer-list
          // sorted to {1, 2, 3, 4, 5, 6, 7, 8, 9}
          int_set.insert(0);
          // int_set : {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
          // int_set.insert(3); => ERROR,duplicate

          std::set<int, std::greater<int>> intSet; // use descending order
          intSet.insert(3);
          intSet.insert(1);
          ...
          intSet.insert( {33, 65, 21, 78, 20, 13} ); // C++11,initializer-list


          // std::greater<>,a template function defined in <bits/stl_function.h>.
          // it has defined operator()(@arg1, @arg2),returns @arg1 > @arg2.

          ! usage for multiset is similar to set.

      Associative Container - multiset : <set>
        a multiset is the same as a set except that duplicates are allowed.

        e.g.
          std::multiset<int> int_multiset{0, 0, 2, 6, 1, 4, 7, 5, 3, 9, 8};
          // int_multiset : {0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
          int_multiset.insert(3);
          // int_multiset : {0, 0, 1, 2, 3, 3, 4, 5, 6, 7, 8, 9}

      Associative Container - map : <map>
        a map contains element that are key/value pairs.each element has a key that is the basis
        for the sorting criterion and a value.
        each key may occur only once.
        a map can also be used as an "associative array",an array that has an arbitrary index type.

        e.g.
          std::map<std::string, int> str_int_map{{"one", 1}, {"two", 2}, {"three", 3}};
          // str_int_map : {[one, 1], [three, 3], [two, 2]}
          //               sorting criterion is the keyA < keyB

      Associative Container - multimap : <map>
        a multimap is the same as a map except that duplicates are allowed,thus it may contains the
        elements that have the same key.
        a multimap can also be used as "dictionary".

        e.g.
          std::multimap<std::string, int> str_int_multimap{{"one", 1}, {"two", 2}, {"three", 3}};
          // str_int_multimap : {[one, 1], [three, 3], [two, 2]}
          //                    sorting criterion is the keyA < keyB
          str_int_multimap.insert({"one, 3"});  // call to void multimap::insert(std::initializer_list)
          // str_int_multimap : {[one, 1], [one, 3], [three, 3], [two, 2]}

      Unordered Container - unordered_set : <unordered_set>
        an unordered set is a collection of unordered elements,where each element may occur only once.

      Unordered Container - unordered_multiset : <unordered_set>
        an unordered multiset is the same as an unordered set except that duplicates are allowed.

        e.g.
          std::unordered_multiser<int> int_multiset;
          int_multiset.insert( {3, 9, 2, 1, 4, 2, 5, 7, 4, 10, 3, 0, 2} );
          // int_multiset : unordered,any new element inserted into the set may change the positions
          //                of all elements in the container.
          //                ! elements have equal values are adjacent to each other.

          ! the iterator over this container is alike to array traversing.
            from index 0 to index N - 1,traverse each list at current index.
                 // array size is N

      Unordered Container - unordered_map : <unordered_map>
        an unordered map contains elements that are key/value pairs.each key may occur only once.
        an unordered map can also be used as an "associative array",an array that has an arbitrary
        index type.

        ! value type of unordered_map<> is std::pair<const _Key, _Tp>,where _Key is type of key and
          _Tp is type of value.
      
      Unordered Container - unordered_multimap : <unordered_map>
        an unordred multimap is the same as an unordred map except that duplicates(same key) are allowed. 
        an unordered multimap can also be used as "dictionary".

      Associative Arrays :
        both maps and unordered maps are collections of key/value pairs with unique keys,such a collection
        can also be thought of as an "associative array",an array whose index is not integer value.
        both of them have provided overload of operator[] -
          mapped_type &operator[](const key_type& __k);
          // also provided member function at() .
          
        e.g.
          std::unordered_map<std::string, int> uo_map; // structure or class has constructor refuse
                                                       // {0} - zero initializer
          uo_map["one"] = 1;
          uo_map["two"] = 2;
          uo_map["eight"] = 8;

          int x(uo_map["eight"]);

      Other Containers :
        std::basic_string<>, std::string, std::wstring -
          std::string is specialization of std::basic_string<> for char type.
          std::wstring is specialization of std::basic_string<> for wchar type.
  
          C++ string is similar to vectors but specified for characters.

        C-Style Arrays -
          an ordinary array that has a declared fixed size or a dynamic size managed
          by memory allocator.
          but ordinary array for character do not provide iterators,the actions based on
          pointer of char type.
          ! nevertheless,STL's design allow call algorithms for them.

        User-Defined Containers -
          user can provide customized containers,and all of them should follow the STL rules.
          -
            provide iterator
            provide begin(),end(),and provide opeator!=() for iterator to the container in range-for
            provide member-acess operator overload
            provide derefer operator overload
            provide random access operator overload if support to random accessing
            provide overload versions for some STL interfaces to support the customized containers
            ...

    Container Adapters :
      the C++ STL provides "container adapters" which are predefined containers that provide a
      restricted interface to meed special needs.these container adapters are implemented by
      using the fundamental container classes.

      Stack : <stack>
        a stack manages its elements by the LIFO policy.
        at any time,only the top element is visble.

      Queue : <queue>
        a queue manages its elements by the FIFO policy,that is,it is an ordinary buffer.

      Priority Queue : <queue>
        a priority queue is a container in which the elements may have different priorities.
        the priority is based on a sorting criterion.
        a priority queue is,in effect,a buffer in which the next element is always one having
        the highest priority inside the queue,if more than one element has the highest priority,
        the order of these elements is undefined.
        // binary-heap, binomial-heap

    Iterators :
      iterator is the object that fulfill the concept that an object represents positions of elements
      in a container.
      an iterator is an object that can iterate over elements,these elements may be all or a subset
      of the elements of an STL container,the iterator represents a certain position in a container.

      fundamental operations -
        operator* => returns the element of the current position
        operator-> => access the member of the element of the current position
        operator++() => prefix increase
        operator--() => postfix decrease
        operator++(int) => postfix increase
        operator--(int) => postfix decrease
        operator== => logical equal
        operator!= => logical not equal
        operator= => assignment

      ! C++ iterators also support to ordinary C-Style array.
        when use iterator with C-Style array,it may be smart pointers.
      ! the internal behavior of iterators depends on the data structure over which
        they iterate,thus,each container type supplies its own kind of iterator.
        as a result,iterators share the same interface but have different types.

      iterator category - define only the abilities of iterator
        input_iterator         =>    read only,forward only

        output_iterator        =>    write only,forward only

        forward_iterator       =>    input_iterator + output_iterator,forward(++) only
                                     // std::forward_list<> use forward_iterator
                                     // unordered_set,unordered_multiset,unordered_map,
                                     // unordered_multimap are "at least" use forward
                                     // iterator

        bidirectional_iterator =>    forward + backward(--)
                                     // list,set,multiset,map,multimap

        random_access_iterator =>    bidirectional_iterator + offset
                                     // vector,deque,array,string

        contiguous_iterator    =>    points to objects stored contiguously in memory
                                     // actually,it generalised random_access_iterator

        ! about logical operation,have to pay attention for that not all iterators supported
          operator<,operator> and etc.but all iterators have supported operator!= .

      basic member functions that containers provide -
        begin() => return an iterator points to the position of the first element
        end() => return an iterator points the next position of the last element
                 // also called past-the-end iterator
        ! if container is empty,then begin() and end() both of them should return the
          position what end() will returns.
        cbegin() => constant iterator version of begin()
        cend() => constant iterator version of end()
        ! if invoke begin() on a const object,the begin() will also return a constant
          iterator,invoke end() is the same.
          constant iterator forbid modification to the element.

      ! in the most cases,iterator for a container is defined in the same header,as 
        a general structure outside to the container or a nested structure in the container
        definition.
        they usually associated with an iterator tag,that describe what kinds of operations
        is supported by the iterator.for example,std::list<> do not support random access,
        so the tag of its itrator should be "bidirectional_iterator_tag",
        but for std::forward_list<>,the tag of its iterator should be "forward_iterator_tag".
        the tag describe what is the category of this iterator.

      e.g.
        range-for :
          std::list<int> ilist;
          ...
          for (auto& item : ilist) {
            ...
          }

        for :
          std::list<int> ilist;
          ...
          auto end_pos(ilist.end());
          auto begin_pos(ilist.begin());

          for (auto i(begin_pos); i != end_pos; ++i) {
            auto& item(*i);
            ...
          }

          /**
           * ++i VS i++
           *   ++iter
           *     ++iter
           *     return *iter
           *   iter++
           *     auto tmp(*iter)  // will create temporary object
           *     iter++
           *     return tmp
           */

    Algorithms :
      the STL provides several standard algorithms for processing elements of collections.
      algorithms are not member functions of the container classes but instead are global
      functions that operate with iterators. /* generic functional programming paradigm */
                                             /* these algorithms can also be used with 
                                              * user-defined container types.
                                              */
      !! disadvantages :
           > the usage is not intuitive
           > some combinations of data structures and algorithms
             might not work
             /* OR can be combined but not useful */

      <bits/stl_algo.h> // this header is inclued by header <algorithm>
                        // namespace : std
        /**
         * min_element - return position of minimum element in the given range
         * @_ForwardIterator:
         *               template parameter,forwad iterator
         *               template need the iterator support to operator++
         * @__first:     starting of the range
         * @__last:      end of the range
         * return:       forward iterator which points to the minimum element
         * # the default comparator of elements is operator<
         * # there is another overload version which require third parameter
         *   as comparator of elements
         */
        template<typename _ForwardIterator>
        _GLIBCXX14_CONSTEXPR
        _ForwardIterator
        inline min_element(_ForwardIterator __first, _ForwardIterator __last);

        e.g.
          std::list<int> int_list{3, 2, 5, 7, 1 ,4, 6, 10, 9};
          auto min = std::min_element(int_list.begin(), int_list.end());
          // @min points to element 1

        /**
         * max_element - return position of maximum element in the given range
         * # similar to min_element(),the default comparator still is operator<,
         *   but exchanged the order of arguments
         * # there is another overload version which require third parameter
         *   as comparator of elements
         */
        template<typename _ForwardIterator>
        _GLIBCXX14_CONSTEXPR
        inline _ForwardIterator
        max_element(_ForwardIterator __first, _ForwardIterator __last);

        /**
         * sort - sort the elements of a sequence
         * @_RandomAccessIterator:
         *        template parameter,iterator type should be random access iterator
         * @__first:
         *        starting of the range
         * @__last:
         *        end of the range
         * # sorts the elements in the range [@__first, @__last) in ascending order
         * # the relative ordering of equivalent elements is not preserved
         * # there is another overload version which require third parameter
         *   as comparator of elements
         *     sort(@__first, @__last, @__comp)
         */
        template<typename _RandomAccessIterator>
        _GLIBCXX20_CONSTEXPR
        inline void
        sort(_RandomAccessIterator __first, _RandomAccessIterator __last);

        /**
         * stable_sort - sort the elements of a sequence,preserving the relative
         *               order of equivalent elements
         * # stable_sort() is similar to sort(),but two equivalent elements have the
         *   same relative ordering
         * # the default comparator is operator<
         * # there is another overload version which require third parameter
         *   as comparator of elements
         */
        template<typename _RandomAccessIterator>
        inline void
        stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last);

        /**
         * find - attempt to find and return position of given element in the
         *        given range
         * @_InputIterator:
         *        template parameter,input iterator,read only
         * @_Tp:  type of the value of the element,for some containers they identify
         *        element by key,@_Tp can be the type of the key
         * @__first:
         *        starting of the range
         * @__last:
         *        end of the range
         * @__val:
         *        the value is going to be found
         * return:
         *        position of the element in the range if found
         *        return @__last if no such element
         * # if the container support same identifier,then this routine will returns
         *   the first position where such element is placed
         * # the default comparator is operator==(v1, v2)
         * # there is another interface find_if() which require a predicate as third
         *   parameter,it will return the position where the given predicate is TRUE,
         *   or return @__last if no such iterator exists
         */
        template<typename _InputIterator, typename _Tp>
        _GLIBCXX20_CONSTEXPR
        inline _InputIterator
        find(_InputIterator __first, _InputIterator __last, const _Tp& __val);

        /**
         * reverse - reverse a sequence
         * @_BidirectionalIterator:
         *           template parameter,iterator type should be bidirectional iterator
         * @__first: starting of the range
         * @__last:  end of the range
         * # this routine reverse the order of the elements in the range [@__first, @__last)
         * # do not pass constant iterator to this routine,because it processes modification
         */
        template<typename _BidirectionalIterator>
        _GLIBCXX20_CONSTEXPR
        inline void
        reverse(_BidirectionalIterator __first, _BidirectionalIterator __last);

      Ranges :
        the API of algorithms for STL containers usually request user pass to them the
        range of elements they will operates on.
        caller must ensure the range is valid,that is the end of the range is reachable from
        the beginning by iterating through the elements.
        // programmer have to ensure that both iterators belong to the same container and
        // that the begining is not behind the end.

        every algorithm processes half-open ranges - [begin, end).
        the half-open-range concept has the advantages that it is simple and avoids special
        handling for empty collections.
        of course,it still has some disadvantages -
          we have known that find() return @__last if no such iterator exists,so that
            auto pos = find(begin, end, val);
            // pos == @end
            reverse(pos, end);  // reverses an empty range [@end, @end)
                                // @end == @end,return to caller with do nothing
            auto posB = find(begin, end, valid_val);
            auto maxA = max_element(begin, posB); // maximum in range - [begin, posB)
                                                  // so we will skip the element at
                                                  // position @posB
                                                  // for deal with this problem,must
                                                  // invoke the routine with ++@posB

        Multiple Ranges :
          !! when call algorithms for multiple ranges,make sure that the second and
             additional ranges have at least as many elements as the first range.

          some algorithm API can receives more than one ranges,when using them,must
          follow the rule at above.

          <bits/stl_algobase.h>
            /**
             * equal - tests a range for element-wise equality
             * @_II1:  template parameter,type of iterator of range1
             *         should be input iterator
             * @_II2:  template parameter,type of iterator of range2
             *         should be input iterator
             * @__first1:
             *         begin of range1
             * @__last1:
             *         end of range1
             * @__first2:
             *         begin of range1
             * return: TRUE => ALL(eI OF Range1 -> eI == pI OF Range2)
             *         FALSE => NOT ALL(eI OF Range1 -> eI == pI OF Range2)
             * # Range1 is defined by [@__first1, @__last1)
             *   Range2 is defined by [@__first2, @__first2 + (@__last1 - @__first1))
             */
            template<typename _II1, typename _II2>
            _GLIBCXX20_CONSTEXPR
            inline bool
            equal(_II1 __first1, _II1 __last1, _II2 __first2);

            e.g.
              std::list<int> int_list1{1, 2, 3, 4, 5, 6};
              std::list<int> int_list2{3, 4, 5};
              equal(std::find(int_list1.begin(), int_list1.end(), 3),
                    std::find(int_list1.begin(), int_list1.end(), 6},
                    int_list2.begin());
              // return TRUE

            /**
             * copy - copies elements of the first range into result
             * @_II:  type of iterator of the Range1
             *        should be input iterator
             * @_OI:  type of iterator of the result
             *        should be output interator
             * @__first:
             *        begin of Range1
             * @__last:
             *        end of Range1
             * @__result:
             *        begin of Result
             * return:
             *        end of Result = @__result + (@__last - @__first)
             * # the end of the output range is permitted to be contained
             *   within [@__first, @__last) - must ensure it is large enough
             * # overwrite rather than insert,thus no automatical allocating
             *   can take place
             *   for enable automatical allocating,must use insert iterator
             *   to instead output iterator
             * # associative and unordered containers can not be used as a 
             *   destination for overwriting algorithms
             */
            template<typename _II, typename _OI>
            _GLIBCXX20_CONSTEXPR
            inline _OI
            copy(_II __first, _II __last, _OI __result);

    Iterator Adapters :
      iterators are pure abstructions - anything that behaves like an iterator is an iterator.
      user can write classes that have the interface of iterators but do something completely
      different.

      the predefined special iterators : iterator adapters
        1> insert iterators
        2> stream iterators
        3> reverse iterators

      insert iterators :
        insert iterators or inserters are used to let algorithms operate in insert mode rather
        than in overwrite mode.this will let containers grow accordingly - std::copy(),etc.

        <bits/stl_iterator.h> // namespace : std
          /**
           * front_insert_iterator - iterator adapter used to insert element to specified
           *                         container
           * @_Container:            template parameter,container type
           * # this adapter is used to solve the destination has not valid space to
           *   contain the coming element in STL algorithm
           *   for achieve the purpose,class has defined operator=() overload which
           *   will invoke member method push_front() of @container,this method cause
           *   automatical memory allocating
           * # this adapter do not support iterator step
           */
          template<typename _Container>
          class front_insert_iterator
          : public iterator<output_iterator_tag, void, void, void, void>
          {
          protected:
            _Container *container;
          public:
            typedef _Container container_type;
            using difference_type = ptrdiff_t; // NEED __cplusplus > 201703L
            ...
          };

          /* front_inserter - makeup a front_insert_iterator object from given container */
          template<typename _Container>
          _GLIBCXX20_CONSTEXPR
          inline front_insert_iterator<_Container>
          front_inserter(_Containter& __x);

          /**
           *  back_insert_iterator - similar to front_insert_iterator,but invoke member method
           *                         push_back() on given container
           */
          template<typename _Container>
          class back_insert_iterator
          : public iterator<output_iterator_tag, void, void, void, void>
          {
            ...
          };

          /* makeup back_insert_iterator object from the given container */
          template<typename _Container>
          _GLIBCXX20_CONSTEXPR
          inline back_insert_iterator<_Container>
          back_inserter(_Container& __x);

          /**
           * insert_iterator - iterator adapter for inserting
           * @container:       container object
           * @iter:            container iterator whose type is
           *                   _Container::iterator
           * # this class is similar to front inserter and back inserter,
           *   except operator=() invoke member method insert() of @container
           *   which usually insert element at position front to @iter,
           *   and then increase @iter
           * # except std::array and std::forward_list,such insert() method
           *   have been implementd in the predefined containers include
           *   associative and unordered containers
           *   - for associative containers and unordered containers,the position
           *     specified by insert() method would as a "hint" where the searching
           *     of correct position to starting
           * # iterator step is no-op
           */
          template<typename _Container>
          class insert_iterator
          : public iterator<output_iterator_tag, void, void, void, void>
          {
          protected:
            _Container *container;
            _Iter iter;
          };

          /* makeup general inserter */
          template<typename _Container>
          constexpr insert_iterator<_Container>
          inserter(_Container& __x, typename _Container::iterator __i);

        ! in normal case,the procedure of copying A to B is seem like this :

            for (i = begin, j = end, r = result; i != j; ++i, ++r)
              *r = *i;

          when make use of inserter,operator++() returns "*this" - the inserter
          itself,but operator=() have overloaded,thus result iterator step is
          hand over to the member method of container(front_inserter / back_inserter),
          or invoke operator++() on the internal iterator of container(inserter).

      stream iterators :
        stream iterators are used for read from or write to a stream,support input/output
        stream redirect.

        <bits/stream_iterator.h> // namespace : std

          /**
           * istream_iterator<> - input stream iterator template
           * @_Tp:                template parameter,type of buffer
           * @_CharT:             template parameter,character type
           * @_Traits:            template parameter,character traits
           * @_Dist:              template parameter,iterator position dist
           * @_M_stream:          pointer to input stream object
           * @_M_value:           buffer for content from stream
           * @_M_ok:              false => end-of-stream
           */
          template<typename _Tp, typename _CharT = char,
                   typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
          class istream_iterator
          : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp *, const _Tp&>
          {
          public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef basic_istream<_CharT, _Traits> istream_type;
            ...
          private:
            istream_type *_M_stream;
            _Tp _M_value;
            bool _M_ok;
            ...
          };

          constructor :
            _GLIBCXX_CONSTEXPR istream_iterator();
            istream_iterator(istream_type& __s);

          allow : copy assignment
          disallow : move

          some member methods :
            const _Tp& operator*() const        => return @_M_value
            const _Tp* operator->() const       => member access operator
            istream_iterator& operator++()      => prefix ++
                                                   @_M_value has updated
                                                   // invoke _M_read()
            istream_iterator operator++(int)    => postfix ++
                                                   @_M_value is not updated
                                                   the returned object is
                                                   older,but the orinal object
                                                   will be updated because
                                                   _M_read() is invoked

            // private methods

            void _M_read()                      => private member
                                                   read content from input stream at
                                                   current position,save it in to
                                                   @_M_value
                                                   if end-of-stream,set @_M_stream to 0,
                                                   set _M_ok to false
                                                   # this method will step input stream
                                                     position
                                                   # this method invoke operator>>() of
                                                     @_M_stream on @_M_value

            bool _M_equal(const istream_iterator& __x) const
            => (@_M_ok == @__x._M_ok) && (!@_M_ok || @_M_stream == @__x._M_stream)

            friend bool operator==(const istream_iterator& __x, const istream_iterator& __y)
            => @__x._M_equal(@__y)

            friend bool operator!=(const istream_iterator& __x, const istream_iterator& __y)
            => !operator==()

            friend bool operator==(const istream_iterator& __i, default_sentinel_t)
            => !@__i._M_stream

          usage :
            // all content from input stream @cin are readed and stored into @container
            std::copy(std::istream_iterator<std::string>(cin), std::istream_iterator<string>(),
                      std::back_inserter(@container));

          /**
           * ostream_iterator<> - similar to istream_iterator<>,but for output
           * @_Tp:                template parameter,type to write to the output stream
           * @_CharT:             template parameter,type of delimiter
           * @_Traits:            template parameter,@_CharT traits
           */
          template<typename _Tp, typename _CharT = char,
                   typename _Traits = char_traits<_CharT> >
          class ostream_iterator
          : public iterator<output_iterator_tag, void, void, void, void>
          {
          public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedf basic_ostream<_CharT, _Traits> ostream_type;
            ...
          private:
            ostream_type *_M_stream; /* sink */
            const _CharT *_M_string; /* delimiter,this string will be written into
                                      * output stream after every @_Tp written
                                      * into the output stream if it is not NULL
                                      */
            ...
          };

          constructor :
            ostream_iterator(ostream_type& __s, const _CharT* __c);

          allow : copy asssignment
          disallow : move

          some member methods :
            ostream_iterator& operator=(const _Tp& __value)    => insert @__value
                                                                  into output stream,
                                                                  if @_M_string is not
                                                                  nullptr,insert it at
                                                                  the end
            operator*()                                        => return *this
            operator++()                                       => return *this
                                                                  // no updating
            operator++(int)                                    => return *this
                                                                  // no updating

      reverse iterators :
        reverse iterators let algorithms operate backward by switching the call of
        an increment operator internally into a call of the decrement operator,and vice versa.

        ! all containers have bidirectional iterators or random-access iterators can create
          reverse iterators via their member function rbegin() and rend().
        ! std::forward_list<> and unordered containers,have no backward-iteration interface
          is provided.

        <bits/stl_iterator.h> // namespace : std
          /**
           * reverse_iterator - reverse iterator step direction
           * # usually,the member function rbegin() of a container returns a reverse iterator
           *   constructed through the end() of the container;and member function rend()
           *   returns a reverse iterator constructed through the begin() of the container
           */
          template<typename _Iterator>
          class reverse_iterator
          : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                            typename iterator_traits<_Iterator>::value_type,
                            typename iterator_traits<_Iterator>::difference_type,
                            typename iterator_traits<_Iterator>::pointer,
                            typename iterator_traits<_Iterator>::reference>
          {
          protected:
            _Iterator current;
            typedef iterator_traits<_Iterator> __traits_type;
            ...
          public:
            typedef _Iterator iterator_type;
            typedef typename __traits_type::difference_type difference_type;
            typedef typename __traits_type::pointer pointer;
            typedef typename __traits_type::reference reference;
            ...
          private:
            template<typename _Tp>
            static _GLIBCXX17_CONSTEXPR _Tp *
            _S_to_pointer(_Tp *__p)
            { return __p; }

            template<typename _Tp>
            static _GLIBCXX17_CONSTEXPR pointer
            _S_to_pointer(_Tp __t)
            { return __t.operator->(); }
          };

          constructor :
            _GLIBCXX17_CONSTEXPR
            reverse_iterator() : current() { }
        
            explicit _GLIBCXX17_CONSTEXPR
            reverse_iterator(iterator_type __x) : current(__x) { }

          allow : copy assignment convert-copy /* a template of copy-constructor */
          disallow : move

          some member methods :
            _GLIBCXX17_CONSTEXPR iterator_type base() const
            => return @current

            _GLIBCXX17_CONSTEXPR reference operator*() const
            => return a reference to a temporary object constructed
               from @current,the result is "*--temp_object"
               /* requirement:
                *   for the underlying iterator type,T x,a reference obtained
                *   by *x remains valid after T x has been modified or destroyed
                */

            _GLIBCXX17_CONSTEXPR pointer
            operator->() const
            => construct a temporary iterator from @current,decrease the temporary
               object,then invoke private member function _S_to_pointer() on it
               to get the pointer of the element this temporary iterator pointed to
            
            operator++()          => --@current,return *this
            operator++(int)       => --@tmp constructed from @current,return @tmp
            operator--()          => ++@current,return *this
            operator--(int)       => ++@tmp constructed from @current,return @tmp
            operator+(diff_t @n)  => return a reverse_iterator constructed through
                                    @current - @n
            operator-(diff_t @n)  => return a reverse_iterator constructed through
                                    @current + @n
            operator+=(diff_t @n) => @current -= @n,return *this
            operator-=(diff_t @n) => @current += @n,return *this

            operator[](diff_t @n) const
            => return *(*this + @n)

            friend constexpr iter_rvalue_reference_t<_Iterator>
            iter_move(const reverse_iterator& __i)
            => return ranges::iter_move(decrease((auto __tmp = @__i.base())))
               /* a new temporary object would be created */

            template<indirectly_swappable<_Iterator> _Iter2>
            friend constexpr void iter_swap(const reverse_iterator& __x,
                                            const reverse_iterator<_Iter2>& __y)
            => makeup two temporary objects
                 @tobj1 = @__x.base(), @tobj2 = @__y.base()
                 ranges::iter_swap(--@tobj1, --@tobj2)

          logical operations :
            == < !=  > <= >=
            <=>
          
          arithmetic operations :
           rt1 - rt2
           rt1 + rt2

          helper :
            template<typename _Iterator>
            inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
            make_reverse_iterator(_Iterator __i)

          usage :
            std::list<int> int_list; // doubly linked list
            ...
            for (auto i(int_list.rbegin()); i != int_list.rend(); ++i) {
              ...
            }

            std::list<int> int_list2; // doubly linked list
            std::copy(int_list.rbegin(), int_list.rend(), int_list2.begin());

      move iterators :
        move iteraotes are provided since C++11,they convert any access to the underlying element
        into a move operation.

        header : <bits/stl_iterator.h>
        namespace : std

        template<typename _Iterator>
        class move_iterator
        {
          ...
        };

        // type-definition @reference is defined as rvalue reference,thus the operations
           that return the type @reference are return a rvalue reference.

    User-Defined Generic Functions :
      STL is an extensible framework,thus user can write his own functions and algorithms to process
      elements of collections.but must follow the rule: these operations should also be generic if it
      is possible.

      e.g.
        template<typename _TContainer>
        void print(const _TContainer& container, const std::string& prefix = "")
        {
          std::cout << prefix << std::endl;
          for (auto e : container)  // print each element in the container
            std::cout << e << " ";
          std::cout << std::endl;
        }

        ! in the example,elements in the container must support to
          operator<<(std::ostream& c = std::cout, element).
          if it is user-defined element type,user can provide this operator overload.
          because here has make use of range-for,thus the container must provide the member methods
          begin(),end(),and iterator type must provide the overloads operator!=(),operator*().

    Manipulating Algorithms :
      "Removing" Elements :
        <bits/stl_algo.h>
          /**
           * remove - function template to remove elements from a sequence
           * @_ForwardIterator:
           *          template parameter,the type of iterators
           * @_Tp:    template parameter,the type of value(key)
           * @__first:
           *          starting of the range
           * @__last: end of the range
           * @__value:
           *          the target to be removed
           * return:  an iteraotr designating the end of the resulting sequence
           * # this routine is stable,the relative order of elements that are not
           *   removed is unchanged
           * # elements between the end of the resulting sequence and @__last are
           *   still present,but their value is unspecified
           */
          template<typename _ForwardIterator, typename _Tp>
          _GLIBCXX20_CONSTEXPR
          inline _ForwardIterator
          remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);

          brief description of remove<>() :
            this routine usually overwrite the element which is going to be removed with
            the next element,and the next element is overwrite by the next next element,
            and so on.
            at the end,it returns the iterator points to the end of resulting sequence,
            but size and end of the container remains unchanged.

            [ 1, 2, 3, 4, 5, 6, 7, 8, 2, 3, 1, 2, 5]
            remove 2
                                            +--> value unspecified
                                            |  |  |
            [ 1, 3, 4, 5, 6, 7, 8, 3, 1, 5, 5, 5, 5]  => other elements' relative order unchanged
                                            |        |
                                            |        +--> container's end
                                            +--> removed() return

            for to remove realy the elements from the container,must invoke the member method
            erase() of the container,pass it the range [removed() return, @__last).
            that is
              container.erase(remove(container.begin(), container.end(), 2), container.end());
            if we want to print the result sequence without erasing,can make use of the algorithm
            std::copy() with an output stream iterator.
              std::copy(container.begin(), std::remove(container.begin(), container.end(), 2),
                        std::ostream_iterator(std::cout, " "));
            after the member method erase() was called,member methods size() and end() of the container
            would return the updated values.

          !! std::remove<>() can only be applied on sequence containers,because the order of elements
             follow the inserting order;we can not easily overwrite the parent node with its right/left
             child node in a binary tree to implement removing.

      Manipulating Associative and Unordered Containers :
        in order to avoid compromising the internal order,every iterator for an associative and unordered
        container is declared as an iterator for a constant value or key,thus manipulating elements of
        or in associative and unordered containers results in a failure at compile time.
        /* typedef const_iterator iterator */

        every associative and unordered container provides member functions to remove elements,that is the
        erase() method.
        e.g.
          std::unordered_set<int> int_unorder_set;
          int_unorder_set.insert(1);
          ...
          int_unorder_set.erase(1);

        usually,the method erase() returns the number of removed elements,if no such element,it would returns
        0;but,if called the overload version which requires another type of argument,the return value is
        different.
        /* only the one needs the value of to be removing element will returns the number of removed elements,
         * for duplicate disallowed container,the return value always is 1 or 0.
         */

      Algorithms VS Member Functions :
        in some cases,a container might have member functions that provide much better performance than algorithm
        functions.
        suppose we using a list,for remove an element,just unlink it from the list - find out the element,
        unlink prev and next,splice previous element and next element.
        but std::remove() always overwrite elements,thus it is more expensive cost for implement generic.
        std::list<> provide member function remove(),it has good performance than std::remove().
        e.g.
          std::list<int> int_list{1, 4, 6, 2, 5, 8, 3, 10};
          int_list.remove(2);
          // std::remove(int_list.begin(), int_list.end(), 2);

        prefer a member function over an algorithm if good performance is the goal.
        // need to know the container have provided such member function and which
           has a good performance.
           but the code applied this method would lost generic abstraction,that is,
           for different container type,must change the code to responding to it.

      Functions as Algorithm Arguments :
        Using Functions as Algorithm Arguments :
          e.g.
            template<typename _ForwardIterator, typename _FuncTp>
            void for_each(_ForwardIterator& start, _ForwardIterator& end, _FuncTp func)
            {
              for (_ForwardIterator& it(start); it != end; ++it) {
                func(it);
              }
            }

            template<typename _Tp>
            void print(const _Tp& e, const std::string& delimiter = " ")
            { std::cout << e << delimiter; }

            template<typename _Tp>
            requires integral<_Tp>
            void square(_Tp& e)
            { e *= e; }


            std::list<int> int_list;
            ...
            for_each(int_list.begin(), int_list.end(), print);
            for_each(int_list.begin(), int_list.end(), square);
            for_each(int_list.begin(), int_list.end(), print);

          algorithms use auxiliary functions in several variants -
            some optional
            /**
             * search criterion
             * sorting criterion
             */

            some mandatory
            /**
             * define a manipulation while transferring elements from one collection to another
             * std::transform()
             */              
            
          <bits/stl_algo.h>
            /**
             * transform - routine used to transform elements in a given collection to another,
             *             the elements will pass through a modifier
             * @_InputIterator:
             *             template parameter,type of iterator of input collection
             * @_OutputIterator:
             *             template parameter,type of iterator of output collection
             * @_UnaryOperation:
             *             template parameter,type of modifier
             * @__first:   starting of the range
             * @__last:    end of the range
             * @__result:  starting of the result collection
             * @__unary_op:
             *             modifier
             * return:     @__result
             * namespace:  std
             * # this routine actually do for each element in range [@__first, @__last),
             *   pass it as argument of @__unary_op,and insert the return value to @__result
             */
            template<typename _InputIterator, typename _OutputIterator, typename _UnaryOperation>
            _GLIBCXX20_CONSTEXPR
            _OutputIterator
            transform(_InputIterator __first, _InputIterator __last,
                      _OutputIterator __result, _UnaryOperation __unary_op);

            /**
             * variant of transform(f, l, r, unary_op)
             * for each pair of elements in range [@__first1, @__last1) and
             * in [@__first2, (@__first2 + (@__last1 - @__first1))),pass them to
             * @__binary_op as the first and the second parameter,respectively,
             * insert the return value to the collection starting at @__result
             *
             * return:    @__result
             * namespace: std
             */
            template<typename _InputIterator1, typename _InputIterator2,
                     typename _OutputIterator, typename _BinaryOperation>
            _GLIBCXX20_CONSTEXPR
            _OutputIterator
            transform(_InputIterator1 __first1, _InputIterator1 __last1,
                      _InputIterator2 __first2, _OutputIterator __result,
                      _BinaryOperation __binary_op);

          e.g.
            template<typename _Tp>
            _Tp square(const _Tp& v)
            {
              _Tp ret(v * v);
              return ret;
            }

            // now we can pass square<>() to the first transform routine as
            // mandatory unary operation.
            // this way is similar to mapping,we map the elements in a given
            // collection to the squared value,but the output collection is
            // the same input collection.
            // (map collection (lambda (v) (* v v)))

        Predicates :
          a predicate is a special kind of auxiliary function,which return a boolean value
          and are often used to specify a sorting or a search criterion.there are unary predicate
          and binary predicate,depends on its purpose.
          /* STL requires that predicates be stateless,they should always yield the same result
           * for the same value.
           */

          e.g. // unary
            bool isPrime(int n)
            {
              n = abs(n);
              if (n == 0 || n == 1)
                return false;

              return improved_FermatPrime(n);
            }
            ...
            auto pos = std::find_if(int_list.begin(), int_list.end(), isPrime);

          e.g. // binary
            bool sortCriterion(auto x, auto y)
            {
              if (x > 2 * y)
                return false;
              else if (x < y - 3)
                return false;

              return (x < y);
            }
            ...

            std::sort(int_deque.begin(), int_deque.end(), sortCriterion);

          <bits/stl_algo.h>
            /**
             * find_if - find the first element's position if it passed predicate
             * @_InputIterator:
             *           template parameter,type of input iterator
             * @_Predicate:
             *           template parameter,type of predicate
             * @__first: the beginning
             * @__last:  the end
             * @__pred:  predicate
             * return:   position of the element OR @__last if no such element
             * namespace:
             *           std
             */
            template<typename _InputIterator, typename _Predicate>
            _GLIBCXX20_CONSTEXPR
            inline _InputIterator
            find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred);

    Function Objects :
      functional arguments can be objects that behave like functions,such an object is
      called a function object,or functor.
      /* object provides a function call operator */

      C++ STL provides the new feature function object since C++11.

      <bits/std_function.h> // <functional>
        /**
         * function<> - primary class template for std::function
         * # polymorphic function wrapper
         */
        template<typename _Res, typename... _ArgTypes>
        class function<_Res(_ArgTypes...)>
        : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
          private _Function_base
        {
          ...
        public:
          typedef _Res result_type;
          ...
        private:
          /* function pointer type -
           * return-type (*)(any_data&, arguments&&)
           *                 ^For class member function
           * type @_Any_data is defined in class _Function_base
           */
          using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
          _Invoker_type _M_invoker; /* function pointer object */
        };

        operator() :
          _Res operator()(_ArgTypes... __args) const;
          -> template<typename _Res, typename... _ArgTypes>
             _Res
             function<_Res(_ArgTypes...)>::operator()(_ArgTypes... __args) const
             {
               ...
               /* _M_functor is a public member of class _Function_base */
               return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
             } /* this routine may throw bad function call if _Function_base::_M_empty()
                * returned TRUE
                */

        normal usage :
          int int_add(int, int);
          ...
          std::function<int(int, int)> iadd(int_add);
                                       /*   ^function pointer */
          iadd(@x, @y);

          ! C++ lambda is similar to std::function,but it has a catch-list defined what
            is visible in the body.
            auto iadd = [@catch-list](int, int) -> int {
              ...
            }; /* std::function<int(int, int)> iadd(anonymous_func);
                *                                   @catch-list is visible in the body of
                *                                   anonymous_func()
                */


      user can define customized callable object through C++ class or structure,the
      hard requirement is the object must contains operator() the operator overloading.
      e.g.
        struct int_add {
          int operator()(int x, int y) const
          {
            return x + y;
          }
        };

        int x(3), y(4);
        int_add iadd;
        auto result = iadd(x, y); // invoke member method "int operator()(int, int) const"

      we can pass user-defined callable object or lambda object or std::function object to
      the STL algorithms.                         /* lambda object and std::function object
                                                   * also are callable objects
                                                   */

      Advantages of function object :
        1> function objects are "functions with state".
           objects that behave like pointers are smart pointers,this is similarly true for
           objects that behave like functions -
             "smart functions" because they may have abilities beyond operator(),can have
             other members to represent the state
           ! the same functionality represented by two different function objects of the same
             type,may have different states at the same time.
           ! can initialize them at runtime before use/call them.

        2> each function object has its own type.
           ordinary functions have different types only when their signatures differ,but function
           objects can has different types even when their signatures are the same.
           /* useful for generic programming */
        
        3> function objects are usually faster than ordinary functions.
           the concept of templates usually allows better optimization because more details are
           defined at compile time.

      Predefined Function Objects :
        <bits/stl_function.h> // namespace : std
          template<typename _Tp>
          struct greater : public binary_function<_Tp, _Tp, bool>
          {
            _GLIBCXX14_CONSTEXPR
            bool
            operator()(const _Tp& __x, const _Tp& __y) const
            { return __x > __y; }
          };

          template<typename _Tp>
          struct less : public binary_function<_Tp, _Tp, bool>
          {
            ... /* similar to greater<>,but applied operator< for comparison. */
          };

          template<typename _Tp>
          struct multiplies : public binary_function<_Tp, _Tp, _Tp>
          {
            ... /* similar to above,but applied operator* for calculating. */
          };

          template<typename _Tp>
          struct divides : public binary_function<_Tp, _Tp, _Tp>
          {
            ... /* x / y */
          };

          template<typename _Tp>
          struct modulus : public binary_function<_Tp, _Tp, _Tp>
          {
            ... /* x % y */
          };

          template<typename _Tp>
          struct negate : public unary_function<_Tp, _Tp>
          {
            ... /* x => -x */
          };

          struct plus<>                 /* binary function */
          struct minus<>                /* binary function */
          struct greater_equal<>        /* binary function */
          struct less_equal<>           /* binary function */
          struct equal_to<>             /* binary function */
          struct not_equal_to<>         /* unary  function */

      Binders :
        C++ defined special function adapters,or so-called binders,to combine predefined function objects
        with other values or use special cases.

        <functional>
          /**
           * bind - function template to product a function object
           * @_Func:
           *        template parameter,function
           * @_BoundArgs:
           *        template parameter pack collect arguments' types
           * @__f:  rvalue type of function object,for ordinary function,it is the function address
           * @__args:
           *        arguments pack
           * return:
           *        an object is type of _Bind<decay<_Func>::type(decay<_BoundArgs>::type...)>
           * namespace:
           *        std 
           * # _Bind<> is a template class,which require a @_Functor,
           *   and a collection of arguments @_Bound_args
           *   of course,it also defined operator(),it invoke private method __call_c(),
           *   and that method make use of std::__invoke() to invoke the functor with proper
           *   arguments
           *   # __call() => call unqualified
           *     __call_c() => call as const
           *     __call_v() => call as volatile
           *     __call_c_v() => call as const volatile
           *   # _Bind<> has data member named @_M_f is type of _Functor to store functor
           *     _Bind<> has data member named @_M_bound_args is type of tuple<_Bound_args...>
           *     to store arguments
           */
          template<typename _Func, typename... _BoundArgs>
          inline _GLIBCXX20_CONSTEXPR typename
          _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
          bind(_Func&& __f, _BoundArgs&&... __args);

          /**
           * bind - overload version for resutl type specified
           * @_Result:
           *        template parameter,type of result
           * @_Func:
           *        template parameter,function type
           * @_BoundArgs:
           *        template parameter pack,types of arguments
           * @__f:  rvalue reference to function
           * @__args:
           *        arguments
           * return:
           *        an object is type of _Bind_result<_Result, decay<_Func>::type(decay<_BoundArgs>::type...)>
           * # _Bind_result<> is also a template class,it similar to _Bind<>,but it require specify the
           *   type of result in template parameters
           */
          template<typename _Result, typenam _Func, typename... _BoundArgs>
          inline _GLIBCXX20_CONSTEXPR
          typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
          bind(_Func&& __f, _BoundArgs&&... __args);

          ! std::bind() can be used bind class method and class object.

          /**
           * placeholders - placeholder
           *                can be combined with std::bind to defer argument specify
           * namespace:     std
           * # placeholders do not allow hole,that is such format (_1, _3, _7, ...)
           *   is illegal.
           *   if placeholder _1 has applied,then next must to be _2,and so on
           *   but the format (@functor, _1, @arg, _2) for std::bind() is OK
           *                   # do not require continuous placeholders
           */
          namespace placeholders {
            extern const _Placeholder<1> _1;
            extern const _Placeholder<2> _2;
            ...
            extern const _Placeholder<29> _29;
          }

          e.g.
            int func(int x, int y)
            {
              return x + 2 + y;
            }

            std::set<int> int_set{...};
            std::set<int> res_set;

            std::transform(int_set.begin(), int_set.end(),
                           res_set.begin(), std::bind(func, std::placeholders::_1, 4));
            /**
             * when traversing the @int_set,each element is passed into the callable object
             * returned by std::bind(),and the functor is func().
             * so @x => @_1,@_1 => current element
             *    @y => 4
             * the elements are transformed(inserting) into @res_set is
             *   func(current element, 4) => current element + 2 + 4
             */

            auto callable_obj = std::bind(func, 2, 5); /* no defer */
            int r = callable(); /* invoke func(2, 5) => 2 + 2 + 5,@r == 9 */

            class AddInt {
            public:
              int add(int x, int y)
              {
                return x + y;
              }
            ...
            };

            AddInt addint;
            auto callable_obj(std::bind(&AddInt::add, std::ref(addint), _1, _2));
            /**
             * std::bind() make up a callable object,and bind a class object for
             * it because the functor is a class method.
             * use placeholders _1,_2 to defer arguments specify for @x and @y
             * ! class method has a implicit parameter that is the class object
             *   this method called from,it is the first parameter and can be
             *   omitted,it is also deferrable.
             *   e.g.
             *     auto callable_obj = std::bind(&AddInt::add, std::placeholders::_1, ...);
             *     AddInt addint;
             *     (void)callable_obj(std::ref(addint), 2, 3);
             *                        ^lvalue reference to @addint
             *                         member method add() called from @addint
             */

            int x(callable_obj(2, 3)); /* invoke addint.add(2, 3) */

    Container Elements :
      elements of containers must meet certain requirements because containers handle them in a special
      way.

      Requirements for Container Elements :
        fundamental requirements -
          1> an element must be copyable or movable.
          2> an element must be (move)assignable by the assignment operator.
          3> an element must be destroyable by a destructor. /* destructor can not be private,and no throw */

        soft requirements -
          1> for some member functions of sequence containers,the default constructor must be available.
          2> for several operations,the test of equality with operator== must be defined and is especially
             needed when elements are searched.
             /* for unordered containers,user can provide his own definition of equivalence if the elements
              * do not support operator==
              */
          3> for associative containers,the operations of the sorting criterion must be provided by the
             elements.
          4> for unordered containers,a hash function and an equivalence criterion must be provided for the
             elements.

      Value Semantics or Reference Semantics :
        copying values means that the STL containers provide "value semantics".
        the containers contain references to the objects that are their elements provide "reference semantics".

        C++ STL containers do not support "reference semantics",but we can implement it through several methods :
          1> let STL containers hold ordinary pointers.
             /* must prevent dangle pointer */
          2> let STL containers hold smart pointers.
             /* do not use ordinary pointers anymore */
          3> let STL containers hold std::reference_wrapper<> objects. /* let containers hold references */
             /* must prevent dangle reference */

    Errors and Exceptions inside the STL :
      Error Handling :
        the design goal of the STL was the best performance rather than the highest security.
         two reasons about do not introduce more error checking -
           1> error checking reduces performance,and speed is still a general goal of programs.
           2> error checking is selectable for user.

           ! error checking is possible but usually not required inside the STL.

        use of the STL requires that the following be met :
          1> iterators must be valid.
          2> iterators that refer to the past-the-end position have no element to which to refer.
          3> ranges must be valid.
          4> if more than one source range is used,the second and later ranges usually must have at
             least as many elements as the first one.
          5> destination ranges must have enough elements that can be overwritten;otherwise,insert
             iterators must be used.
        
      Exception Handling :
        the standard requires that only the usual standard exceptions may occur,such as bad_alloc for lack
        of memory or exceptions of user-defined operations.
        /* STL do not check logical errors,there are only two function calls for which the standard
         * requires that it migth cause an exception directly: at() method and reserve() method.
         */

        C++ standard library now guarantees the following :
          1> in general,no erase(), clear(), pop_back(), pop_front(), or swap() function throws and
             exception.also,no copy constructor or assignment operator of a returned iterator throws
             an exception.
          2> for all node-based containers,including the unordered containers,any failure to construct
             a node simply leaves the containers as it was.furthermore,removing a node can not fail,
             provided that destructors do not throw.
             however,for multiple-element insert operations of associative containers,the need to keep
             elements sorted makes full recovery from throws impractical,thus all single-element insert
             operations of associative and unordered containers support commit-or-rollback behavior,
             provided that the hash function for unordered containers does not throw.      /* atomic */
             the container's compare function does not throw.
          3> all array-based continers do not fully recover when an element gets inserted.
             pop back,push back do not require that existing elements get copied,if they throw,it is
             guaranteed that they have no effect.
             if element's copy constructor and assignment operator do not throw,every container operation
             for the element either succeeds or has no effect.

STL Containers :
    Common Container Abilities and Operations :
      Container Abilities :
        most abilities are requirements that in general every STL container should meet.

        core abitilies >
          1> all containers provide value rather than reference semantics.
             containters copy and/or move elements internally when they are inserted        
             rather than managing references to them.
             /* implicitly require the element can be copied or moved */
          2> the elements inside a container have a specific order.each container type provides
             operations that return iterators to iterate over the elements.
          3> in general,operations are not "safe" in the sense that they check for every possible error.
             the caller must ensure that the parameters of the operations meet the requirements
             these operations have.
             /* usually,the STL does not throw exception,but user-defined routine called by STL container
              * may throw exception.
              */

      Container Operations :
        a list of requirements that standard specified >
          Operations are Required : /* general container requirements */
            default constructible
            copy constructible
            copy assignment
            move constructible                    /* not for array<> */
            move assignment                       /* not for array<> */
            destructible
            is container empty?
            size of container                     /* not for forward_list<> */
            max size of container
            ==
            !=
            swap
            begin
            end
            cbegin
            cend

          Operations are optional :
            constructible from range              ContType c(start, end) /* not for array<> */
            constructible from initialize-list    ContType c({...})      /* not for array<> */
            initialize-list assignment            ContType c = {...}, c = {...} /* not for array<> */
            <                                     /* not for unordered containers
            >                                      * ...
            <=                                     * ...
            >=                                     * ... */
            clear                                 remove all elements /* not for array<> */

            ! by using std::istream_iterator<>,we can construct container with the elements
              from stdin,but the container must be constructible from range.
              e.g.
                /* new uniform initialization syntax */
                std::deque<int> d{std::istream_iterator<int>(std::cin),
                                  std::istream_iterator<int>()};

                /* another uniform,if no brackets,we are declaring a function */
                std::deque<int> dd((std::istream_iterator<int>(std::cin)),
                                   (std::istream_iterator<int>()));
