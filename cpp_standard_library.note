                                                        The C++ Standard Library 2

Callable Objects :
    objects that can be used to call some functionality >
      1> a function,where additional args are passed to as arguments
      2> a pointer to a member function,which is called for the object passed
         as the first additional argument(reference or pointer) and gets the
         remaining argument as member function parameters
      3> a function object(operator() for a passed object),where additional args
         are passed as arguments
      4> a lambda,which strictly speaking is a kind of function object

    function :
      void func(int a, float b, char c);
      func(1, 1.1, 'c');

    member function :
      void Class::func(Class &obj, int a, float b, char c);
      Class obj;    /* +-> can omit in prototype */
      obj.func(1, 1.1, 'c');

    function object :
      std::function<void (int a, float b, char c)> func(function);
      func(1, 1.1, 'c');

    lambda :
      auto function = [](int a, float b, char c) -> void { ... };
      function(1, 1.1, 'c');

    std::bind :
      the stuff bind of namespace std can be used to bind arguments with callable a object.
      the expression of std::bind returns a callable object,the detail is defined in header
      <tr1/functional>. // just include header <functional> as well

      <tr1/functional>
        template<typename _Functor, typename... _ArgTypes>
        inline _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>
        bind(_Functor __f, _ArgTypes... _args);

        /* another version returns _Bind_result object */

    std::async :
      the stuff async of namespace std can be used to start a new background task in two ways,
      one is async,another one is deferred.std::async is based on C++ promise,it is part of
      C++ future introduced in C++ 11.the header is <future>.

      <future>
        template<typename _Fn, typename... _Args>
        future<__async_result_of<_Fn, _Args...>>
        async(launch __policy, _Fn&& __fn, _Args&&... __args);

        /* launch could be @async,@deferred */

        template<typename _Fn, typename... _Args>
        future<__async_result_of<_Fn, _Args...>>
        async(_Fn&& __fn, _Args&&... __args);

Concurrency and Multithreading :
    Since C++ 11,language core supporting concurrency.
      Introduced memory model
        - it guarantees that updates on two different objects used by two different
          threads are independent of each other
      Introduced new keyword thread_local
        - define thread-specific variables and objects
      /**
       * In Linux,multithreading is implemented by POSIX thread model,the new thread is
       * a lightweight process cloned from the original process,they share the same
       * process address space,but the ip register for them has different instruction
       * position,sp register as the same,and so on.
       */

    The General Concurrency Guarantees of the C++ Standard Library :
      > modifying an object of a standard library type that is sharted between threads
        risks undefined behavior unless objects of that type are explicitly specified
        as being sharable without data races or user supplies a locking mechanism.
      > during the construction of an object in one thread,using it in another thread
        results in undefined behavior,without loss of generality,destruction as the same.
        /* this applies to objects are provided for thread synchronization */
      
      For STL containers :
        > concurrent read-only access is possible
        > concurrent access to different elements of the same container is possible
          (except for vector<bool>)
          /* read/write different elements has different positions in the container,
           * follow this view point,each element in the container is similar to a
           * variable in different memory position
           */    

      For formatted I/O to a _standard stream_ :
        > synchronized with C I/O,concurrent access is possible,although it might
          result in interleaved characters
          /* default behavior for std::cout, std::cin, std::cerr */
          /* std::ios::sync_with_stdio(bool value) is a trigger for such sync */

      > concurrent calls of atexit() and at_quick_exit() are synchronized,and more
        include set_new_handler(),set_unexpected(),set_terminate() and the corresponding
        geters
      > for all member functions of the default allocator except destructor,concurrent
        access is synchronized

      ! the library guarantees that C++ standard library has no "hidden" side effects
        that break concurrent access to different objects.      

Allocators :
    C++ standard library use special objects to handle the allocation and deallocation of
    memory in several places,such object is called "Allocator".they represent a special
    memory model and are used as an abstraction to translate the "need" to use memory
    into a raw "call" for memory.
    /* allocator is part of STL used to solve pointer type problem on PCs,but now as
     * the base for technical solution that use certain memory models withou changing
     * the interfaces.
     */

    the C++ allocator base is defined in <ext/new_allocator.h> inside to namespace std :
      template<typename _Tp>
      class new_allocator;  // allocator for global new

      typedef _TP value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      // more type definitions if __cplusplus <= 201703L
      
      member method allocate() is used to allocate a memory space with aligned specified size.
      member method deallocate() is used to deallocate the memory allocated previously.

    and an alias for std::allocator is introduced in <"architecture depend directory"/bits/c++allocator.h> :
      template<typename _Tp>
        using __allocator_base = __gnu_cxx::new_allocator<_Tp>;  // need __cplusplus >= 201103L

Pairs :
    a type used to treat two values as single unit,the most normal case is key/value pairs.
    the structure pair is defined in <utility> inside to namespace std.

    // the detail is defined in <bits/stl_pair.h>
    template<typename T1, typename T2>
    struct pair {
      ...
    };

    the structure allows :
      copy  move  assign  swap  compare
                                |
                                +--> A.first == B.first && A.second == B.second // operator<
                                 |
                                 +-> A.first < B.first || (!(A.first < B.first) &&
                                 |   A.second < B.second) // operator<
                                 +-> !(A < B) // operator<=
    type definitions :
      typedef _T1 first_type;
      typedef _T2 second_type;

    shortcut :
      /**
       * make_pair - shortcut for make up a pair
       * @_T1:       first type
       * @_T2:       second type
       * @__x:       forward reference to first object
       * @__y:       forward reference to second object
       * return:     value of an object is type of pair<_T1, _T2>{__x, __y}
       * # make_pair() "decay"s and "strip"s _T1 and _T2 for produce types
       *   of @first and @second.for example "a" and "ab" as parameters will
       *   get type const char *,not the const char[2] and const char[3]
       * # because of forward reference,make_pair() can combine with std::move()
       *   when move semantics is applied,and can combine with std::ref() when
       *   reference semantics is applied
       */
      template<typename _T1, typename _T2>
      constexpr pair<_T1, _T2>
      make_pair(_T1 &&__x, __T2 &&__y);

      /**
       * __pair_get - shortcut for get element in a pair object,only specializations
       *              _Int := 0 and _Int := 1 been defined
       */
      template<std::size_t _Int>
      struct __pair_get;

      // get value in pair object,more overloaded versions
      template<std::size_t _Int, class _Tp1, class _Tp2>
      constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type &
      get(std::pair<_Tp1, _Tp2>& __in) noexcept;

    ! because std::tuple is the extend for std::pair,thus template methods std::tuple_size
      and std::tuple_element can be used on an object is type of std::pair.
    ! C++ language rule request an explicit call of a default constructor also initializes
      fundamental data types,for the pair,the constructors first() and second() will be
      called by pair().
    ! since C++ 11,a std::pair using a type that has only a nonconstant copy constructor
      will no longer compile.

    a special constructor of std::pair :
      /**
       * pair - a constructor for std::pair introduced for the situation that @first_type and/or
       *        @second_type is std::tuple
       * @_Args1:    template parameter pack for tuple1
       * @_Args2:    template parameter pack for tuple2
       * @piecewise_construct_t:    void structure used as an identifier
       * @tuple objects:    std::tuple for @first and/or @second
       * # if the type of data member is not tuple,then implicit type conversion will
       *   take place during construct the object
       */
      template<typename... _Args1, typename... _Args2>
      _GLIBCXX20_CONSTEXPR
      pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

Tuples :
    extend pairs to represent a heterogeneous list  of elements for which the types are specified
    or deduced at compile time.
    for tuple apply C++ 98 features,the implementation defined at least ten template parameters,that
    is the maximum number of elements.the newer C++ 11 supported template parameter pack,thus there
    can have more than ten elements in a tuple.

    <tuple>
      /* tuple - tuple is a container extended std::pair */
      /* tuple is in namespace std */
      template<typename... _Elements>
      class tuple : public _Tuple_impl<0, _Elements...>
      {
        ...
      };

    shortcut :
      /* make_tuple - template function used to makeup a tuple object and return it */
       * # because make_tuple() is a template function,thus automatically type deduce
       *   will process
       * # std::ref() and std::cref() combined with make_tuple() is possible to
       *   let tuple include an element whose type is a lvalue reference or a const lvalue
       *   reference.by using reference with make_tuple(),allow extract values of a tuple
       *   back to some other variable
       */
      template<typename... _Elements>
      constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
      make_tuple(_Elements&&... __args);

      /* tie - makeup a tupe with lvalue references and return it
       * # for const lvalue reference,the types pass to template should with const quantifier
       * # std::ignore can be used as a placeholder to tell tie() do not process reference
       *   binding on "this" element
       */
      template<typename... _Elements>
      constexpr tuple<_Elements&...>
      tie(_Elements&... __args) noexcept;


      /* __get_helper - this implementation applied a special programming technique to extract
       *                the specified __i-th element in a tuple object
       * # used template metaprogramming technique
       */
      template<std::size_t __i, typename _Head, typename... _Tail>
      constexpr _Head&
      __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
      { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

      /* get - get @__i-th element in a tuple,this routine returns std::__get_helper<__i>(__t) */
      template<std::size_t __i, typename... _Elements>
      constexpr __tuple_element_t<__i, tuple<_Elements...>>&
      get(tuple<_Elements...>& __t) noexcept;

      ! because get() returns a value is constexpr,that means it is compile-time constant,thus
        index __i can not be a variable is not constexpr.
        e.g.
          int i(0); // @i is not a constexpr value,that it is runtime variable
          auto t(make_tuple(1, 1.1, 'c');
          auto x = get<i>(t);
      ! pass an invalid index also throw a compile-time error.

    Allowed operations :
      assign  copy  move  swap  compare
                                |
                                +--> A.@all == B.@all
                                 |
                                 +-> A1 < B1 || (!(A1 < B1) && (A2 < B2 || .. // lexicographical comparison
                                 |
                                 +-> !(A < B)
    
    Tuple and Initializer lists :
      std::tuple<@types> t(@arguments);      //  OK,call to copy constructor
      std::tuple<@types> t1{@arguments};     //  OK,call to copy constructor
      std::tuple<@types> t2 = {@arguments};  //  ERROR,call to assignment operator
                                             //  for process assignment,the rvalue must been constructred
                                             //  t2 = std::tuple<@types>{@arguments}; => OK

      std::vector<std::tuple<int, float>> v{{1, 1.1}, {2, 1.2}};  // ERROR
      // but it is OK when @value_type is std::pair<int, float> or std::vector
      // it is OK when combine std::make_tuple() with initializer list
      //   std::vector<std::tuple<int, float>> v{std::make_tuple(1, 1.1), std::make_tuple(2, 2.2)};

      return {1, 2, 3}; in a function which returns a value is type of std::tuple<int, int, int>.
      // ERROR for std::tuple,but it is OK for std::vector

    Additional Tuple Features :
      /**
       * tuple_size - structure template in namespace std used to calculate the number of elements
       *              in std::tuple object
       * # operator sizeof...() is a compiler feature used to get number of types in template
       *   parameter pack
       * # integral_constant::value is the number of elements of "this" tuple object
       */
      template<typename... _Elements>
      struct tuple_size<tuple<_Elements...>>
      : public integral_constant<std::size_t, sizeof...(_Elements)> { };

      /**
       * tuple_element - structure template in namespace std used to get the type of a specified
       *                 element in std::tuple object
       * # recursive derive itself,used template metaprogramming technique
       * # type definition "typedef _Head type;" is introduced in the specialization that __i := 0,
       *   @type is the type of that @__i-th element 
       */
      template<std::size_t __i, typename _Head, typename... _Tail>
      struct tuple_element<__i, tuple<_Head, _Tail...>>
      : tuple_element<__i - 1, tuple<_Tail...>> { };

      /**
       * tuple_cat - function template in namespace std used to concatenates multiple tuples into
       *             one tuple
       * # this function template receive forward reference
       * # this function applied trailing return type function definition
       */
      template<typename... _Tpls,
               typename = typename enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
      constexpr auto
      tuple_cat(_Tpls&&... __tpls)
      -> typename __tuple_cat_result<_Tpls...>::__type
      {
        ...
      }
        
    I/O for Tuples :
      std::tuple does not provide operator<< overload for output values to standard output through
      std::cout(nor standard error std::cerr).

      if you want it,then you have to implement it.

      e.g.
        // use compile-time recursion to traverse every element
        // in the tuple object,and print them to standard output
        // *template metaprogramming*
        
        template<std::size_t IDX, std::size_t MAX, typename... _TupleTypes>
        struct PrintTuple {
          static void print(std::tuple<_TupleTypes...> &t)
          {
            std::cout << std::get<IDX>(t) << " ";
            PrintTuple<IDX + 1, MAX, _TupleTypes...>::print(t); // print next one
          }
        };

        // partial specialization to end the recursion
        template<std::size_t MAX, typename... _TupleTypes>
        struct PrintTuple<MAX, MAX, _TupleTypes...> {
          static void print(std::tuple<_TupleTypes...> &t)
          { }
        }

        // caller
        template<typename... _TupleTypes>
        void printTuple(std::tuple<_TupleTypes> &t)
        {
          PrintTuple<0, std::tuple_size(t), _TupleTypes...>::print(t);
        }

        std::tuple<@types> x(std::make_tuple<@type>{@arguments});
        printTuple(x);

    Conversions between tuples and pairs :
      for convert std::tuple to std::pair,should construct the std::pair by special
      constructor piecewise_construct_t as its first parameter.

      for convert std::pair to std::tuple,should instantiate a partial specialization
      2-element tuple template.that partial specialization includes construction and
      assignment from a std::pair.
      <tuple>
        template<typename _T1, typename _T2>
        class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
        {
          ...
        };

        // construction for a 2-elements tuple from a pair
        // function definition outside to class definition
        template<typename _T1, typename _T2>
        template<typename _U1, typename _U2, _ImpliciCtor<true, const _U1&, const _U2&> = true>
        constexpr
        tuple<_T1, _T2>::tuple(const pair<_U1, _U2> &__in)
        noexcept(__nothrow_constructible<const _U1 &, const _U2 &>())
        : _Inherited(__in.first, __in.second)
        { }

Smart Pointers :
    shared_ptr :
      pointer that can be shared by several owners,and memory is recycled when the reference
      count become _zero_.

      the destructor of shared_ptr call to "delete" as a default behavior,thus,if used it
      with array together,must define an array-specified destruction policy.
      for do this,should pass it a callable object that the callback function,it will be
      called in destructor.
      define a deleter :
        std::shared_ptr<int> pInt(new int[10], [](int *p) -> void { delete[] p; });

      a helper officially provided for std::unique_ptr for array-deleting also can be
      used with std::shared_ptr.
        std::default_delete<@type[]>()

      destruction policy :
        of couse,the deleter of std::shared_ptr can be an object of a user-defined class.
        in this case,operator() must be overloaded.
        the object will be called in destructor of std::shared_ptr through @obj(@type pointer)
        function calling.

        ! notice that,the destruction policy is not deallocate memory only.it could do everything
          that we want.but at the last,it must deallocate the memory.the overload operator()
          can pass the pointer to another function,hand over the deallocating to them.this is
          useful when handle system share resources such shared memory.

      ! can not create several std::shared_ptr objects refer to the same one object,this will bring
        a problem that the object is deallocated more than once.
        # copy an existed std::shared_ptr object is OK
        # keep only one group of shared pointers owns an object
      ! std smart pointer stuff class template std::enable_shared_from_this can pass the "this"
        pointer in a class method to the outside place.
        e.g.
          class A : public std::enable_shared_from_this<A>
          {
          public:
            void func(std::vector<A> &vec)
            {
              ...
              vec.push_back(shared_from_this()); // OK
              ...
            }
            ...
          };
          /* if no std::enable_shared_from_this,then send @this to another std::shared_ptr group is
           * an error
           * another way,is pass the pointer of class object as additional parameter for that method,
           * but that is not elegant.
           * !! CAN NOT shared_from_this() WHEN AN OBJECT IS CONSTRUCTING,OF COURSE DESTRUCTING.
           */

    weak_ptr :
      std::weak_ptr is introduced for solve the following two problems they might happens when using
      std::shared_ptr :
        1> cyclic references
             A -> B
             B -> A
        2> explicitly share but not own an object
           semantics : the lifetime of a reference to an object outlives the object it refers to
           /* dangling pointer */

      std::weak_ptr,allows sharing but now owning an object.for use this class,require a shared
      pointer,whenever the last shared pointer owning the object lose its ownership,any std::weak_ptr
      automatically becomes empty.so,except default and copy constructors,std::weak_ptr provides
      only a constructor taking a std::shared_ptr object.

      ! dereference operator and member access operator are not supported by std::weak_ptr,for
        do these operations,must use the std::weak_ptr to create a std::shared_ptr at first.
        in this way we can :
          1> checks whether the pointer is NULL,if it is,then throw an exception or create
             empty std::shared_ptr object
          2> we are using the referred object,that the object referred by the std::shared_ptr
             will not be deallocated unexpectedly

      usage :
        std::shared_ptr<int> pInt(new int(10));

        std::weak_ptr<int> weakPInt(pInt);
        std::shared_ptr<int> weakPIntOP(weakPInt);

        *weakPIntOP = 20;
      

       
      