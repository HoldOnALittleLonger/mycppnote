                                                        The C++ Standard Library 2

Callable Objects :
    objects that can be used to call some functionality >
      1> a function,where additional args are passed to as arguments
      2> a pointer to a member function,which is called for the object passed
         as the first additional argument(reference or pointer) and gets the
         remaining argument as member function parameters
      3> a function object(operator() for a passed object),where additional args
         are passed as arguments
      4> a lambda,which strictly speaking is a kind of function object

    function :
      void func(int a, float b, char c);
      func(1, 1.1, 'c');

    member function :
      void Class::func(Class &obj, int a, float b, char c);
      Class obj;    /* +-> can omit in prototype */
      obj.func(1, 1.1, 'c');

    function object :
      std::function<void (int a, float b, char c)> func(function);
      func(1, 1.1, 'c');

    lambda :
      auto function = [](int a, float b, char c) -> void { ... };
      function(1, 1.1, 'c');

    std::bind :
      the stuff bind of namespace std can be used to bind arguments with callable a object.
      the expression of std::bind returns a callable object,the detail is defined in header
      <tr1/functional>. // just include header <functional> as well

      <tr1/functional>
        template<typename _Functor, typename... _ArgTypes>
        inline _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>
        bind(_Functor __f, _ArgTypes... _args);

        /* another version returns _Bind_result object */

    std::async :
      the stuff async of namespace std can be used to start a new background task in two ways,
      one is async,another one is deferred.std::async is based on C++ promise,it is part of
      C++ future introduced in C++ 11.the header is <future>.

      <future>
        template<typename _Fn, typename... _Args>
        future<__async_result_of<_Fn, _Args...>>
        async(launch __policy, _Fn&& __fn, _Args&&... __args);

        /* launch could be @async,@deferred */

        template<typename _Fn, typename... _Args>
        future<__async_result_of<_Fn, _Args...>>
        async(_Fn&& __fn, _Args&&... __args);

Concurrency and Multithreading :
    Since C++ 11,language core supporting concurrency.
      Introduced memory model
        - it guarantees that updates on two different objects used by two different
          threads are independent of each other
      Introduced new keyword thread_local
        - define thread-specific variables and objects
      /**
       * In Linux,multithreading is implemented by POSIX thread model,the new thread is
       * a lightweight process cloned from the original process,they share the same
       * process address space,but the ip register for them has different instruction
       * position,sp register as the same,and so on.
       */

    The General Concurrency Guarantees of the C++ Standard Library :
      > modifying an object of a standard library type that is sharted between threads
        risks undefined behavior unless objects of that type are explicitly specified
        as being sharable without data races or user supplies a locking mechanism.
      > during the construction of an object in one thread,using it in another thread
        results in undefined behavior,without loss of generality,destruction as the same.
        /* this applies to objects are provided for thread synchronization */
      
      For STL containers :
        > concurrent read-only access is possible
        > concurrent access to different elements of the same container is possible
          (except for vector<bool>)
          /* read/write different elements has different positions in the container,
           * follow this view point,each element in the container is similar to a
           * variable in different memory position
           */    

      For formatted I/O to a _standard stream_ :
        > synchronized with C I/O,concurrent access is possible,although it might
          result in interleaved characters
          /* default behavior for std::cout, std::cin, std::cerr */
          /* std::ios::sync_with_stdio(bool value) is a trigger for such sync */

      > concurrent calls of atexit() and at_quick_exit() are synchronized,and more
        include set_new_handler(),set_unexpected(),set_terminate() and the corresponding
        geters
      > for all member functions of the default allocator except destructor,concurrent
        access is synchronized

      ! the library guarantees that C++ standard library has no "hidden" side effects
        that break concurrent access to different objects.      

Allocators :
    C++ standard library use special objects to handle the allocation and deallocation of
    memory in several places,such object is called "Allocator".they represent a special
    memory model and are used as an abstraction to translate the "need" to use memory
    into a raw "call" for memory.
    /* allocator is part of STL used to solve pointer type problem on PCs,but now as
     * the base for technical solution that use certain memory models withou changing
     * the interfaces.
     */

    the C++ allocator base is defined in <ext/new_allocator.h> inside to namespace std :
      template<typename _Tp>
      class new_allocator;  // allocator for global new

      typedef _TP value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      // more type definitions if __cplusplus <= 201703L
      
      member method allocate() is used to allocate a memory space with aligned specified size.
      member method deallocate() is used to deallocate the memory allocated previously.

    and an alias for std::allocator is introduced in <"architecture depend directory"/bits/c++allocator.h> :
      template<typename _Tp>
        using __allocator_base = __gnu_cxx::new_allocator<_Tp>;  // need __cplusplus >= 201103L

Pairs :
    a type used to treat two values as single unit,the most normal case is key/value pairs.
    the structure pair is defined in <utility> inside to namespace std.

    // the detail is defined in <bits/stl_pair.h>
    template<typename T1, typename T2>
    struct pair {
      ...
    };

    the structure allows :
      copy  move  assign  swap  compare
                                |
                                +--> A.first == B.first && A.second == B.second // operator<
                                 |
                                 +-> A.first < B.first || (!(A.first < B.first) &&
                                 |   A.second < B.second) // operator<
                                 +-> !(A < B) // operator<=
    type definitions :
      typedef _T1 first_type;
      typedef _T2 second_type;

    shortcut :
      /**
       * make_pair - shortcut for make up a pair
       * @_T1:       first type
       * @_T2:       second type
       * @__x:       forward reference to first object
       * @__y:       forward reference to second object
       * return:     value of an object is type of pair<_T1, _T2>{__x, __y}
       * # make_pair() "decay"s and "strip"s _T1 and _T2 for produce types
       *   of @first and @second.for example "a" and "ab" as parameters will
       *   get type const char *,not the const char[2] and const char[3]
       * # because of forward reference,make_pair() can combine with std::move()
       *   when move semantics is applied,and can combine with std::ref() when
       *   reference semantics is applied
       */
      template<typename _T1, typename _T2>
      constexpr pair<_T1, _T2>
      make_pair(_T1 &&__x, __T2 &&__y);

      /**
       * __pair_get - shortcut for get element in a pair object,only specializations
       *              _Int := 0 and _Int := 1 been defined
       */
      template<std::size_t _Int>
      struct __pair_get;

      // get value in pair object,more overloaded versions
      template<std::size_t _Int, class _Tp1, class _Tp2>
      constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type &
      get(std::pair<_Tp1, _Tp2>& __in) noexcept;

    ! because std::tuple is the extend for std::pair,thus template methods std::tuple_size
      and std::tuple_element can be used on an object is type of std::pair.
    ! C++ language rule request an explicit call of a default constructor also initializes
      fundamental data types,for the pair,the constructors first() and second() will be
      called by pair().
    ! since C++ 11,a std::pair using a type that has only a nonconstant copy constructor
      will no longer compile.

    a special constructor of std::pair :
      /**
       * pair - a constructor for std::pair introduced for the situation that @first_type and/or
       *        @second_type is std::tuple
       * @_Args1:    template parameter pack for tuple1
       * @_Args2:    template parameter pack for tuple2
       * @piecewise_construct_t:    void structure used as an identifier
       * @tuple objects:    std::tuple for @first and/or @second
       * # if the type of data member is not tuple,then implicit type conversion will
       *   take place during construct the object
       */
      template<typename... _Args1, typename... _Args2>
      _GLIBCXX20_CONSTEXPR
      pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

Tuples :
    extend pairs to represent a heterogeneous list  of elements for which the types are specified
    or deduced at compile time.
    for tuple apply C++ 98 features,the implementation defined at least ten template parameters,that
    is the maximum number of elements.the newer C++ 11 supported template parameter pack,thus there
    can have more than ten elements in a tuple.

    <tuple>
      /* tuple - tuple is a container extended std::pair */
      /* tuple is in namespace std */
      template<typename... _Elements>
      class tuple : public _Tuple_impl<0, _Elements...>
      {
        ...
      };

    shortcut :
      /* make_tuple - template function used to makeup a tuple object and return it */
       * # because make_tuple() is a template function,thus automatically type deduce
       *   will process
       * # std::ref() and std::cref() combined with make_tuple() is possible to
       *   let tuple include an element whose type is a lvalue reference or a const lvalue
       *   reference.by using reference with make_tuple(),allow extract values of a tuple
       *   back to some other variable
       */
      template<typename... _Elements>
      constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
      make_tuple(_Elements&&... __args);

      /* tie - makeup a tupe with lvalue references and return it
       * # for const lvalue reference,the types pass to template should with const quantifier
       * # std::ignore can be used as a placeholder to tell tie() do not process reference
       *   binding on "this" element
       */
      template<typename... _Elements>
      constexpr tuple<_Elements&...>
      tie(_Elements&... __args) noexcept;


      /* __get_helper - this implementation applied a special programming technique to extract
       *                the specified __i-th element in a tuple object
       * # used template metaprogramming technique
       */
      template<std::size_t __i, typename _Head, typename... _Tail>
      constexpr _Head&
      __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
      { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

      /* get - get @__i-th element in a tuple,this routine returns std::__get_helper<__i>(__t) */
      template<std::size_t __i, typename... _Elements>
      constexpr __tuple_element_t<__i, tuple<_Elements...>>&
      get(tuple<_Elements...>& __t) noexcept;

      ! because get() returns a value is constexpr,that means it is compile-time constant,thus
        index __i can not be a variable is not constexpr.
        e.g.
          int i(0); // @i is not a constexpr value,that it is runtime variable
          auto t(make_tuple(1, 1.1, 'c');
          auto x = get<i>(t);
      ! pass an invalid index also throw a compile-time error.

    Allowed operations :
      assign  copy  move  swap  compare
                                |
                                +--> A.@all == B.@all
                                 |
                                 +-> A1 < B1 || (!(A1 < B1) && (A2 < B2 || .. // lexicographical comparison
                                 |
                                 +-> !(A < B)
    
    Tuple and Initializer lists :
      std::tuple<@types> t(@arguments);      //  OK,call to copy constructor
      std::tuple<@types> t1{@arguments};     //  OK,call to copy constructor
      std::tuple<@types> t2 = {@arguments};  //  ERROR,call to assignment operator
                                             //  for process assignment,the rvalue must been constructred
                                             //  t2 = std::tuple<@types>{@arguments}; => OK

      std::vector<std::tuple<int, float>> v{{1, 1.1}, {2, 1.2}};  // ERROR
      // but it is OK when @value_type is std::pair<int, float> or std::vector
      // it is OK when combine std::make_tuple() with initializer list
      //   std::vector<std::tuple<int, float>> v{std::make_tuple(1, 1.1), std::make_tuple(2, 2.2)};

      return {1, 2, 3}; in a function which returns a value is type of std::tuple<int, int, int>.
      // ERROR for std::tuple,but it is OK for std::vector

    Additional Tuple Features :
      /**
       * tuple_size - structure template in namespace std used to calculate the number of elements
       *              in std::tuple object
       * # operator sizeof...() is a compiler feature used to get number of types in template
       *   parameter pack
       * # integral_constant::value is the number of elements of "this" tuple object
       */
      template<typename... _Elements>
      struct tuple_size<tuple<_Elements...>>
      : public integral_constant<std::size_t, sizeof...(_Elements)> { };

      /**
       * tuple_element - structure template in namespace std used to get the type of a specified
       *                 element in std::tuple object
       * # recursive derive itself,used template metaprogramming technique
       * # type definition "typedef _Head type;" is introduced in the specialization that __i := 0,
       *   @type is the type of that @__i-th element 
       */
      template<std::size_t __i, typename _Head, typename... _Tail>
      struct tuple_element<__i, tuple<_Head, _Tail...>>
      : tuple_element<__i - 1, tuple<_Tail...>> { };

      /**
       * tuple_cat - function template in namespace std used to concatenates multiple tuples into
       *             one tuple
       * # this function template receive forward reference
       * # this function applied trailing return type function definition
       */
      template<typename... _Tpls,
               typename = typename enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
      constexpr auto
      tuple_cat(_Tpls&&... __tpls)
      -> typename __tuple_cat_result<_Tpls...>::__type
      {
        ...
      }
        