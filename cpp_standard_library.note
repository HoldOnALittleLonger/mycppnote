                                                        The C++ Standard Library 2

Callable Objects :
    objects that can be used to call some functionality >
      1> a function,where additional args are passed to as arguments
      2> a pointer to a member function,which is called for the object passed
         as the first additional argument(reference or pointer) and gets the
         remaining argument as member function parameters
      3> a function object(operator() for a passed object),where additional args
         are passed as arguments
      4> a lambda,which strictly speaking is a kind of function object

    function :
      void func(int a, float b, char c);
      func(1, 1.1, 'c');

    member function :
      void Class::func(Class &obj, int a, float b, char c);
      Class obj;    /* +-> can omit in prototype */
      obj.func(1, 1.1, 'c');

    function object :
      std::function<void (int a, float b, char c)> func(function);
      func(1, 1.1, 'c');

    lambda :
      auto function = [](int a, float b, char c) -> void { ... };
      function(1, 1.1, 'c');

    std::bind :
      the stuff bind of namespace std can be used to bind arguments with callable a object.
      the expression of std::bind returns a callable object,the detail is defined in header
      <tr1/functional>. // just include header <functional> as well

      <tr1/functional>
        template<typename _Functor, typename... _ArgTypes>
        inline _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>
        bind(_Functor __f, _ArgTypes... _args);

        /* another version returns _Bind_result object */

    std::async :
      the stuff async of namespace std can be used to start a new background task in two ways,
      one is async,another one is deferred.std::async is based on C++ promise,it is part of
      C++ future introduced in C++ 11.the header is <future>.

      <future>
        template<typename _Fn, typename... _Args>
        future<__async_result_of<_Fn, _Args...>>
        async(launch __policy, _Fn&& __fn, _Args&&... __args);

        /* launch could be @async,@deferred */

        template<typename _Fn, typename... _Args>
        future<__async_result_of<_Fn, _Args...>>
        async(_Fn&& __fn, _Args&&... __args);

Concurrency and Multithreading :
    Since C++ 11,language core supporting concurrency.
      Introduced memory model
        - it guarantees that updates on two different objects used by two different
          threads are independent of each other
      Introduced new keyword thread_local
        - define thread-specific variables and objects
      /**
       * In Linux,multithreading is implemented by POSIX thread model,the new thread is
       * a lightweight process cloned from the original process,they share the same
       * process address space,but the ip register for them has different instruction
       * position,sp register as the same,and so on.
       */

    The General Concurrency Guarantees of the C++ Standard Library :
      > modifying an object of a standard library type that is sharted between threads
        risks undefined behavior unless objects of that type are explicitly specified
        as being sharable without data races or user supplies a locking mechanism.
      > during the construction of an object in one thread,using it in another thread
        results in undefined behavior,without loss of generality,destruction as the same.
        /* this applies to objects are provided for thread synchronization */
      
      For STL containers :
        > concurrent read-only access is possible
        > concurrent access to different elements of the same container is possible
          (except for vector<bool>)
          /* read/write different elements has different positions in the container,
           * follow this view point,each element in the container is similar to a
           * variable in different memory position
           */    

      For formatted I/O to a _standard stream_ :
        > synchronized with C I/O,concurrent access is possible,although it might
          result in interleaved characters
          /* default behavior for std::cout, std::cin, std::cerr */
          /* std::ios::sync_with_stdio(bool value) is a trigger for such sync */

      > concurrent calls of atexit() and at_quick_exit() are synchronized,and more
        include set_new_handler(),set_unexpected(),set_terminate() and the corresponding
        geters
      > for all member functions of the default allocator except destructor,concurrent
        access is synchronized

      ! the library guarantees that C++ standard library has no "hidden" side effects
        that break concurrent access to different objects.      

Allocators :
    C++ standard library use special objects to handle the allocation and deallocation of
    memory in several places,such object is called "Allocator".they represent a special
    memory model and are used as an abstraction to translate the "need" to use memory
    into a raw "call" for memory.
    /* allocator is part of STL used to solve pointer type problem on PCs,but now as
     * the base for technical solution that use certain memory models withou changing
     * the interfaces.
     */

    the C++ allocator base is defined in <ext/new_allocator.h> inside to namespace std :
      template<typename _Tp>
      class new_allocator;  // allocator for global new

      typedef _TP value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      // more type definitions if __cplusplus <= 201703L
      
      member method allocate() is used to allocate a memory space with aligned specified size.
      member method deallocate() is used to deallocate the memory allocated previously.

    and an alias for std::allocator is introduced in <"architecture depend directory"/bits/c++allocator.h> :
      template<typename _Tp>
        using __allocator_base = __gnu_cxx::new_allocator<_Tp>;  // need __cplusplus >= 201103L

Pairs :
    a type used to treat two values as single unit,the most normal case is key/value pairs.
    the structure pair is defined in <utility> inside to namespace std.

    // the detail is defined in <bits/stl_pair.h>
    template<typename T1, typename T2>
    struct pair {
      ...
    };

    the structure allows :
      copy  move  assign  swap  compare
                                |
                                +--> A.first == B.first && A.second == B.second // operator<
                                 |
                                 +-> A.first < B.first || (!(A.first < B.first) &&
                                 |   A.second < B.second) // operator<
                                 +-> !(A < B) // operator<=
    type definitions :
      typedef _T1 first_type;
      typedef _T2 second_type;

    shortcut :
      /**
       * make_pair - shortcut for make up a pair
       * @_T1:       first type
       * @_T2:       second type
       * @__x:       forward reference to first object
       * @__y:       forward reference to second object
       * return:     value of an object is type of pair<_T1, _T2>{__x, __y}
       * # make_pair() "decay"s and "strip"s _T1 and _T2 for produce types
       *   of @first and @second.for example "a" and "ab" as parameters will
       *   get type const char *,not the const char[2] and const char[3]
       * # because of forward reference,make_pair() can combine with std::move()
       *   when move semantics is applied,and can combine with std::ref() when
       *   reference semantics is applied
       */
      template<typename _T1, typename _T2>
      constexpr pair<_T1, _T2>
      make_pair(_T1 &&__x, __T2 &&__y);

      /**
       * __pair_get - shortcut for get element in a pair object,only specializations
       *              _Int := 0 and _Int := 1 been defined
       */
      template<std::size_t _Int>
      struct __pair_get;

      // get value in pair object,more overloaded versions
      template<std::size_t _Int, class _Tp1, class _Tp2>
      constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type &
      get(std::pair<_Tp1, _Tp2>& __in) noexcept;

    ! because std::tuple is the extend for std::pair,thus template methods std::tuple_size
      and std::tuple_element can be used on an object is type of std::pair.
    ! C++ language rule request an explicit call of a default constructor also initializes
      fundamental data types,for the pair,the constructors first() and second() will be
      called by pair().
    ! since C++ 11,a std::pair using a type that has only a nonconstant copy constructor
      will no longer compile.

    a special constructor of std::pair :
      /**
       * pair - a constructor for std::pair introduced for the situation that @first_type and/or
       *        @second_type is std::tuple
       * @_Args1:    template parameter pack for tuple1
       * @_Args2:    template parameter pack for tuple2
       * @piecewise_construct_t:    void structure used as an identifier
       * @tuple objects:    std::tuple for @first and/or @second
       * # if the type of data member is not tuple,then implicit type conversion will
       *   take place during construct the object
       */
      template<typename... _Args1, typename... _Args2>
      _GLIBCXX20_CONSTEXPR
      pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);