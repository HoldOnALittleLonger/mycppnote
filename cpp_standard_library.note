                                                        The C++ Standard Library 2

Callable Objects :
    objects that can be used to call some functionality >
      1> a function,where additional args are passed to as arguments
      2> a pointer to a member function,which is called for the object passed
         as the first additional argument(reference or pointer) and gets the
         remaining argument as member function parameters
      3> a function object(operator() for a passed object),where additional args
         are passed as arguments
      4> a lambda,which strictly speaking is a kind of function object

    function :
      void func(int a, float b, char c);
      func(1, 1.1, 'c');

    member function :
      void Class::func(Class &obj, int a, float b, char c);
                    /* |                         */
      Class obj;    /* +-> can omit in prototype */
      obj.func(1, 1.1, 'c');

    function object :
      std::function<void (int a, float b, char c)> func(function);
      func(1, 1.1, 'c');

    lambda :
      auto function = [](int a, float b, char c) -> void { ... };
      function(1, 1.1, 'c');

    std::bind :
      the stuff bind of namespace std can be used to bind arguments with callable a object.
      the expression of std::bind returns a callable object,the detail is defined in header
      <tr1/functional>. // just include header <functional> as well

      <tr1/functional>
        template<typename _Functor, typename... _ArgTypes>
        inline _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>
        bind(_Functor __f, _ArgTypes... _args);

        /* another version returns _Bind_result object */

    std::async :
      the stuff async of namespace std can be used to start a new background task in two ways,
      one is async,another one is deferred.std::async is based on C++ promise,it is part of
      C++ future introduced in C++ 11.the header is <future>.

      <future>
        template<typename _Fn, typename... _Args>
        future<__async_result_of<_Fn, _Args...>>
        async(launch __policy, _Fn&& __fn, _Args&&... __args);

        /* launch could be @async,@deferred */

        template<typename _Fn, typename... _Args>
        future<__async_result_of<_Fn, _Args...>>
        async(_Fn&& __fn, _Args&&... __args);

Concurrency and Multithreading :
    Since C++ 11,language core supporting concurrency.
      Introduced memory model
        - it guarantees that updates on two different objects used by two different
          threads are independent of each other
      Introduced new keyword thread_local
        - define thread-specific variables and objects
      /**
       * In Linux,multithreading is implemented by POSIX thread model,the new thread is
       * a lightweight process cloned from the original process,they share the same
       * process address space,but the ip register for them has different instruction
       * position,sp register as the same,and so on.
       */

    The General Concurrency Guarantees of the C++ Standard Library :
      > modifying an object of a standard library type that is sharted between threads
        risks undefined behavior unless objects of that type are explicitly specified
        as being sharable without data races or user supplies a locking mechanism.
      > during the construction of an object in one thread,using it in another thread
        results in undefined behavior,without loss of generality,destruction as the same.
        /* this applies to objects are provided for thread synchronization */
      
      For STL containers :
        > concurrent read-only access is possible
        > concurrent access to different elements of the same container is possible
          (except for vector<bool>)
          /* read/write different elements has different positions in the container,
           * follow this view point,each element in the container is similar to a
           * variable in different memory position
           */    

      For formatted I/O to a _standard stream_ :
        > synchronized with C I/O,concurrent access is possible,although it might
          result in interleaved characters
          /* default behavior for std::cout, std::cin, std::cerr */
          /* std::ios::sync_with_stdio(bool value) is a trigger for such sync */

      > concurrent calls of atexit() and at_quick_exit() are synchronized,and more
        include set_new_handler(),set_unexpected(),set_terminate() and the corresponding
        geters
      > for all member functions of the default allocator except destructor,concurrent
        access is synchronized

      ! the library guarantees that C++ standard library has no "hidden" side effects
        that break concurrent access to different objects.      

Allocators :
    C++ standard library use special objects to handle the allocation and deallocation of
    memory in several places,such object is called "Allocator".they represent a special
    memory model and are used as an abstraction to translate the "need" to use memory
    into a raw "call" for memory.
    /* allocator is part of STL used to solve pointer type problem on PCs,but now as
     * the base for technical solution that use certain memory models withou changing
     * the interfaces.
     */

    the C++ allocator base is defined in <ext/new_allocator.h> inside to namespace std :
      template<typename _Tp>
      class new_allocator;  // allocator for global new

      typedef _TP value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      // more type definitions if __cplusplus <= 201703L
      
      member method allocate() is used to allocate a memory space with aligned specified size.
      member method deallocate() is used to deallocate the memory allocated previously.

    and an alias for std::allocator is introduced in <"architecture depend directory"/bits/c++allocator.h> :
      template<typename _Tp>
        using __allocator_base = __gnu_cxx::new_allocator<_Tp>;  // need __cplusplus >= 201103L

Pairs :
    a type used to treat two values as single unit,the most normal case is key/value pairs.
    the structure pair is defined in <utility> inside to namespace std.

    // the detail is defined in <bits/stl_pair.h>
    template<typename T1, typename T2>
    struct pair {
      ...
    };

    the structure allows :
      copy  move  assign  swap  compare
                                |
                                +--> A.first == B.first && A.second == B.second // operator<
                                 |
                                 +-> A.first < B.first || (!(A.first < B.first) &&
                                 |   A.second < B.second) // operator<
                                 +-> !(A < B) // operator<=
    type definitions :
      typedef _T1 first_type;
      typedef _T2 second_type;

    shortcut :
      /**
       * make_pair - shortcut for make up a pair
       * @_T1:       first type
       * @_T2:       second type
       * @__x:       forward reference to first object
       * @__y:       forward reference to second object
       * return:     value of an object is type of pair<_T1, _T2>{__x, __y}
       * # make_pair() "decay"s and "strip"s _T1 and _T2 for produce types
       *   of @first and @second.for example "a" and "ab" as parameters will
       *   get type const char *,not the const char[2] and const char[3]
       * # because of forward reference,make_pair() can combine with std::move()
       *   when move semantics is applied,and can combine with std::ref() when
       *   reference semantics is applied
       */
      template<typename _T1, typename _T2>
      constexpr pair<_T1, _T2>
      make_pair(_T1 &&__x, __T2 &&__y);

      /**
       * __pair_get - shortcut for get element in a pair object,only specializations
       *              _Int := 0 and _Int := 1 been defined
       */
      template<std::size_t _Int>
      struct __pair_get;

      // get value in pair object,more overloaded versions
      template<std::size_t _Int, class _Tp1, class _Tp2>
      constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type &
      get(std::pair<_Tp1, _Tp2>& __in) noexcept;

    ! because std::tuple is the extend for std::pair,thus template methods std::tuple_size
      and std::tuple_element can be used on an object is type of std::pair.
    ! C++ language rule request an explicit call of a default constructor also initializes
      fundamental data types,for the pair,the constructors first() and second() will be
      called by pair().
    ! since C++ 11,a std::pair using a type that has only a nonconstant copy constructor
      will no longer compile.

    a special constructor of std::pair :
      /**
       * pair - a constructor for std::pair introduced for the situation that @first_type and/or
       *        @second_type is std::tuple
       * @_Args1:    template parameter pack for tuple1
       * @_Args2:    template parameter pack for tuple2
       * @piecewise_construct_t:    void structure used as an identifier
       * @tuple objects:    std::tuple for @first and/or @second
       * # if the type of data member is not tuple,then implicit type conversion will
       *   take place during construct the object
       */
      template<typename... _Args1, typename... _Args2>
      _GLIBCXX20_CONSTEXPR
      pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

Tuples :
    extend pairs to represent a heterogeneous list  of elements for which the types are specified
    or deduced at compile time.
    for tuple apply C++ 98 features,the implementation defined at least ten template parameters,that
    is the maximum number of elements.the newer C++ 11 supported template parameter pack,thus there
    can have more than ten elements in a tuple.

    <tuple>
      /* tuple - tuple is a container extended std::pair */
      /* tuple is in namespace std */
      template<typename... _Elements>
      class tuple : public _Tuple_impl<0, _Elements...>
      {
        ...
      };

    shortcut :
      /* make_tuple - template function used to makeup a tuple object and return it */
       * # because make_tuple() is a template function,thus automatically type deduce
       *   will process
       * # std::ref() and std::cref() combined with make_tuple() is possible to
       *   let tuple include an element whose type is a lvalue reference or a const lvalue
       *   reference.by using reference with make_tuple(),allow extract values of a tuple
       *   back to some other variable
       */
      template<typename... _Elements>
      constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
      make_tuple(_Elements&&... __args);

      /* tie - makeup a tupe with lvalue references and return it
       * # for const lvalue reference,the types pass to template should with const quantifier
       * # std::ignore can be used as a placeholder to tell tie() do not process reference
       *   binding on "this" element
       */
      template<typename... _Elements>
      constexpr tuple<_Elements&...>
      tie(_Elements&... __args) noexcept;


      /* __get_helper - this implementation applied a special programming technique to extract
       *                the specified __i-th element in a tuple object
       * # used template metaprogramming technique
       */
      template<std::size_t __i, typename _Head, typename... _Tail>
      constexpr _Head&
      __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
      { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

      /* get - get @__i-th element in a tuple,this routine returns std::__get_helper<__i>(__t) */
      template<std::size_t __i, typename... _Elements>
      constexpr __tuple_element_t<__i, tuple<_Elements...>>&
      get(tuple<_Elements...>& __t) noexcept;

      ! because get() returns a value is constexpr,that means it is compile-time constant,thus
        index __i can not be a variable is not constexpr.
        e.g.
          int i(0); // @i is not a constexpr value,that it is runtime variable
          auto t(make_tuple(1, 1.1, 'c');
          auto x = get<i>(t);
      ! pass an invalid index also throw a compile-time error.

    Allowed operations :
      assign  copy  move  swap  compare
                                |
                                +--> A.@all == B.@all
                                 |
                                 +-> A1 < B1 || (!(A1 < B1) && (A2 < B2 || .. // lexicographical comparison
                                 |
                                 +-> !(A < B)
    
    Tuple and Initializer lists :
      std::tuple<@types> t(@arguments);      //  OK,call to copy constructor
      std::tuple<@types> t1{@arguments};     //  OK,call to copy constructor
      std::tuple<@types> t2 = {@arguments};  //  ERROR,call to assignment operator
                                             //  for process assignment,the rvalue must been constructred
                                             //  t2 = std::tuple<@types>{@arguments}; => OK

      std::vector<std::tuple<int, float>> v{{1, 1.1}, {2, 1.2}};  // ERROR
      // but it is OK when @value_type is std::pair<int, float> or std::vector
      // it is OK when combine std::make_tuple() with initializer list
      //   std::vector<std::tuple<int, float>> v{std::make_tuple(1, 1.1), std::make_tuple(2, 2.2)};

      return {1, 2, 3}; in a function which returns a value is type of std::tuple<int, int, int>.
      // ERROR for std::tuple,but it is OK for std::vector

    Additional Tuple Features :
      /**
       * tuple_size - structure template in namespace std used to calculate the number of elements
       *              in std::tuple object
       * # operator sizeof...() is a compiler feature used to get number of types in template
       *   parameter pack
       * # integral_constant::value is the number of elements of "this" tuple object
       */
      template<typename... _Elements>
      struct tuple_size<tuple<_Elements...>>
      : public integral_constant<std::size_t, sizeof...(_Elements)> { };

      /**
       * tuple_element - structure template in namespace std used to get the type of a specified
       *                 element in std::tuple object
       * # recursive derive itself,used template metaprogramming technique
       * # type definition "typedef _Head type;" is introduced in the specialization that __i := 0,
       *   @type is the type of that @__i-th element 
       */
      template<std::size_t __i, typename _Head, typename... _Tail>
      struct tuple_element<__i, tuple<_Head, _Tail...>>
      : tuple_element<__i - 1, tuple<_Tail...>> { };

      /**
       * tuple_cat - function template in namespace std used to concatenates multiple tuples into
       *             one tuple
       * # this function template receive forward reference
       * # this function applied trailing return type function definition
       */
      template<typename... _Tpls,
               typename = typename enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
      constexpr auto
      tuple_cat(_Tpls&&... __tpls)
      -> typename __tuple_cat_result<_Tpls...>::__type
      {
        ...
      }
        
    I/O for Tuples :
      std::tuple does not provide operator<< overload for output values to standard output through
      std::cout(nor standard error std::cerr).

      if you want it,then you have to implement it.

      e.g.
        // use compile-time recursion to traverse every element
        // in the tuple object,and print them to standard output
        // *template metaprogramming*
        
        template<std::size_t IDX, std::size_t MAX, typename... _TupleTypes>
        struct PrintTuple {
          static void print(std::tuple<_TupleTypes...> &t)
          {
            std::cout << std::get<IDX>(t) << " ";
            PrintTuple<IDX + 1, MAX, _TupleTypes...>::print(t); // print next one
          }
        };

        // partial specialization to end the recursion
        template<std::size_t MAX, typename... _TupleTypes>
        struct PrintTuple<MAX, MAX, _TupleTypes...> {
          static void print(std::tuple<_TupleTypes...> &t)
          { }
        }

        // caller
        template<typename... _TupleTypes>
        void printTuple(std::tuple<_TupleTypes> &t)
        {
          PrintTuple<0, std::tuple_size(t), _TupleTypes...>::print(t);
        }

        std::tuple<@types> x(std::make_tuple<@type>{@arguments});
        printTuple(x);

    Conversions between tuples and pairs :
      for convert std::tuple to std::pair,should construct the std::pair by special
      constructor piecewise_construct_t as its first parameter.

      for convert std::pair to std::tuple,should instantiate a partial specialization
      2-element tuple template.that partial specialization includes construction and
      assignment from a std::pair.
      <tuple>
        template<typename _T1, typename _T2>
        class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
        {
          ...
        };

        // construction for a 2-elements tuple from a pair
        // function definition outside to class definition
        template<typename _T1, typename _T2>
        template<typename _U1, typename _U2, _ImpliciCtor<true, const _U1&, const _U2&> = true>
        constexpr
        tuple<_T1, _T2>::tuple(const pair<_U1, _U2> &__in)
        noexcept(__nothrow_constructible<const _U1 &, const _U2 &>())
        : _Inherited(__in.first, __in.second)
        { }

Smart Pointers :
    header - <memory>

    shared_ptr :
      pointer that can be shared by several owners,and memory is recycled when the reference
      count become _zero_.

      the destructor of shared_ptr call to "delete" as a default behavior,thus,if used it
      with array together,must define an array-specified destruction policy.
      for do this,should pass it a callable object that the callback function,it will be
      called in destructor.
      define a deleter :
        std::shared_ptr<int> pInt(new int[10], [](int *p) -> void { delete[] p; });

      a helper officially provided for std::unique_ptr for array-deleting also can be
      used with std::shared_ptr.
        std::default_delete<@type[]>()

      destruction policy :
        of couse,the deleter of std::shared_ptr can be an object of a user-defined class.
        in this case,operator() must be overloaded.
        the object will be called in destructor of std::shared_ptr through @obj(@type pointer)
        function calling.

        ! notice that,the destruction policy is not deallocate memory only.it could do everything
          that we want.but at the last,it must deallocate the memory.the overload operator()
          can pass the pointer to another function,hand over the deallocating to them.this is
          useful when handle system share resources such shared memory.

      ! can not create several std::shared_ptr objects refer to the same one object,this will bring
        a problem that the object is deallocated more than once.
        # copy an existed std::shared_ptr object is OK
        # keep only one group of shared pointers owns an object
      ! std smart pointer stuff class template std::enable_shared_from_this can pass the "this"
        pointer in a class method to the outside place.
        e.g.
          class A : public std::enable_shared_from_this<A>
          {
          public:
            void func(std::vector<A> &vec)
            {
              ...
              vec.push_back(shared_from_this()); // OK
              ...
            }
            ...
          };
          /* if no std::enable_shared_from_this,then send @this to another std::shared_ptr group is
           * an error
           * another way,is pass the pointer of class object as additional parameter for that method,
           * but that is not elegant.
           * !! CAN NOT shared_from_this() WHEN AN OBJECT IS CONSTRUCTING,OF COURSE DESTRUCTING.
           */

      ! deleter of std::shared_ptr would be called after methods reset(),operator=(&),operator=(&&)
        if this shared_ptr is the last owner of the original pointer.

      ! deleter that passed to constructor shall not throw.
    
      some member methods :
        shared_ptr(sp2, ptr)     /* alias constructor,creates a shared pointer "sharing" ownership
                                  * of @sp2 but referring to @ptr
                                  * useful when we want get a pointer points to a member of a
                                  * structure,this can prevent unexpected destorying to the
                                  * structure object when we using its member
                                  */
        swap(sp2)                /* exchange raw pointer */
        reset()                  /* reset raw pointer to nullptr */
        reset(new)               /* reset raw pointer to @new */
                                 !! after called reset() method, the std::weak_ptr
                                    created from the std::shared_ptr will be invalidated,
                                    operation on the std::weak_ptr will throw exception
                                    bad_weak_ptr,std::weak_ptr::expired() returns true
        operator*()              /* derefer */
        operator->()             /* member access on pointer */
        use_count()              /* how many instances are existing */
        unique()                 /* if use_count() == 1 ? */
        get()                    /* get the raw pointer */
        operator bool()          /* raw pointer == nullptr ? false : true */
        owner_before(sp2)        /* provide a strict weak ordering with another shared pointer */
        owner_before(wp)         /* provide a strict weak ordering with a weak pointer */

      logical operations :
        ==  !=  <  <=  >=  >
        /* logical operations are use the raw pointer as the real operand */

      some std stuffs :
        make_shared(...)
        allocate_shared(@allocator, ...)
        swap(sp1, sp2)
        static_pointer_cast      /* for convert a shared_ptr of @type1 to @type2,should use this
                                  * static casting,not the static_cast<@type2*>(sp)
                                  */
        dynamic_pointer_cast     
        const_pointer_cast
        get_deleter(sp)
        operator<<(sp)           /* output raw pointer got by @sp.get() */       

      some atomic interfaces :
        atomic_is_lock_free(&sp) /* whether atomic operations on @sp is lock-free */
        atomic_load(&sp)         /* return *@sp */
        atomic_store(&sp, sp2)   /* *@sp = sp2 */
        atomic_exchange(&sp, sp2) /* exchange *@sp and @sp2 */

    weak_ptr :
      std::weak_ptr is introduced for solve the following two problems they might happens when using
      std::shared_ptr :
        1> cyclic references
             A -> B
             B -> A
        2> explicitly share but not own an object
           semantics : the lifetime of a reference to an object outlives the object it refers to
           /* dangling pointer */

      std::weak_ptr,allows sharing but now owning an object.for use this class,require a shared
      pointer,whenever the last shared pointer owning the object lose its ownership,any std::weak_ptr
      automatically becomes empty.so,except default and copy constructors,std::weak_ptr provides
      only a constructor taking a std::shared_ptr object.

      ! dereference operator and member access operator are not supported by std::weak_ptr,for
        do these operations,must use the std::weak_ptr to create a std::shared_ptr at first.
        in this way we can :
          1> checks whether the pointer is NULL,if it is,then throw an exception or create
             empty std::shared_ptr object
          2> we are using the referred object,that the object referred by the std::shared_ptr
             will not be deallocated unexpectedly

      some member methods :
        weak_ptr(sp)                /* create std::weak_ptr from @sp */
        weak_ptr(wp2)               /* create std::weak_ptr from @wp2,sharing ownership of @wp2 */
        operator=(sp)               /* give up original ownership,and get new */
        operator=(wp2)              /* give up original ownership,and get new */
        swap(wp2)                   /* exchange */
        reset()                     /* give up current ownership,then this become empty */
        use_count()                 /* number of shared owners or 0 if this is empty */
        expired()                   /* whether this weak ptr is empty,that use_count() == 0 */
        lock()                      /* create a std::shared_ptr from this */
        owner_before(wp2)           /* provide a strict weak ordering with another weak pointer */
        owner_before(sp)            /* provide a strict weak ordering with a shared pointer */

      usage :
        std::shared_ptr<int> pInt(new int(10));

        std::weak_ptr<int> weakPInt(pInt);
        std::shared_ptr<int> weakPIntOP(weakPInt);

        *weakPIntOP = 20;

    unique_ptr :
      smart pointer that exclusive ownership,used for RAII to prevent resource leak.

      template<typename _Tp, typename _Dp = default_delete<_Tp>>
      class unique_ptr {
        template<typename _Up>
        using _DeleterConstraint = 
          typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

        __uniq_ptr_data<_Tp, _Dp> _M_t;
      public:
        using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
        using element_type = _Tp;
        using deleter_type = _Dp;
        ...
      }; /**
          * struct __uniq_ptr_impl<>
          * struct __uniq_ptr_data<> : public __uniq_ptr_impl<>
          *
          * struct default_delete<>
          * struct default_delete<>::operator()(@type *__ptr) const -> void
          * # just do static assert,and "delete" @__ptr
          * # a specification of default_delete is @type = _Tp[]
          */

      std::unique_ptr<> disallow to be initialized through assignment syntax.
        std::unique_ptr<int> pInt = new int(10);  /* ERROR */

      default constructor for std::unique_ptr<> will create an object with nullptr.
        std::unique_ptr<@type> up;  /* @up is nullptr */

      a runtime error should to be prevented :
        int *x = new int(10);
        std::unique_ptr<int> up1(x);  /* OK */
        std::unique_ptr<int> up2(x);  /* ERROR,@up1 and @up2 own same data */

      unique pointer can be used with array :
        std::unique_ptr<int[]> up(new int[4](0));
    
        /* do not need to define deleter suit to array destroying.
         * but std::unique_ptr<> also support to custom deleter.
         * pass it a customized deleter as the second template parameter
         * can let std::unique_ptr<> make use of new deleter.
         * the deleter must be callable!
         * # _Dp could be std::function<>,that means lambda function is legal
         */

      disallow :
        copy  assignment

      allow :
        move  swap  "assign nulltpr"
        
        /* allow "swap" means std::swap(up1, up2) is OK */
      special constructor :
        unique_ptr<...>(@ptr, @del) /* owns @ptr,use @del as deleter */
                                    /* @del is rvalue,then it must be MoveConstructible
                                     * @del is lvalue,then it must be CopyConstructible
                                     */
        special format make use of this constructor :
          std::unqiue_ptr<@type, @deleter&> up(@ptr @del);  /* @del is a lvalue type of @deleter */

          ! disallow pass deleter as the second parameter is rvalue but @_Dp is a lvalue reference.
              std::unique_ptr<@type, const @deleter&> up(@ptr, @del-expression-produce-rvalue);

      some member methods :
        reset()                /* reset to nullptr */
        reset(newp)            /* give up to original,get new ownership of @newp */
        release()              /* give up to original,and return the raw pointer */
        get()                  /* get raw pointer */
        get_deleter()          /* get return the lvalue reference to the deleter */
                               /* this method actually call to _M_t._M_deleter(),
                                * and that method is come from __uniq_ptr_impl.
                                */
        operator bool()        /* get() == pointer() ? false : true
                                * pointer() will create a nullptr
                                */
        operator*()
        operator->()
        operator[](@idx)

      logical operations :
        ==  !=  <  <=  >=  >

      resource destroyed if :
        lifetime of the std::unique_ptr object is end
        reset() method is called
        either operator=(nullptr) or operator=(&&) is called

Numeric Limits :
    template class numeric_limits<> is provided by C++,C++ make use of it to replace and
    supplement the ordinary preprocessor C constants which are available in headers
    <climits> and <limits.h>,floating-point types are available in headers <cfloat> and
    <float.h>.

    Advantages of numeric limits :
      1> offers more type safety
      2> enables a programmer to write templates that evaluate these limits
         /* so any error can be detected during compile-time */

    Minimum Size of Built-In Types :
      the minimum guaranteed precision of types.

      char 1B
      short int 2B
      int 2B
      long int 4B
      long long int 8B
      float 4B
      double 8B
      long double 8B

      /* these limits are platform-independent */

    Class numeric_limits<> :
      it is a common interface that is implemented for each type.

      <limits>
        struct __numeric_limits_base;
        
        template<typename _Tp>
        struct numeric_limits : public __numeric_limits_base
        {
          /* this bool variable is a static member in __numeric_limits_base,used to
           * indicates whether the specified type has a specialization exists
           */
          static _GLIBCXX_USE_CONSTEXPR bool __numeric_limits_base::is_specialized;

          /* methods used to return minimum value and maximum value of @_Tp */
          static _GLIBCXX_CONSTEXPR _Tp
          min() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

          static _GLIBCXX_CONSTEXPR _Tp
          max() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }

          /* each specialization re-defined these two methods by return
           * __glibcxx_min(@type),and __glibcxx_max(@type)
           */
          ...
        };

        /* partial specializations const @_Tp and volatile @_TP,const volatile @_Tp are void */
        /* for each built-in type,header <limits> specialized one template for it. */

        /* rounding style for floating-point types */
        enum float_round_style {
          round_indeterminate = -1,
          round_toward_zero = 0,
          round_to_nearest = 1,
          round_toward_infinity = 2,
          round_toward_neg_infinity = 3
        };

        /* de-normalization for floating-point types */
        enum float_denorm_style {
          denorm_indeterminate = -1,
          denorm_absent = 0,
          denorm_present = 1
        };

      some useful data members :
        is_specialized    /* if specialization exist */
        is_signed         /* signed */
        is_integer        /* integer */
        is_exact          /* calculations produce no rounding erros */
        digits            /* character/integer - number of bits,excluding sign */
        radix             /* integer - base of the representation(almost always 2)
                           * floating point - base of the exponent representation
                           */
        has_denorm        /* whether type allows denormalized values */
        has_denorm_loss   /* loss of accuracy is detected as a denormalization loss rather
                           * than as an inexact result
                           */

      some useful methods :
        lowest()          /* maximum negative finite value(meaningful if @is_bounded */
        epsilon()         /* difference of 1 and least value greater than 1,C constant FLT_EPSLION, ... */
        round_style()     /* rounding style */
        round_error()     /* measure of the maximum rounding error(ISO/IEC 10967-1)
        infinity()        /* positive infinity,if available */
        quiet_NaN()       /* quiet "Not a Number",if available */
        signaling_NaN()   /* signaling "Not a Number",if available */
        denorm_min()      /* minimum positive denormalized value */

Type Traits and Type Utilities :
    Purpose of Type Traits :
      a type trait provides a way to deal with the _peroperties_ of a type.
      it is a template,which at compile time yields a specific type or value based
      on one or more passed template arguments,which are usually types.
      type traits are building blocks for generic code.

    std::is_pointer<> :
      <type_traits>
        /**
         * integral_constant<> has a static member,its type will be the
         * first template parameter,and its value will be the second
         * template parameter,and its name is @value
         * of course,it has a type-definition "typedef integral_constant<_Tp, __v> type",
         * thus ::type can be used for class deriving
         * operator () been overloaded in the structure,it returns @value.
         */

        typedef integral_constant<bool, false> false_type;
        typedef integral_constant<bool, true> true_type;

        // no(match everything) template parameter specialization
        // this means,except pointer type,any others are
        // get false
        template<typename>
        struct __is_pointer_helper : public false_type
        { };

        ! of course,similar to function,we can accept function parameter,
          but do not name it,that means we do not want to make use of it,
          just as an indicator

        // pointer type template parameter specialization
        template<typename _Tp>
        struct __is_pointer_helper<_Tp *> : public true_type
        { };

        template<typename _Tp>
        struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
        { };

      e.g.
        // it's OK,because @value is static linkage and declared with
        // constexpr
        // compiler will optimizes this if-else statement depends on the @type
        if (std::is_pointer<@type>::value) {
          ...
        } else {
          ...
        }

      !! can not use std::is_pointer<> in expression "@cond ? @v1 : @v2" .
      !! std::is_pointer<> can be used as an argument of a function's parameter,
         which type either is std::true_type or std::false_type,can be used as an
         calling indicator.
         e.g.
           template<typename T>
           void func(@params, std::false_type) { ... }

           template<typename T>
           void func(@params, std::true_type) { ... }

           template<typename T>
           void call_to_func_is_int(@params)
           {
             func(@params, std::is_integral<T>());
           }

    Processing the Common Type :
      type traits can be used to solve the problem process the "common type" of two or more types.
      because,the function can only returns the value with one type,if we want it to return the
      value with a common type from its parameters,then we can make use of type traits to determine
      which type should be returned.
      by make use of template metaprogramming technique,we can determine the real return type of
      such function through find common type of the types of its parameters during compile-time.

      ! if these types have no common type,then attempt to find a common type is an error.

      std::common_type<> : (header <type_traits>)
        // no detail,because we use this
        // as the Prototype for specializations
        template<typename... _Tp>
        struct common_type;

        // Partial-Specialization
        // sizeof...(T) == 0
        template<>
        struct common_type<>
        { };

        // Partial-Specialization
        // sizeof...(T) == 1 => common type is T
        template<typename _Tp0>
        struct common_type<_Tp0> : public common_type<_Tp0, _Tp0>
        { };

        // Partial-Specialization
        // sizeof...(T) == 2
        template<typename _Tp1, typename _Tp2>
        struct common_type<_Tp1, _Tp2> : public __common_type_impl<_Tp1, _Tp2>::type
        { };

        // Partial-Specialization
        // sizeof...(T) > 2
        // recursive checks
        // common_type<common_type<_Tp1, _Tp2>::type, _Rp...> ... 
        template<typename _Tp1, typename _Tp2, typename... _Rp>
        struct common_type<_Tp1, _Tp2, _Rp...>
        : public __common_type_fold<common_type<_Tp1, _Tp2>, __common_type_pack<_Rp...>>
        { };

        // Prototype
        // impl of common type when sizeof...(T) == 2
        template<typename _Tp1, typename _Tp2,
                 typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
        struct __common_type_impl
        {
          using type = common_type<_Dp1, _Dp2>;
        };

        // Partial-Specialization
        // impl of common type when sizeof...(T) == 2
        // and _Dp1 == _Tp1, and _Dp2 == _Tp2
        // evaluate common type of _Tp1 and _Tp2
        template<typename _Tp1, typename _Tp2>
        struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
        : private __do_common_type_impl
        {
          using type = decltype(_S_test<Tp1, _Tp2>(0));
        }

        /**
         * structure __do_common_type_impl defined an alias
         *   template<typename _Tp, typename _Up>
         *   using __cond_t = decltype(true? std::declval<_Tp>() : std::declval<_Up>());
         *   # "@cond ? @v1 : @v2" expression produce a value @v1 or @v2,and the value
         *     can be used by decltype keyword to produce the exact type
         *   # keyword declval
         *       introduced since C++ 11
         *       produce a rvalue reference to the type T,but do not evaluate it
         *                                                           (no real object makeup)
         * and defined template methods _S_test<>(),_S_test_2<>() and their overloaded 
         * versions for find common type of the given types
         */

    Unary Type Predicates : (result in std::true_type or std::false_type)
      is_void<T>
      is_integral<T>
      is_floating_point<T>
      is_arithmetic<T>
      is_signed<T>
      is_unsigned<T>
      is_const<T>
      is_volatile<T>
      is_array<T>
      is_enum<T>
      is_union<T>
      is_class<T>
      is_function<T>
      is_reference<T>
      is_lvalue_reference<T>
      is_rvalue_reference<T>
      is_pointer<T>
      is_member_point<T>
      is_member_object_pointer<T>
      is_member_function_pointer<T>
      is_fundamental<T>                void,integral,floating-point,std::nullptr_t
      is_scalar<T>                     integral,floating-point,enumeration,pointer,member point,std::nullptr_t
      is_object<T>                     any type except void,function,reference
      is_compound<T>                   array,enumeration,union,class,function,reference,pointer
      is_trivial<T>
      is_trivially_copyable<T>
      is_standard_layout<T>
      is_pod<T>
      is_literal_type<T>

      is_empty<T>
      is_polymorphic<T>
      is_abstract<T>
      has_virtual_destructor<T>

      is_default_constructible<T>
      is_copy_constructible<T>
      is_move_constructible<T>
      is_copy_assignable<T>
      is_move_assignable<T>
      is_destructible<T>

      is_trivially_default_constructible<T>
      is_trivially_copy_constructible<T>
      is_trivially_move_constructible<T>
      is_trivially_copy_assignable<T>
      is_trivially_move_assignable<T>
      is_trivially_destructible<T>

      is_nothrow_default_constructible<T>
      is_nothrow_copy_constructible<T>
      is_nothrow_move_constructible<T>
      is_nothrow_copy_assignable<T>
      is_nothrow_move_assignable<T>
      is_nothrow_destructible<T>

    Traits for Relations : (result in std::true_type or std::false_type)
      is_same<T1, T2>
      is_base_of<T, D>
      is_convertible<T, T2>
      is_constructible<T, Args...>
      is_trivially_constructible<T, Args...>
      is_nothrow_constructible<T, Args...>
      
      is_assignable<T, T2>
      is_trivially_assignable<T, T2>
      is_nothrow_assignable<T, T2>
      uses_allocator<T, Alloc>

    Traits for Type Modifications : (produce a type)
      remove_const<T>
      remove_volatile<T>
      remove_cv<T>
      add_const<T>
      add_volatile<T>
      add_cv<T>
      make_signed<T>
      make_unsigned<T>
      remove_reference<T>
      add_lvalue_reference<T>
      add_rvalue_reference<T>
      remove_pointer<T>
      add_pointer<T>

    Other Type Traits :
      rank<T>                                number of dimensions of an array type(or 0)
      extent<T, I = 0>                       extent of dimension I(or 0)
      remove_extent<T>
      remove_all_extents<T>
      uderlying_type<T>                      underlying type of an enumeration type
      decay<T>                               transfers to corresponding "by-value" type
                                             T &, T &&, T * => T
      enable_if<B, T = void>                 yields T only if B is TRUE
      conditional<B, T, F>                   B ? T : F
      common_type<T1, ...>
      result_of<F, ArgTypes>                 type of calling F with argument types ArgTypes
      alignment_of<T>                        alignof(T)
      aligned_storage<Len>
      aligned_storage<Len, Align>
      aligned_union<Len, Types...>

Reference Wrappers :
    class std::reference_wrapper<> decalred in header <functional>,which is used primarily to "feed"
    references to function templates that take their parameter by value.
    std::reference_wrapper<> can also be used in some STL containers such std::vector<>,std::pari<>,
    std::tuple<> and std::array<>,etc.for specify that type of element is the reference to type T.
    /* just use template argument @type& will failed on compile */

    <bits/refwrap.h> /* implementation file */
      // base of ref wrapper
      template<typename _Tp>
      struct _Reference_wrapper_base
      : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>
      { };

      // memfun ref wrapper base
      template<typename _Tp, bool = is_member_function_pointer<_Tp>::value>
      struct _Reference_wrapper_base_memfun
      : _Reference_wrapper_base<_Tp>
      { };

      // memfun ref wrapper base partial specialization
      template<typename _MemFunPtr>
      struct _Reference_wrapper_base_memfun<_MemFunPtr, true>
      : _Mem_fn_traits<_MemFunPtr>::__maybe_type
      {
        using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
      }

      // primary reference_wrapper
      template<typename _Tp>
      class reference_wrapper
      : public _Reference_wrapper_base_memfun<typename remove_cv<_Tp>::type>
      {
        _Tp *_M_data; // private data member
                      // used to store the real object of type @_Tp
        
        _GLIBCXX20_CONSTEXPR
        static _Tp *_S_fun(_Tp &__r) noexcept
        { return std::__addressof(__r); }

        static void _S_fun(_Tp&&) = delete;

        // used to checks whether the type parameter of constructor is same to @_Tp
        // default T of std::enable_if<> is void,if @_Tp is not same as @_Up,then
        // is_same<> get false_type,and __not_same get type void
        template<typename _Up, typename _Up2 = __remove_cvref_t<_Up>>
        using __not_same = typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;

      public:
        typedef _Tp type;

        // constructor
        // @__uref:    forward reference parameter to the argument.when makeup reference_wrapper,
        //             a lvalue / rvalue to the argument is pass to constructor,and @_M_data then
        //             points to the object(address get through _S_fun())
        template<typename _Up, typename = __not_same<_Up>,
                 typename = decltype(reference_wrapper::_S_fun(std::declval<_Up>()))>
        _GLIBCXX20_CONSTEXPR
        reference_wrapper(_Up &&__uref)
        noexcept(noexcept(reference_wrapper::_S_fun(std::declval<_Up>())))
        : _M_data(reference_wrapper::_S_fun(std::forward<_Up>(__uref)))
        { }

        ...
        _GLIBCXX20_CONSTEXPR
        _Tp& get() const noexcept
        {
          return *_M_data;
        }
        _GLIBCXX20_CONSTEXPR operator _Tp&() const noexcept
        {
          return this->get();
        }
        ...

        #if __cpp_deducation_guides
        template<typename _Tp>
        reference_wrapper(_Tp &) -> reference_wrapper<_Tp>;
        #endif

        // produce a lvalue reference
        template<typename _Tp>
        _GLIBCXX20_CONSTEXPR
        inline reference_wrapper<_Tp>
        ref(reference_wrapper<_Tp> __t) noexcept
        {
          return __t;
        }

        // produce a const lvalue reference
        template<typename _Tp>
        _GLIBCXX20_CONSTEXPR
        inline reference_wrapper<const _Tp>
        cref(reference_wrapper<_Tp> __t) noexcept
        {
          return { __t.get() };
        }
      };

    so we can easy to know that,std::reference_wrapper<> is converted to @_Tp& when
    where the @_Tp& is required.it use a pointer points to the original object,and
    convert *@_M_data to @_Tp&.
    such STL container std::vector<std::reference_wrapper<int>>,element type will be
    std::reference_wrapper<int>.when construct an element,a int object should be
    passed to the constructor of std::reference_wrapper<int> as forward reference
    parameter,then @_M_data points to the int object.when we need a reference to int,
    operator int&() will be invoked,which return *@_M_data.

    std::ref() and std::cref() is call to the member functions ref() and cref() of
    std::reference_wrapper<>,respectively.an object is type of std::reference_wrapper<@_Tp>
    or of std::reference_wrapper<const @_Tp> as the result returns to caller.
    the type @_Tp of the std::reference_wrapper<> object returned by cref() will becomes const @_Tp,
    thus operator _Tp&() => operator const @type&() .

Auxiliary Functions :
  Minimum and Maximum :
    header <algorithm>
    namespace std
      min(a, b)                      a < b ? a : b
      min(a, b, cmp)                 minimum between @a and @b,comparing with @cmp
      min(init-list)                 minimum between @init-list,comparing with "<"
      min(init-list, cmp)            minimum between @init-list,comparing with @cmp
      max(a, b)                      a > b ? a : b
      max(a, b, cmp)                 maximum between @a and @b,comparing with @cmp
      max(init-list)                 maximum between @init-list,comparing with ">"
      max(init-list, cmp)            maximum between @init-list,comparing with @cmp
      minmax(a, b)                   minimum and maximum of @a and @b,comparing with "<"
        /* std::pair<int, int> minmax(std::minmax(3, 7)); */
      minmax(a, b, cmp)              minimum and maximum of @a and @b,comparing with @cmp
      minmax(init-list)              minimum and maximum of @init-list,comparing with "<"
      minmax(init-list, cmp)         minimum and maximum of @init-list,comparing with @cmp

  Swap :
    header <utility>
    namespace std
      swap(a, b)                     exchange contents of @a and @b
                                     ! if either operand is a class type,then member method
                                       swap() must be defined,and which receive an operand
                                       is type of another parameter of swap(@a, @b)
                                       if both operands are class type,then each other must
                                       defined swap() member method with another type

  Comparison :
    header <utility>
    namespace std::rel_ops
      operator!= <> (a, b)             !(@a == @b)
      operator> <>  (a, b)             @b < @a
      operator<= <> (a, b)             !(@b < @a)
      operator>= <> (a, b)             !(@a < @b)

    the purpose is to reduce the number of operator overloading definitions of a class type.
    by use of these four template function,a class can only defines operator== and operator<
    as well.

    e.g.
      class c {
      public:
        bool operator<(const c &p1, const c &p2) const
        { return p1.__data < p2.__data; }

        bool operator==(const c &p1, const c &p2) const
        { return p1.__data == p2.__data; }

        ...
      private:
        int __data;
        ...
      };

      using namespace std::rel_ops;

      c c1(8), c2(16);

      /* from clas definition */
      c1 < c2;
      c1 == c2;

      /* implemented by rel_ops */
      c1 > c2;
      c1 != c2;
      c1 >= c2;
      c1 <= c2;

  Compile-Time Fractional Arithmetic :
    header <ratio>
    namespace std
      template<intmax_t _Num, intmax_t _Den = 1>
        struct ratio {
          static_assert(_Den != 0, "denominator cannot be zero");
          static_assert(_Num >= -__INTMAX_MAX__ && _Den >= -__INTMAX_MAX__,
                        "out of range");

          /**
           * header <ratio>
           * template<intmax_t _Pn>
           * __static_sign : integral_constant<intmax_t, (_Pn < 0) ? -1 : 1>
           * { };
           *
           * template<intmax_t _Pn>
           * __static_abs : integral_constant<intmax_t, __Pn * __static_sign<_Pn>::value>
           * { };
           *
           * template<intmax_t _Pn, intmax_t _Qn>
           * struct __static_gcd : __static_gcd<_Qn, (_Pn % _Qn)>
           * # stopped when either @_Pn or @_Qn becomes _zero_
           * # @_Pn == 0 => derive integral_constant<intmax_t, __static_abs<_Qn>::value>
           * # @_Qn == 0 => derive integral_constant<intmax_t, __static_abs<_Pn>::value>
           */
          static constexpr intmax_t num =
            _Num * __static_sign<_Den>::value / __static_gcd<_Num, _Den>::value;

          static constexpr intmax_t den =
            __static_abs<_Den>::value / __static_gcd<_Num, _Den>::value;

          typedef ratio<num, den> type;
        };

        usage :
          typedef std::ratio<64, 8> sfe; /* 64/8 */
          auto num(sfe::num); /* @num == 8 */
          auto den(sfe::den); /* @den == 1 */

        ratio_add<@ratio1, @ratio2>                => using ratio_add = typename __ratio_add<@ratio1, @ratio2>::type
                                                      returns ratio<>
        ratio_subtract<@ratio1, @ratio2>           => using raiot_subtract = typename __ratio_subtract<@ratio1, @ratio2>::type
                                                      returns ratio<>
        ratio_multiply<@ratio1, @ratio2>           => using ratio_multiply = typename __ratio_multiply<@ratio1, @ratio2>::type
                                                      returns ratio<>
        ratio_divide<@ratio1, @ratio2>             => using ratio_divide = typename __ratio_divide<@ratio1, @ratio2>::type
                                                      returns ratio<>

        ratio_equal<@ratio1, @ratio2>              @ratio1 == @ratio2 <-> @num1 == @num2 AND @den1 == @den2
        ratio_not_equal<@ratio1, @ratio2>          @ratio1 != @ratio2 => !(@ratio1 == @ratio2)
        ratio_less<@ratio1, @ratio2>               @ratio1 < @ratio2
        ratio_less_equal<@ratio1, @ratio2>         @ratio1 <= @ratio2 => @ratio1 < @ratio2 AND @ratio1 == @ratio2
        ratio_greater<@ratio1, @ratio2>            @ratio1 > @ratio2 =>  !(@ratio1 < @ratio2) AND !(@ratio1 == @ratio2)
        ratio_greater_equal<@ratio1, @ratio2>      @ratio1 >= @ratio2 => !(@ratio1 < @ratio2)
                                                   /* comparison returns std::false_type or std::true_type */

Clocks and Timers :
    Chrono Libraray :
      header <chrono>
      namespace std::chrono

      design purpose - timers and clocks might be different on different systems and improve over
                       time in precision,reduce the number of interfaces that needed for switch
                       time precision.
                       provide precision-neutral concept by separating duration and point of time
                       from specific clocks.

      time duration - a time duration is defined as a specific number of ticks over a time unit.
      time point    - a time point is defined as combination of a duration and a beginning of time(epoch)
      
      ! the concept of a timepoint is parametrized by a clock,which is the object that defines the epoch of
        a timepoint.different clocks have different epochs.

          +--> timepoint          +--> timepoint          +--> timepoint
          |                       |                       |
      [ - - - - - - - - - - - - - - - - - - - - - - - - - - ]
                        |                   |
                        +----> duration <---+
                        |
                        +--> epoch of a clock 

    Durations :
      a duration is a combination of a _value_ representing the number of ticks and a _fraction_
      representing the unit in seconds.ratio<> is used to specify the fraction.

      <chrono>
        /**
         * duration - struct template used to represent time duration
         * @_Rep:     type of tick
         * @_Period:  period of ticks
         *            # ratio<60> => 60/1 seconds -> 1 tick is 60/1 seconds(1minute)
         *              ratio<1> => 1/1 second   -> 1 tick is 1 second
         *              ratio<1, 1000> => 1/1000 seconds -> 1 tick is 1/1000 second == 1ms
         * # @_Rep is floating-point type allows we pass arguments such 0.3, 0.5, and so on
         *   values to duration's construction.
         */
        template<typename _Rep, typename _Period = ratio<1>>
        struct duration;

        type-definition :
          using rep = _Rep;
          using period = typename _Period::type;

        private-data :
          rep __r;

        constructor :
          constexpr duration() = default;

          template<typename _Rep2, typename = _Require<is_convertible<const _Rep2&, rep>,
                                                       __or_<is_float<rep>,
                                                       __not_<__is_float<_Rep2>>>>>
          constexpr explict duration(const _Rep2 &__rep)
          : __r(static_cast<rep>(__rep)) { }

        copy-constructor :
          duration(const duration &) = default;

          template<typename _Rep2, typename _Period2,
                   typename = _Require<is_convertible<const _Rep2 &, rep>,
                                       __or_<__is_float<rep>,
                                             __and_<is_harmonic<_Period2>,
                                                    __not_<__is_float<_Rep2>>>>>
          constexpr duration(const duration<_Rep2, _Period2> &__d)
          : __r(duration_cast<duration>(__d).count()) { }
                // cast type of @__d to type of this duration object

        some useful methods :
          count()           =>        return @__r

          /* these three methods are wrappers of the same name methods from
           * struct template duration_values<_Rep>
           */
          zero()            =>        return rep(0)
                                      duration of zero length
          min()             =>        return numeric_limits<rep>::lowest()
                                      minimum possible duration of this type

          max()             =>        return numeric_limits<rep>::max()
                                      maximum possible duration of this type

          operator=(d)      =>        *this = @d
          operator+         =>        +this_duration
          opeartor-         =>        -this_duration

          operator++()      
          operator++(int)   
          operator--()
          operator--(int)
          operator+=(d)     =>        @__r += @d.count()
          operator-=(d)     =>        @__r -= @d.count()
          operator*=(r)     =>        @__r *= @r
          operator/=(r)     =>        @__r /= @r

          template <typename _Rep2 = rep>
          operator%=(d || r)
                            =>        @__r %= @d.count() || @__r %= @r

          /* there are two non-member methods used to implement "add" and "subtract" */
          operator+(d1, d2) =>        let ctd as common_type<d1_type, d2_type>
                                      return ctd(ctd(@d1).count() + ctd(@d2).count())

          operator-(d1, d2) =>        let ctd as common_type<d1_type, d2_type>
                                      return ctd(ctd(@d1).count() - ctd(@d2).count())

          !! when assign a duration to another duration,the tick types of them one
             are different,such one is integral,another is floating-point,must explicit
             convert tick type before assignment.
             e.g.
               std::chrono::seconds halfmin;
               std::chrono::duration<double, std::ratio<60>> thirtyseconds(0.5);
               halfmin = thirtyseconds; // ERROR
               halfmin = std::chrono::duration_cast<std::chrono::seconds>(thirtyseconds); // OK

             # this rule should also be followed when period is different,such 1/1 and 60/1,
               1/1 => 1 tick is 1s,60/1 => 1 tick is 60s(1 minute).
               e.g.
                 std::chrono::seconds s(55);
                 std::chrono::minutes m;
                 m = s; // ERROR
                 m = std::chrono::duration_cast<std::chrono::minutes>(s); // OK

             # std::chrono::duration_cast<> is used to cast duration type

        pre-defined special duration :
          using nanoseconds = duration<_GLIBCXX_CHRONO_INT64_T, nano>;
          using microseconds = duration<_GLIBCXX_CHRONO_INT64_T, micro>;
          using milliseconds = duration<_GLIBCXX_CHRONO_INT64_T, milli>;
          using seconds = duration<_GLIBCXX_CHRONO_INT64_T>;
          using minutes = duration<_GLIBCXX_CHRONO_INT64_T, ratio<60>>;
          using hours = duration<_GLIBCXX_CHRONO_INT64_T, ratio<3600>>;
          using days = duration<_GLIBCXX_CHRONO_INT64_T, ratio<86400>>;
          using weeks = duration<_GLIBCXX_CHRONO_INT64_T, ratio<604800>>;
          using months = duration<_GLIBCXX_CHRONO_INT64_T, ratio<2629746>>;
          using years = duration<_GLIBCXX_CHRONO_INT64_T, ratio<31556952>>;

    Clocks and Timepoints :
      relationship between clock and timepoint -
        a clock defines an epoch and a tick period,and a clock provides a type for any timepoint
        specified according to this clock.
        a timepoint represents a specific point in time by associating a positive or negative
        duration to a given clock.

      type definition and static member for each clock -
        clock::duration        duration type of this clock
        clock::rep             tick type of this clock
        clock::period          unit type of this clock  /* duration::period */
        clock::time_point      timepoint of this clock
        clock::is_steady       is it steady?
        clock::now()           yield a time_point for the current point in time

      C++ standard library clocks :
        std::system_clock - <chronon> as a structure
          represents timepoints associated with the usual real-time clock of the current system
          /**
           * provides static member methods for map to C api
           *   static std::time_t to_time_t(const time_point &__t) noexcept;
           *   # implementation make use of duration_cast<> and force type convert std::time_t()
           *   static time_point from_time_t(std::time_t __t) noexcept;
           *   # implementation make use of time_point_cast<>
           */

        std::steady_clock - <chronon> as a structure
          steady clock,never gets adjusted,thus timepoint values never decrease as the physical
          time advances,and they advance at a steady rate relative to real time
          /* monotonic clock */
        
        std::high_resolution_clock - <chronon> as a structure
          represents a clock with the shortest tick period possible on the current system
          /* using high_resolution_clock = system_clock; */

        ! standard does not provide requirements for the precision,the epoch,the range of the
          clocks.
        ! the durations of system_clock and steady_clock are the same chrono::nanoseconds.
        ! if a program have to compare or compute the difference of two times,should make use of
          steady_clock than system_clock,because steady_clock never adjusted.
      
      the time_point object :
        <chrono>
          namespace - std::chrono

          template<typename _Clock, typename _Dur>
          struct time_point {
            typedef _Clock clock;
            typedef _Dur duration;
            typedef typename duration::rep rep;
            typedef typename duration::period period;

            // default constructor
            constexpr time_point() : __d(duration::zero())
            { }

            // constructor
            constexpr explicit time_point(const duration &__dur)
            : __d(__dur)
            { }

            // copy-constructor
            template<typename _Dur2, typename = _Require<is_convertible<_Dur2, _Dur>>>
            constexpr time_point(const time_point<clock, _Dur2>& __t)
            : __d(__t.time_since_epoch())
            { }

            // observer
            constexpr duration
            time_since_epoch() const
            { return __d; }

            ...
        
          private:
            duration __d;
          };

          some useful operations :
            min()                    -    time_point(duration::min())
            max()                    -    time_point(duration::max())
            operator+=(__dur)        -    @__d += @__dur   
            operator-=(__dur)        -    @__d -= @__dur

            // the following methods are make use of time_since_epoch() method
            operator+(tp, dur)       -    @tp.time_since_epoch() + @dur
            operator+(dur, tp)       -    @dur + @tp.time_since_epoch()
            operator-(tp, dur)       -    @tp.time_since_epoch() - @dur
            operator-(tp1, tp2)      -    @tp1.time_since_epoch() - @tp2.time_since_epoch()
            operator==(tp1, tp2)     -    @tp1 == @tp2
            operator!=(tp1, tp2)     -    !(@tp1 == @tp2)
            operator<(tp1, tp2)      -    @tp1 < @tp2
            operator<=(tp1, tp2)     -    @tp1 <= @tp2
            operator>(tp1, tp2)      -    @tp1 > @tp2
            operator>=(tp1, tp2)     -    @tp1 >= @tp2

          time_point_cast :
            /**
             * time_point_cast<> - cast time_point
             * @_ToDur:            duration of the time_point that convert to
             * @_Dur:              duration of the time_point that is original
             * @_Clock:            clock of the time_point(s)
             * @__t:               original time_point object
             * return:             a new time_point<_Clock, _ToDur> object
             * # function make use of methods duration_cast<> and __t.time_since_epoch()
             */
            template<typename _ToDur, typename _Clock, typename _Dur>
            constexpr typename enable_if<__is_duration<_ToDur>::value,
                                         time_point<_Clock, _ToDur>>::type
            time_point_cast(const time_point<_Clock, _Dur>& __t);

      ! timepoint can not less than its epoch or greater than its maximum duration.
      ! C++ does not defined time stamp string casting routines in addition,because
        C library provided routine ctime() to handle this work.
        but only the timepoint of system_clock is able to be converted to time_t type.
      ! time_point always associated with a clock,only a timepoint without clock is no sense.
      ! C library routine gmtime() can get UTC time stamp from time_t type,the result is
        stored in structure tm.

The Standard Template Library :
    STL Components :
      containers - used to manage collections of objects of a certain kind.
      iterators  - used to step through the elements of collections of objects.
                   major advantage :
                     offer a small but common interface for any arbitraty container type.
      algorithms - used to process the elements of collections.
                   and programmer is able to supply certain auxiliary functions called by
                   the algorithms to suit needs even if that needs is very special or complex.

      the concept of the STL is based on a separation of data and operations. /* generic */
                                                                              /* object-oriented */
      the data is managed by container classes,and the operations are defined by configurable
      algorithms.iterators are the glue between these two components,they let any algorithm
      interact with any container.
      /* thanks to template,we can delay type determining to compile-time,compiler will produce
       * the appropriate code for us.
       */

      all components are templates for any type,provided that type is able to perform the required
      operations.
      containers and algorithms are generic for arbitrary types and classes,respectively.
