C++17

Removed Features :
  std::auto_ptr
  deprecated function objects
  std::random_shuffle
  std::unexpected
  the obsolete iostreams aliases
  trigraphs
  the register keyword
  bool increment
  dynamic exception specification  //  throw(type-id-list) follows a function declaration

Deprecated :
  std::iterator
  std::raw_storage_iterator
  std::get_temporary_buffer
  std::is_literal_type
  std::result_of
  all of <codecvt>


> u8 character literal
    u8 character literal is literal data
    Syntax :
      u8'c-char'

      c-char : either
      	         > basic-c-char
		 > an escape sequence
		 > a universal character name

    UTF-8 character literal,such literal has type char(until c++20) or char8_t(since c++20) and the value equal to
    ISO/IEC 10646 code point value of c-char,provided that the code point values is representable with a single UTF-8
    code unit(range 0 - 255)

    //  if c-char is not representable with a signle UTF-8 code unit,the  character literal is ill-formed.

    e.g.
      char c = u8'\xff';
      char b = u8'\027';
      char d = u8'd';

      char_t u8c = u8'c';  //  char_t since c++20


> made noexcept part of type system
    this is means the noexcept specifier would as a part of function type.
    function has type same as its return type before this feature came.
    but functions differing only in their exception specification cant be overloaded.
    (just like the return type,exception specification is part of function type,but not part of the
    function signature)

    e.g.
	void f(int a) noexcept;
	void f(int a);
			//  the second f() cant be overloaded version of the first,
			//  because the different between them only in their exception specification.
			//  the second is no exception,the first is potentially exception.

	g() noexcept(false);
	g();
			//  both declarations for g are potentially throwing,but there have not overload.

	void f(void) noexcept;
	void (*pf)(void) = f;  //  error
	     		       //  f is noexcept,but pf requires a function which is potentially throwing.

	void (*pf2)(void noexcept = f;  //  OK 


> new order of evaluation
    every expression has a well-defined evaluation order !

    postfix expressions are evaluated from left to right.this includes functions calls and member selection
    expressions.
    assignment expressions are evaluated from right to left.this includes compound assignments.
    operands to shift operators are evaluated from left to right.

    Summary :
      the following expressions are evaluated in the order a,then b,then c,then d >
        a.b
	a->b
	a->*b
	a(b1,b2,b3)
	b @= a  //  '@' means any operator which can be combined with '='
	a[b]
	a << b
	a >> b

      #  additional rule :
      	   the order of evaluation of an expression involving an overloaded operator is determined by the
	   order associated with the corresponding built-in operator,not the rules for function calls.

         function calls :
	   the function is evaluated before all its arguments,but any pair of arguments(from the argument list) 
	   is indeterminately sequenced;meaning that one is evaluated before the other but the order is not
	   specified;it is guaranteed that the function is evaluated before the arguments.

    //  new order of evaluation is to solve a problem occurs in chaining expressions like :
    	  std::cout<<f()<<t()<<c();  //  a chaining member functions calls.


> lambda capture of *this
    the current object *this can be implicitly captured if either capture default is present,if implicitly
    captured,it is always captured by reference,even if the capture default is '='.
    (c++20,the implicit capture of *this when the capture default is '=' is deprecated)

    captures :
      [this]	simple by-reference capture of the current object
      [*this]	simple by-copy capture of the current object

    attention :
      lambda expression is a closure class object,that means it has this pointer point to the object,so
      have to prevent the following usage :
        void class A::func(void)
	{
	  auto l_func = [this](void) -> void 
	    {
	      return this;  //  this != A::this
	    };
	  //  the this pointer captured by l_func is not A::this,it is the pointer point to 
	  //  closure class object.  
	  /*
	   *  auto pA(this);
	   *  auto l_func[&pA](void) -> void { return pA; };
	   *  //  pA == A::this
	  */
	}
