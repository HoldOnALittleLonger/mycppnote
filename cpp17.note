C++17

Removed Features :
  std::auto_ptr
  deprecated function objects
  std::random_shuffle
  std::unexpected
  the obsolete iostreams aliases
  trigraphs
  the register keyword
  bool increment
  dynamic exception specification  //  throw(type-id-list) follows a function declaration

Deprecated :
  std::iterator
  std::raw_storage_iterator
  std::get_temporary_buffer
  std::is_literal_type
  std::result_of
  all of <codecvt>


> u8 character literal
    u8 character literal is literal data
    Syntax :
      u8'c-char'

      c-char : either
      	         > basic-c-char
		 > an escape sequence
		 > a universal character name

    UTF-8 character literal,such literal has type char(until c++20) or char8_t(since c++20) and the value equal to
    ISO/IEC 10646 code point value of c-char,provided that the code point values is representable with a single UTF-8
    code unit(range 0 - 255)

    //  if c-char is not representable with a signle UTF-8 code unit,the  character literal is ill-formed.

    e.g.
      char c = u8'\xff';
      char b = u8'\027';
      char d = u8'd';

      char_t u8c = u8'c';  //  char_t since c++20


> made noexcept part of type system
    this is means the noexcept specifier would as a part of function type.
    function has type same as its return type before this feature came.
    but functions differing only in their exception specification cant be overloaded.
    (just like the return type,exception specification is part of function type,but not part of the
    function signature)

    e.g.
	void f(int a) noexcept;
	void f(int a);
			//  the second f() cant be overloaded version of the first,
			//  because the different between them only in their exception specification.
			//  the second is no exception,the first is potentially exception.

	g() noexcept(false);
	g();
			//  both declarations for g are potentially throwing,but there have not overload.

	void f(void) noexcept;
	void (*pf)(void) = f;  //  error
	     		       //  f is noexcept,but pf requires a function which is potentially throwing.

	void (*pf2)(void noexcept = f;  //  OK 


> new order of evaluation
    every expression has a well-defined evaluation order !

    postfix expressions are evaluated from left to right.this includes functions calls and member selection
    expressions.
    assignment expressions are evaluated from right to left.this includes compound assignments.
    operands to shift operators are evaluated from left to right.

    Summary :
      the following expressions are evaluated in the order a,then b,then c,then d >
        a.b
	a->b
	a->*b
	a(b1,b2,b3)
	b @= a  //  '@' means any operator which can be combined with '='
	a[b]
	a << b
	a >> b

      #  additional rule :
      	   the order of evaluation of an expression involving an overloaded operator is determined by the
	   order associated with the corresponding built-in operator,not the rules for function calls.

         function calls :
	   the function is evaluated before all its arguments,but any pair of arguments(from the argument list) 
	   is indeterminately sequenced;meaning that one is evaluated before the other but the order is not
	   specified;it is guaranteed that the function is evaluated before the arguments.

    //  new order of evaluation is to solve a problem occurs in chaining expressions like :
    	  std::cout<<f()<<t()<<c();  //  a chaining member functions calls.


> lambda capture of *this
    the current object *this can be implicitly captured if either capture default is present,if implicitly
    captured,it is always captured by reference,even if the capture default is '='.
    (c++20,the implicit capture of *this when the capture default is '=' is deprecated)

    captures :
      [this]	simple by-reference capture of the current object
      [*this]	simple by-copy capture of the current object


> compile-time if constexpr
    if statement :
      syntax :
        <attr>(optional) if constexpr(optional) (<init-statement>(optional) <condition>) <statement-true>
			 else <statement-false>

      the constexpr keyword in if statement :
        if present,the statement becomes a constexpr if statement.

      init-statement : (since c++17)
        either an expression statement or a simple declaration,typically a declaration of a variable with
	initializer,but it may declare arbitrary many variables or be a structured binding declaration.
	(an alias declaration (since c++23))
	//  init-statement must end with a symbol ';',null statement is supported just a ';'.

    constexpr if statement :
      in a constexpr if statement,the value of condition must be a contextually converted constant
      expression of type bool(until c++23)<an expression contextually converted to bool,where the
      conversion is a constant expression.(since c++23)>
      
      //  the return statements in a discarded statement do not participate in function return type deduction.

      E.g.
        template<typename T>
	auto get_value(T t)
	{
	  if constexpr(std::is_pointer_v<T>)
	    return *t;
	  else
	    return t;
	}

      //  if constexpr is not a substitute for the #if preprocessing directive,this means if constexpr
      	  statement have not macro alike behavior.
      //  when constexpr if statement inside a template,and the condition is not value-dependent after
          instantiation,the discarded statement is not instantiated while the enclosing template is
	  instantiated.

    //  consteval if since c++23


> constexpr lambda
    syntax :
      [<captures>] (<params>) <specs requires>(optional) { <body> }

      specs requires = constexpr,the lambda expresion becomes constexpr lambda.
      that means it has same behavior as constexpr function.
      and,even constexpr is not present,if the function satisfy all constexpr function requirements,
      the function call operator of any given operator template specialization(lambda expression indeed is
      ClosureType) will be constexpr anyway!