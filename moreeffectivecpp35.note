Chapter Basics >

  Item 1 : Distinguish between pointers and references
         Pointers use * or -> to indirectly access object
	 References use . to indirectly access object

	 Differences between reference and pointer :
	   1>  reference can not be a NULL reference
	   2>  pointer can be NULL pointer
	   3>  if design does not allow NULL object,then prefer reference,otherwise
	       use pointer.
	       ERROR e.g.
	         char *x = 0;  //  NULL pointer
		 char &y = *x;  //  refer to NULL object
           4>  C++ requires reference must be initialized when declare.
	   5>  no need to test reference if valid before use it.         
	       mut test pointer if valid before use it.
	   6>  pointer is allowed to reassignment,but reference is not allowed.

       !!  you should use a pointer whenever you need to take into account the possibility that
	   there is nothing to refer to or whenever you need to be able to refer to different
	   things at different times.  !!
       !!  you should use a reference whenever you know there will always be an object to refer to
	   and you also know that once you are referring to that object,you will never want to 
	   refer to anything else.
	   you should use a reference when implementing operators whose syntactic requirements make
	   the use of pointers undesirable.in all other cases,stick with pointers.  !!


  Item 2 : Prefer C++ style casts
         the traditional C-style casts'problems :
	   1>  C-style is designed for C,not C++,so that,
	       cast a pointer-to-const-object into a pointer-to-non-const-object and
	       a cast that changes a pointer-to-base-class-object into a pointer-to-derived-class-object
	       is no difference for C-style cast.
	   2>  tranditional C-style cast syntactically consist of little more than a pair of parentheses
	       and an identifier.
	       it belike this :
	         int a = 0;
		 float b = (float)a;
		 float c = float(a);
	       but everywhere in C++ might be parentheses are existed.
	       so there is a question,"Are any casts used in this program?"

	 Use C++-style casts to instead C-style casts :
	   static_cast<type>(expression)
	   dynamic_cast<type>(expression)
	   const_cast<type>(expression)
	   reinterpret_cast<type>(expression)


	   const_cast is used to remove constness of an object,but it is not realy remove it,just
	   make a copy from object and that is constless.
	   const_cast is used to remove volatileness of an object.
	   const_cast is only used for these two purposes.

	   reinterpret_cast is to cast between function pointer types.
	   example :
	     using funcPtr = void (*)();
	     funcPtr funcPtrArray[10];
	     int func1();
	     funcPtrArray[0] = func1;  //  ERROR,func1 has wrong type which is returns int.
	     funcPtrArray[1] = reinterpret_cast<funcPtr>(func1);
				       //  OK.
	   cast for function pointers is not portable!

	 following C++-style casts but compiler is not support :
	   template<typename _Type, typename _EType>
	   _Type static_cast(_EType expression)
	   {
	     return (_Type)(expression);
	   }

	   #define static_cast(TYPE, EXPRESSION) ((TYPE)(EXPRESSION))
	   #define dynamic_cast(TYPE, EXPRESSION) ((TYPE)(EXPRESSION))

	   //  but these functions would not report cast fails.

	 !!  prefer C++ style casts,even they are hard to type or ugly,because that style will improve
	     code readability,and designed for C++ programming.  !!


  Item 3 : Never treat arrays polymorphically
       	 dont mix polymorphism and pointer arithmetic.
	 e.g.
	   void printC(ostream &output, const TheClass Array[], int numElements)
	   {
	     for (unsigned i(0); i < numElements; ++i) {
	       output<<Array[i];
	     }
	   }

	   TheClass Array[10];  //  initialized by default constructor
	   printC(std::cout, Array, 10);  //  there is no polymorphism and pointer arithmetic mixing

	   DerivedTheClass DArray[10];  //  initialized by default constructor
	   printC(std::cout, DArray, 10);  //  there is polymorphism and pointer arithmetic mixing

	   //

	   Array and DArray are arrays one of type TheClass another of type DerivedTheClass.
	   every elements in array is an object,not a object pointer.
	   in the loop which print class contents,for each Array[i],compiler will generates
	   generic code which has form like this :
	     output<<*(Array + i);
		 
	     this form is no problem for TheClass Array,but it is not suit DerivedTheClass array.
	     DerivedTheClass is inherit from TheClass,so its size is greater than TheClass.
	     function printC() receives an array which type is TheClass,so compiler knows the displacement
	     for each elements in the array.
	     if pass an array type of DerivedTheClass,displacement between DerivedTheClass objects is not
	     same as displacement between TheClass objects.
	     this is problem!

	   not only loop would arise such problem,and "delete[] @array" will also bring the problem.
	   for delete an array contains class object,C++ have to calls every element's destructor,
	   that is a loop alike above.

	   the true way to use polymorphism in array :
	     TheClass *pArray[10];  //  initialize every pointer point to a DerivedTheClass object.

	     pointer point to TheClass is no difference with pointer point to DerivedTheClass.
	     be there,pointer arithmetic will do "*(pArray + i * sizeof(void *))",on x86,pointer
	     has length 8 bytes.

	     there is not real class object in the array,just pointer objects.
	     
	     note : 
	       if object is not from new,then can not delete it.
	       at above,the class object only destructed when program exit.
	       at above,if the class object is from new and assign address to the element in array,
	       have to manually delete every allocated memory where the class object be.

	     another discussion :
	       TheClass **pArray(new TheClass*[10]);
	       pArray[0] = new TheClass;
	       ...
	       pArray[9] = new TheClass;

	       delete[] pArray;  //  what happens ?
	       			 //  every element in pArray is a pointer point to TheClass object.
				 //  delete[] pArray,recycle all resources this pointer array occupied.
				 //  for delete pArray,have to delete every element in array at first.
				 //  delete pArray[0] will cause a call to TheClass::~TheClass() .
				 //  delete pArray[i] will cause a call to (*(pArray[i])).TheClass::~TheClass() .


           !!  do not mix polymorphism with pointer arithmetic.that would not bring
	       expected behaviors.  !!


  Item 4 : Avoid gratuitous default constructors
         a default constructor is the C++ way of saying you can get something for nothing.
	 a class lack a default constructor,its use may be problematic in three contexts :
	   1>  creation of arrays.
	       when create an array of type is such class which is lack default constructor,
	       that will failed.
	       e.g.
	         A array[10];  //  ERROR,every element has to be initialized by default constructor
		 A *pA = new A[10];  //  ERROR

	       there are three ways to get around this restriction :
	         >  declare and initialize.
		    e.g.
		      A array[2] = {A(3), A(4)};
		    but this way is not apply to heap array.
		 >  use an array of pointers instead of an array of objects.
		    this is apply to head array.
		    e.g.
		      A *pArray[10];
		      for (int i(0); i < 10; ++ i)
		        pArray[i] = new A(i);

	            but there are two disadvantages to this approach.
		    first :
		      have to remember to delete all the objects pointed to by the array.
		    second :
		      the total amount of memory increases,memory amount = pointers + objects.

		 >  to privent the space penalty,use the raw memory for the array :

		      void *pArray = operator new[] (10 * sizeof(A));  //  allocate object memory space(raw memory)
		      A *pA = static_cast<A*>(pArray);
		      for (int i(0); i < 10; ++i)
		        new (pA + i) A(i);      //  placement new.

		      there is no need to save pointers in an array.

		 this technique allows to create arrays of objects when a class lacks a default constructor;
		 it does not show how to bypass required constructor arguments.

		 for method 2,have to delete pointer manually.
		 for method 3,have to call destructor on each object in memory units at first,then delete raw memory.
		 !  do not call "delete[] pA;" for method 3,because pointer pA is not from new.(undefined behavior)

	   2>  ineligible for use with many template-based container classes.
	       that is because it is a common requirement for such templates that the type
	       used to instantiate the template provide a default constructor.
	       this requirement almost always grows out of the fact that inside the template,
	       an array of the template parameter type is being created.
	       e.g.
	         template<typename T>
		 class A {
		 public:
		   A(int size)
		   {
		     Data = new T[size];  //  if T is lack default constructor,this is an ERROR
		   }
		 private:
		   T *Data;
		 };

	       !  careful template design can eliminate the need for a default constructor,for example,
	       	  std::vector has no requirement that its type parameter have a default constructor.
		  but not all containers alike vector.

         virtual base classes lacking default constructors are a pain to work with :
	   the arguments for virtual base class constructors must be provided by the most derived class
	   of the object being constructed.
	   as a result,a virtual base class lacking a default constructor requires that all classes derived
	   from that class - no matter how far removed - must know about,understand the meaning of,and provide
	   for the virtual base class's constructors' arguments.

	   e.g.
	     class A {
	     public:
	       A(int x);
	     };

	     class B : virtual public A {
	     public:
	       B(int x, int y) : A(y)
	       {
	         ...
	       }
	     };

	     class C : public B {
	     public:
	       C(int x, int y, int z) : B(x, y), A(z)  //  C have to know and understand A's constructors' argument.
	       {
	         ...
	       }
	     }

	 !!  some people belive all classes should have default constructor even it does not have enough information to
	     fully initialize objects of that class.but inclusion of meaningless default constructors affects the 
	     efficiency of classes,too.code have to test to see if fields have truly been initialized,and have to handles
	     the case where the tests fail.of course,these bring code bloat.  !!
	 !!  default value to constructor could get behavior like default constructor.but the default value maybe still
	     meaningless,because the information used to create a class should from outside.
	     this method also confuse to other member functions.  !!


Chapter Operators >

  Item 5 : Be wary of user-defined conversion functions
       	 C allows implicit type conversions such char -> int or short -> double.
	 but covert a type double to short will lose information,etc.
	 C++ inherited C' attribute,so such conversions are included in C++.
	 (implicit type conversion,compiler does not report)

	 Two kinds of functions allow compilers to perform such conversions :
	   single-argument constructors
	   implicit type conversion operators

	   A single-argument constructor is a constructor that may be called with only one argument,
	   that is,the constructor is declared receives one argument,or more than one argument but
	   the argument after the first has a default value.
	   e.g.
	     struct A {
	       A(int x);		//  allows int -> A
	       A(float x, int y = 0);	//  allows float -> A
	     };

	   An implicit type conversion operator is simply a member function with a strange-looking name :
	   the word operator followed by a type specification.and can not specify a type for the function's
	   return value.
	   e.g.
	     struct A {
	       operator int();
	     };

	 the fundamental problem is that such functions often end up being called when neither want nor expect them to be.
	 e.g.
	   struct A {
	     operator int() const;
	   };

	   A a;
	   cout<<a;

	   //  there is no suit operator<< function to be called,so that should fails.
	   //  but compiler seen no suit operator<< function,then try to implicit type conversion to make
	   //  the invocation success.
	   //  so compiler convert a to int,because "operator int()" is defined.
	   //  but this is not a expected behavior.

	 so,these functions,their presence can lead to wrong function being called.

	 solution :
	   replace the operators with equivalent functions that do not have the syntactically magic names.
	   e.g.
	     struct A {
	       int asInt() const;  //  replace operator int()
	     };

	   this would insist explicit calling to do type conversion.

	   in most cases,the inconvenience of having to call conversion functions explicitly is more than
	   compensated for by the fact that unintended functions can no longer be silently invoked.

         another problem is single-argument constructors will be used as type conversion functions implicitly.
	 solutions :
	   1>  use "explicit" keyword.
	       e.g.
	         struct A {
		   explicit A(int x);
		   A operator+(const A &lhs, const A &rhs);
		 };

		 forbit compiler calls the function implicitly,just allows programer calls it explicitly.

		 A a(10);  //  OK
		 A b = a + 3;  //  ERROR,no suit operator+ and impilicit type conversion from int to A had been
		       	       //  forbidden.

		 //  A b = a + static_cast<Array<int> >(3); is still valid.
		 
		 !  expiclit keyword apply to a copy-constructor will forbids pass class object as function parameter or
		    return by value from function.

	   2>  use proxy class.
	       e.g.
	         template<typename T>
		 class Array {
		 public:
		   class ArraySize {
		   public:
		     ArraySize(int numElements) : theSize(numElements) {}
		     int size() const { return theSize; }
		   private:
		     int theSize;
		   };

		   Array(int lowBound, int highBound);
		   Array(ArraySize size);
		   ...
		 };

		 there is a rule followed by compiler when compiler try type conversion,that is :
		   a sequence of functions to be called for type conversion can only has one user-defined function.
		 
		 design class with the rule is able to disable implicit type conversion,like above.

		 Array<int> a(10);  //  Array<int> takes an ArraySize object as argument to construct object.
		 	    	    //  compiler found there is a way to construct ArraySize object via int value,
				    //  then it does this calling: Array<int>::ArraySize(10);
				    //  and use the ArraySize object to construct Array object.
				    //  OK

		 Array<int> b(10);  // OK

		 a == b[3];  //  ERROR
		      	     //  b[3] returns a value of int or a reference to int object.
			     //  for calls operator== ,there needs two Array objects,so compiler try to covert
			     //  int to Array.
			     //  the sequence is : calls Array<int>::ArraySize(10),returns tempArraySize,
			     //                    calls Array<int>(tempArraySize),returns tempArray.
			     //  but this sequence contains two user-defined functions,so it is violate the rule.

	       proxy class actually a specific instance of a more generial technique.
	       the proxy class ArraySize just used for conjure Array object up,each ArraySize object stands for
	       a Array object.


	 !!  proxy objects can give you control over aspects of your software's behavior,at above,it is 
	     implicit type conversion.  !!
	 !!  granting compilers license to perform implicit type conversions usually leads to more harm than godd,
	     so do not provide conversion functions unless you are sure you want them.  !!


  Item 6 : Distinguish between prefix and postfix forms of increment and decrement operators
       	 In C,prefix form of the increment operator is sometimes called "increment and fetch",
	 postfix form is often known as "fetch and increment".

	 C++ allows overload prefix/postfix increment/decrement.
	 for distinguish prefix from postfix,when write a postfix overload function,it takes a int parameter but
	 no real name,this can prevent compiler issue a warning that unused variable.
	 e.g.
	   struct A {
	     int x;
	     A &operator++()  //  prefix
	     {
	       ++x;
	       return *this;
	     }
	     const A operator++(int)  //  postfix
	     {
	       A tempA = *this;
	       ++(*this);
	       return tempA;
	     }
	   };

	 the reasons that prefix returns reference and postfix returns const object :
	   prefix is "increment / decrement and fetch",this means function have to increment/decrement *this at first,then
	   return it.
	   but why postfix returns const object?
	   if it returns reference as same as prefix,then there is
	     A a;
	     a++++;  //  this is conflict to built-in type.
	     	     //  int x; x++++;  is ERROR
           and postfix is "fetch and do something",that means retrive object at first then do something on original object.
	   
	   if it returns object but no const,then there is
	     A a;
	     a++++;  //  built-in type did not allow such form.
	     	     //  and it would not do something expected by client.
		     //  it would not increase a twice,
		     //  first,increase *this,
		     //  second,increase tempA.
           const object could prevent such calling,because tempA is const,can not increase it.

	   !  A good rule to follow then designing classes is when in doubt,do as the intS do,and the intS most certainly
	      do not allow double application of postfix increment.

         at above,the implementation of postfix is depends on prefix.because,at most times,postfix is behave alike prefix,
	 except the return type.thus,let postfix depends on prefix,that allow programmer just maintain prefix as well,postfix
	 depends on prefix.

	 !!  prefix operators has different semantics to postfix operators.for distinguish the form of prefix to postfix,the postfix
	     should take a no name parameter.  !!
	 !!  prevent double application of postfix operators on a object.that would not get expected behavior.  !!
	 !!  when dealing with user-defined types,prefix operators should be used whenever possible,because it is inherently more
	     efficient.  !!
	 !!  let postfix operators depend on prefix operators,that allows programmer just maintain prefix version as well,postfix
	     will automatically behave in a consistent fashion.(except return type).  !!


  Item 7 : Never overload &&, ||, or , .
         C and C++ employs short-circuit evaluation of boolean expressions.
	 this means that once the truth or falsehood of an expression has been determined,evaluation of the expression
	 ceases,even if some parts of the expression have not yet been examined.
	 e.g.
	   char *p;
	   ...
	   if (p != 0 && strlen(p) > 10)
	   ...

	   //  if p == nullptr,then,this short-circuit evaluation has value false,
	   //  strlen(p) would not be evaluated.of course,pass a nullptr to strlen() is wrong.

	 if overload && and || ,then the example is look like this :
	   if (operator&&(p != 0, strlen(p) > 10))  //  operator&& as global overload
	   ...

	 it becomes a function call,but function call semantics differ from short-circuit semantics in
	 two crucial ways.
	   first>  when a function call is made,all parameters must be evaluated,so when calling the functions
	   	   operator&& and operator||,both parameters are evaluated.
		   that is,there is no short-circuit.
	   second> the language specification leaves undefined the order of evaluation of parameters to a function call,
	   	   so there is no way of knowing whether expression1 or expression2 will be evaluated first.

	 as result,if overload && or ||,there is no way to offer programmers the behavior they both expect and have come
	 to depend on.

	 comma operator :
	   int a = 0, b = 3;
	   b = 3, a = a + 1 + b;

	   just as there are rules in C++ defining how && and || behave for built-in types,there are rules defining how
	   the comma operator behaves for such types.
	   an expression containing a comma is evaluated by first evaluating the part of the expression to the left of 
	   the comma,then evaluating the expression to the right of the comma;the result of the overall comma expression
	   is the value of the expression on the right.

	 if write operator, as a non-member function,you will never be able to guarantee that the left-hand expression is
	 evaluated before the right-hand expression.(it becomes a function call)
	 if write operator, as a member function,even here,it is can not rely on the left-hand operand to the comma
	 operator being evaluated first,because compilers are not constrained to do things that way.

	 as result,do not overload comma operator.

	 !!  overload operator the purpose is to make programs easier to read,write,and understand.
	     if you do not have a good reason for overloading an operator,do not overload it.
	     in the case of &&, ||, and , ,it is difficult to have a good reason,because no matter how hard
	     you try,you can not make them behave the way they are supposed to.  !!


  Item 8 : Understand the different meanings of new and delete
       	 new behave like this two fold :
	   >  allocates enough memory to hold an object of the type requested.
	   >  calls a constructor to initialize an object in the memory that was allocated.

	 programmer can not changes its behavior,just only be able to determine how the memory for an object is
	 allocated.

	 when programmer calls new to create heap-based object :
	   std::string *str = new std::string("test");

	   compiler probably creates such code :
	     void *tempP = operator new(sizeof(std::string));
	     calls std::string's constructor on tempP.
	     std::string *str = static_cast<std::string *>(tempP);

	   notice that the second step above involves calling a constructor,something you,a mere programmer,
	   are prohibited from doing.
	   programmer can not directly call the constructor necessary to initialize the object.(for heap-based object)

         if you holds some raw heap memory,and want to construct an object in the memory,could use palcement new :
	   #include <new>

	   void *tempP = operator new(sizeof(std::string));
	   std::string *str = new (tempP) std::string("test");

	   //  it looks like this :
	   void *operator new(size_t, void *location)
	   {
	     return location;
	   }

	 if you want to allocate memory and call constructor on it,use "new" statement.
	 if you just want to allocate memory only,use "operator new" statement.
	 if you want to construct an object in memory you have already got a pointer to,use "placement new" statement.
	 operator new and placement new could be overloaded.

	 deletion and memory deallocation :
	   the function operator delete is to the built-in delete operator as operator new is to the new operator.
	   when programmer delete an object,compiler mighe generate such code :

	     std::string *str = new std::string;

	     delete str; {
	       str->~std::string();   //  call destructor at first,
	       operator delete(str);  //  call operator delete function at second.
	     }

	   if you want to deal only with raw memory,you should bypass the new and delete operators entirely.
	   e.g.
	     void *buffer = operator new (sizeof(char) * 30);
	     operator delete(buffer);

	   do not call delete on a pointer which is returned by placement new,because nobody knows where the pointer
	   from.just undo the effect of the constructor by explicitly calling the object's destructor.	 
	   e.g.
	     std::string *str = new (buffer) std::string("test");
	     str->~std::string();

	 Arrays :
	   when create an array contains some objects,operator new[] would be called.(array new)
	   of course,operator new[] also could be overloaded.(if compiler does not support operator new[],then all
	   memory allocation is through operator new,in the case,do not overload operator new as well)

	   the new operator,for arrays,a constructor must be called for each object in the array,when the delete operator
	   is used on an array,it calls a destructor for each array element and then calls operator delete[] to deallocate
	   the memory.
	   e.g.
	     std::string *strArray = new std::string[10];
	     delete[] strArray;

	   operator delete [] is also could be overloaded,just like operator new [].(has some restrictions)

	 !!  when you think about customizing the behavior of the new and delete operators,remember that,you can not really
	     do it.you can modify how they do what they do,but what they do is fixed by the lanaguage.  !!  
	 !!  must pair new and delete,new[] and delete[].do not mix them.  !!


Chapter Exceptions >

  Item 9 : Use destructors top prevent resource leaks
       	 C++ from C,and of course,it supports error code returning.
	 but the difference between error code and exception,that is,exception can not be ignored.
	 when an exception was thrown,then program have to catch it,if it not,the default action is stop program.
	 where the exception is thrown,the statements after would be skipped,then resouce leaks risk is come in.
	 e.g.
	   void do_something(void)
	   {
	     for (int i = 0; i < 10; ++i) {
	       int *intPointer = createInt(i);
	       delete intPointer;
	     }
	   }

	   if function createInt() throw an exception,then the statements after call point would be skipped,
	   because do_something() does not catch the exception,so it will propagates to its caller.
	   statement "delete intPointer;" will be skipped,resouce leaks happens.

	   a good resolution is use smart pointer,follow RAII rule.
	   destructor always be called if the object's lifetime is end,be there,that is leave the loop scope.

	   void do_something(void)
	   {
	     for (int i = 0; i < 10; ++i) {
	       std::unique_ptr<int> intPointer(createInt(i));
	     }
	   }

	   //  destructor of std::unique_ptr will be called if intPointer encountered death.

	 C++ exception cause stack unwinding.this is behavior that C programmers can approach only by using setjmp
	 and longjmp,but longjmp exhibits a serious deficiency when used with C++ :
	   it fails to call destructors for local objects when it adjusts the stack.

	 !!  for prevent resource leak,should follow RAII rule,use smart pointer to instead raw pointer.  !!


  Item 10 : Prevent resource leaks in constructors
       	  what would happens if exception is thrown in constructor?
	  example :
	    struct A {
	      int *a;
	      int *b;
	      A()
	      {
	        a = createInt(10);  //  maybe throw
		b = createInt(11);  //  maybe throw
	      }

	      ~A()
	      {
	        delete a;
		delete b;
	      }
	    };

	    if a had been assigned,and exception is thrown when create b,then resouce leaks happen.

	  C++ refuse to call destructor on a not fully constructed object.an object is fully constructed if its constructor
	  had been completed.
	  e.g.
	    int main(void)
	    {
	      A testa;
	      return 0;
	    }
	    //  if exception is propagated from A::A(),then it is not fully constructed,its destructor would never be called.
	    //  the resource of A::a points to will leak forever.

	  to solve such problem,should do some clean up manully before exception propagates,that is :
	    A()
	    {
	      try {
	        a = createInt(10);
		b = createInt(11);
	      } catch(...) {
	      	delete a;  //  clean a
		delete b;  //  clean b
		throw;
	      }
	    }

	    C++ allows delete a nullptr.
	    because destructor does something as cleanup code,so there could prevent code duplication.
	      void A::private::cleanup()
	      {
	        delete a;
		delete b;
	      }

	      void A::~A()
	      {
	        cleanup();
	      }

	  there is another problem occur when pointer is const :
	    struct A {
	      ...
	      int const *a;
	      int const *b;
	    };

	    such pointer is able to be initialized only in member-initialize list.
	      A() : a(new int), b(new int) { ... }

	    but member-initialize list only allows expressions,can not place try-catch block be there.

	    as above,propagates an exception before cleanup executing,but cleanup have to be executed in try-catch block,
	    so place calling where in a help function,then let the expression invoke them.
	    e.g.
	      int *A::creatA(void)
	      {
	        int *x(new int);
		return (x) ? x : 0;
	      }

	      int *A::creatB(void)  //  because b is initialized after a has been initialized,so place try-catch in it.
	      {
	        int *x(nullptr);
		try {
		  x = new int(&x);
		} catch(...) {
		  delete a;
		  throw;
		}
		return x;
	      }

	      A() : a(creatA), b(creatB) { }

	      !  this method could deal with such problem,but it will reduce readability of code.so do not recommend.
	      !  creatA and creatB as a part of construcotr but separated.

	    a more useful method is use smart pointer.
	    e.g.
	      struct A {
	        const std::unique_ptr<int> a;
		const std::unique_ptr<int> b;
		A() : a(creatInt()), b(creatInt()) { ... }
		...
	      };

	      if exception is throw out when initializing A::a,then no resouce have to be destroyed.
	      if exception is throw out when initializing A::b,then resource of A::a have to be destroyed,but by the time,
	      A::a had been constructed completly,so the destructor of std::unique_ptr<int> would be called,it is fully
	      constructed object.

	  !!  as summary,the best way to prevent resouce leaks in constructor is use C++ smart pointer,follow RAII rule.  !!
	  !!  C++ refuses call destructor on a non-fully constructed object,because delete a nullptr is no sence.  !!
	      

  Item 11 : Prevent exceptions from leaving destructors
       	  There are two situations in which a destructor is called.
	    1>  when an object is destroyed under "normal" conditions.
	    2>  when an object is destroyed by the exception-handling mechanism during the stack-unwinding part of
	    	exception propagation.

          an exception may or may not be active then a destructor is invoked,but there is no way to distinguish these in
	  destructor.
	  so should always assume that an exception is active,because if control leaves a destructor due to an exception
	  while another exception is active,C++ calls the terminate function.

	  the second reason why it is bad practice to allow exceptions to propagate out of destructors :
	    if an exception is thrown from a destructor and is not caught there,that destructor won't run to completion.
	    if the destructor doesn't run to completion,it won't do everything it is supposed to do.

	  e.g.
	    struct A {
	      A()
	      {
	        dosomething();
	      }

	      ~A()
	      {
	        try {
		  doSomething();
		} catch(...) {}
	      }
	    };

	    //  if A::~A() was called because stack unwinding,and if might doSomething() throw an exception,
	    //  for prevent two exceptions is alive,have to prevent the exception leave A::~A().
	    //  there is just catch it but do nothing,all purpose is that do not let exception throw by doSomething()
	    //  leave A::~A().

	  !!  there are two good reasons for keeping exceptions from propagating out of destructors :
	        >  it prevents terminate from being called during the stack-unwinding part of exception propagation.
		>  it helps ensure that destructors always accomplish everything they are supposed to accomplish.
          !!


  Item 12 : Understand how throwing an exception differs from passing a parameter or calling a virtual function
          you can pass both function parameters and exceptions by value,by reference,or by pointer,however,there is
	  quite different.
	  e.g.
	    f(arg);
	    f(arg *);
	    f(arg &);

	    catch(arg);
	    catch(arg *);
	    catch(arg &);

	  when pass a parameter to function do a function invocation,the control would eventually returns to the call site.
	  but throw an exception,control will not return to throw site.
	  while catch an exception,regardless of whether it is passed by value or by reference,a copy will be made and pass
	  to catch clause.
	  e.g.
	    struct A {}
	    void func(A &x);
	    void func2()
	    {
	      A localA;
	      func(localA);
	      throw localA;  //  a copy of localA would be made.
	    } 	    	     //  when control leaves func2(),localA would be destructed,so copy is necessary.

	  C++ specifies that an object thrown as an exception is copied.
	  the copying occurs even if the object being thrown is not in danger of bing destroyed.
	  e.g.
	    void func2()
	    {
	      static A localA;
	      func(localA);
	      throw localA;  //  still a copy would be made.
	    }

	    //  even the exception is caught by reference,it can not modify the original object.

	  the mandatory copying of exception objects helps explain another difference between parameter passing and throwing an
	  exception: the latter is typically much slower than the former.
	  //  calls copy constructor to made copy.

	  attention :
	    the copy constructor in the class would be called is corresponding to the object's static type,not its dynamic type.
	    (inheritence will bring dynamic type)
	    //  in C++,copying is always based on an object's static type.

	  propagate an exception from catch block has two formats :
	  e.g.
	    {
	      throw derivedClass{};
	    }

	    catch (baseClass &w) {
	      ...
	      throw;
	    }  //  no copy made,even it is caught by a baseClass reference.
	    catch (baseClass &w) {
	      ...
	      throw w;
	    }  //  has copy made,a new exception is thrown,its type always be baseClass,because w's static type is baseClass.

	    first catch block just rethrow the exception but dont care about what its type is.(more efficient)
	    second catch block throw a new exception.

	 ! passing a temporary object to a non-const reference parameter is not allowed for function calls,but it is for exceptions.	  
	 ! if throw exception by value,then two copying would be made,one is temporary object,another is the parameter in catch clause.
	   (throw exception by value will always one more copying be made than pass value to function parameter)

	 exception is thrown by-pointer :
	   when throw an exception by-pointer,a copy of the pointer would be made,it as same as pass pointer to function.
	   so,dont let the pointer point to a local object(in the case throw an exception by-pointer)

	 no type conversions are applied to exception.
	 catch block specify the type of exception which expect to catch.so an exception is type of int,would not be caught by a
	 catch block which expect catch an exception is type of double.then the exception would propagated to next.
	 //  exception by-pointer only be caught by catch block which expect an exception by-pointer.

	 but there is some special cases :
	   1>  inheritance-based conversions.(baseClass->derivedClass)
	   2>  from a typed to an untyped pointer.(char *->void *)

	 the final difference between passing a parameter and propagating an exception is that catch clauses are always tried 
	 in the order of their appearance :
	   try {
	     ...
	   } catch (baseClass &x) { }
	     catch (derivedClass &x) { }

	   the first catch block catch an exception is type of baseClass reference,will catches all derivecClass exceptions,even
	   a catch block which expect such derivedClass exception and associated with a same try block!

	   //  this strategy is differ to virtual function invocation.
	   //  virtual function call strategy : best fit
	   //  exception handling strategy : first fit

	 !!  never put a catch clause for a base class before a catch clause for a derived class.  !!
	 !!  there are three primary ways in which passing an object to a function or using that object to invoke a virtual
	     function differs from throwing the object as an exception >
	       first : exception objects are always copied.(by-value,twice copied)
	       second : objects thrown as exceptions are subject to fewer forms of type conversion than are objects passed
	       	      	to functions.
	       three : catch clauses are examined in the order in which they appear in the source code,and the first one
	       	       that can succeed is selected for execution.
         !!


  Item 13 : Catch exceptions by reference
       	  there are three types for catch exceptions(has been discussed in Item12).
	  by-pointer,by-value,by-reference.

	  the problems caused by-pointer :
	    1>  the pointer points to a local object,which will be destructed when the control
	    	leaves throw site.(danging pointer)
            2>  for prevent problem1,have to allocate exception object on heap,
	    	but programmers how to determine where catch clause should delete the pointer it
		received.if the pointer is from a global object or a static object,delete the pointer
		is wrong.

          the problems caused by-value :
	    1>  slicing off.
	    	e.g.
		  class the_exception : public std::exception {
		    ...  //  some redefined virtual function.
		  };

		  try {
		    throw the_exception{};
		  } catch (std::exception ex) {
		    //  call to the virtual function redefined in the_exception.
		  }

		the problem is that,in the class hierarchy,the_exception is inherited from exception,
		when convert the_exception object to an exception object,slicing off would happen.
		then the data member in the_exception would be lost.
		so the call to virtual function redefined in the_exception would always point to
		the same function in exception,this is not expected behavior.

          by-reference :
	    solved problems for by-pointer.even catch by-reference,copy is still progress.
	    programmer do not need to determine if delete the pointer.(reference can not be deleted)

	    solved problem for by-value,because a reference to a base class could refer to a derived
	    class,when call virtual function,the called entity is determined dynamically by type of the object
	    this reference refers to.

	  !  C++ allows reference cast in inheriting hierarchy,but entity cast is forbid.
	     if A is the derived class of baseA.
	     then :
	       A a;
	       static_cast<baseA>(a);  //  force cast
	               		       //  the object coverted now lost data members defined in A
	       baseA ba;
	       static_cast<A>(ba);     //  force cast
	                	       //  the object coverted has no data members defined in A

	  !!  if you catch by reference,you side-step questions about object deletion that leave you damned if you do
	      and damned if you dont;
	      you avoid slicing exception objects;
	      you retain the ability to catch standard exceptions;
	      you limit the number of times exception objects need to be copied.
	  !!

					
  Item 14 : Use exception specifications judiciously
       	  if the exceptions the function would throw is not in exception specifications,this fault will be
	  detected at runtime,and the special function unexpected is automatically invoked.
	  the default behavior for unexpected is to call terminate!(terminate default call abort())

	  //  abort immediately stop program and do nothing for cleanup.
	  
	  if there is a function which might throw any kind of exception,and another function which might throw int exception,
	  then,there is :
	    void f1();
	    void f2() throw(int) { f1(); }

	    //  if f1() throw an exception is type of double out,but f2() did not catch it,then that exception will propagating.
	    //  the different exception had been throw out from f2(),it is unexpected,program will stop.

	  solve :
	    <first>
	    it is important to write yout software in such a way that these kinds of inconsistencies are minimized.
	    a good way to start is to avoid putting exception specifications on templates that take type arguments.
	    that is,templates and exception specifications do not mix.

	    template<class T>
	    void func();  //  no exception specifications there.

	    <second>
	    for avoid calls to unexpected is to omit exception specifications on functions making calls to functions that
	    themselves lack exception specifications.
	    e.g.
	      func1() throw() {}
	      func2() throw() { func1(); }  //  it's ok.

	      typedef (*funcPtr)(int);	 
	      funcPtr fptr = x;
	      func3(funcPtr f) throw() { f(); } //  ERROR,do not know if the entity pointer f points to is no throw.

	      typedef (*funcPtr2)(int) throw();
	      funcPtr2 fptr2 = y;
	      func3(funcPtr2 f) throw() { f(); }  //  OK

	      func4() {}
	      func5() { func4(); }  //  OK

	    the examples had been reveal that,match exception specifications for every function in the calling sequence.

	    <third>
	    handle exceptions "the system" may throw.
	    C++ allows replace unexpected exception with another exceptions of a different type.
	    unexpected has a default behavior,so there is a default function will be invoked when unexpected exception is
	    thrown,C++ allows replace the unexpected exception default function.

	    set_unexpected(void (*unexpected_func)());

	    class UnexpectedException {};
	    void coverUnexpected() { throw UnexpectedException(); }
	    set_unexpected(coverUnexpected);

	    then all function should not provides any exception specification.

	    another way to translate unexpected exceptions into a well known type is to rely on the fact that if the
	    unexpected function's replacement rethrows the current exception,that exception will be replaced by a 
	    new exception of the standard type "bad_exception".
	    e.g.
	      void coverUnexpected() { throw; }
	      set_unexpected(coverUnexpected);

	    then all catch clause receives a std::exception reference will catch the exception had been thrown out.

	  
	  maybe such case will happen,that is unexpected being invoked even when a higher-level caller is prepared to cope with
	  the exception that is arisen.
	  e.g.
	    func1() { try { func2(); } catch (...) {} }
	    func2() throw() { try { func3(); } catch (int x) {} }
	    func3() throw(double) { throw 3.2; }

	    //  func2() try-catch catch an exception is type of int,but func3() throw double.
	    //  then the exception will propagate,func2() was fail to catch it.
	    //  but func2() has an exception specification that no throw.
	    //  in this case,unexpected will be called,even func1() is ready to cope any type of exception.

	  !!  exception specifications are a tool to be applied judiciously.before adding them,consider whether the 
	      behavior they impart to your software is really the behavior you want.  !!
	  !!  C++11 has been supported "noexcept" keyword,now,no longer need to specify what kind of exception will
	      be thrown out by function.function is default "noexcept(false)".  !!


  Item 15 : Understand the costs of exception handling
       	  exception handling has costs,and you pay at least some of then even if you never use the keywords 
	  try,throw,or catch.
	    >  you pay for the space used by the data structures needed to keep track of which objects are
	       fully constructed.
	    >  you pay for the time needed to keep theses data structures up to date.
	    >  whenever you use try block,you have to pay.different compilers implement try blocks in different
	       ways,so the cost varies from compiler to compiler.
	       (code size and runtime inc 5%-10% even no thrown)<from experience>
	    >  compilers tend to generate code for exception specifications much as they do for try blocks.
	    >  throw an exception to return from a function may be as much as three orders of magnitude slower.
	       (copy exception-> destruct objects-> propagate exception)

	    these costs are typically quite modest.
	    so if a program compiled without exception is more faster and smaller,but exception is a part of
	    C++.
	    
	  some compiler is selective to exception supporting,if all object files(include anything) does not
	  use exception feature,then compile program without exception is a way to optimize program.

	  !!  to minimize your exception-related costs :
	        compile without support for exceptions when that is feasible;
		limit yout use of try blocks and exception specifications to those locations where you
		honestly need them;
		throw exceptions only under conditions that are truly exceptional.
          !!
	  !!  different compiler vendor use different ways to implement exception supporting,so switch to
	      another compiler maybe reduce costs.  !!
	    

  Item 16 : Remember the 80-20 rule
          the 80-20 rule state that 80 percent of a program's resources are used by about 20 percent of the code :
	    80 percent of the runtime is spend in approximately 20 percent of the code;
	    80 percent of the memory is used by some 20 percent of the code;
	    80 percent of disk accesses are performed for about 20 percent of the code;
	    80 percent of the maintenance effort is devoted to around 20 percent of the code.

	  the fundamental point is :
	    the overall performance of your software is almost always determined by a small part of its constituent code.

	  if your software is not so efficient,then you have to locate the code that are causing the problem,and have to
	  find ways to increase their performance dramatically.
	  there are two fundamentally different ways to approach the matter :
	    the way most people do it (empirical,intuitive)
	    and
	    the right way (program profiler)

	  a profiler can only tell you how a program behaved on a particular run,so if you profile a program using input
	  data that is unrepresentative,you are going to get back a profile that is equally unrepresentative.
	  that,in turn,is likely to lead to you to optimize your software's behavior for uncommon uses,and the overall
	  impact on common uses may even be negative.

	  !!  performance efficiency problem can be found in two ways :
	        the way most people do it;
		the right way;
          !!

	    
  Item 17 : Consider using lazy evaluation
       	  the best computations are those you never perform at all.
	  lazy evaluation is applicable in an enormous variety of application areas : 
	    Reference Counting :
	      e.g.
	        string s1 = "hello";
		string s2 = s1;

	      if do not need a copy of s1,then should not write s2 copy value of s1.
	      instead,let s2 share the value of s1,there just need a bookkeeping to trace who is sharing now.

	      but in the case,s2 would be modified,then there just one object(s2) should be changed.
	      e.g.
	        s2.modify();

	      s2 is sharing the value of s1,but modify() will modify the data,so have to make a copy for s2
	      as its private data and then modify it.
	      (we can be lazy no longer)

	      it is seem like what fork() did.

	      if want to recycle s1,have to keep a share counting,until the value becomes zero,the resource
	      is could to recycle safely.
	       
	    Distinguishing Reads from Writes :
	      e.g.
	        string s1 = "hello";
		cout<<s1[3];  //  Reading
		s1[3] = 'x';  //  Writing

	      we had like to be able to distinguish the read call from the write,because reading a reference-counted
	      string is cheap,but writing to such a string may require splitting off a new copy of the string's value
	      prior to the write.

	      there must have a way to distinguish Reading and Writing in operator[],in fact,but there is no way.

	      use lazy evaluation and proxy class could to defer what action it should take,
	      if reading is correct or writing is correct.

	    Lazy Fetching :
	      if there have to restore data from disk or database(local host or network host),then do not retrive
	      the data if it is the time which is not needed.
	      e.g.
	        class table_first {
		public:
		  table_first();
		  const table_first &field1() const;
		  const table_first &field2() const;
		  ...
		private:
		  mutable string *field1;
		  mutable string *field2;
		  ...
		};

		table_first::table_first() : field1(nullptr), field2(nullptr), ... {}
		const table_first &table_first::field1() const 
		{
		  if (field1 == nullptr)
		    field1 = new string;
		  retriveData(FIELD1, field1);
		}

	      when accessing to the field,have to check if it is nullptr first,if it is,then retrive data(have to allocate memory).
	      there is not needed to restore all field when construct object.

	      "mutable" is tell to compiler "i know what i am doing.",this allows programmer to modify data member while const this
	      is passed to member function.

	      //  if compiler do not support the keyword there is another way :
	      	    >  fake this pointer :
		         table_first * const fake_this = const_cast<table_first * const>(this);  //  C++ style
			 OR
			 table_first * const fake_this = (table_first * const)this;  //  C style

	      every fields have to be zero-initialized,and have to be checked before accessing.it is tedious and error-prone,
	      use smart pointer could prevent these work,and if use smart pointer,"mutable" is also not need.

            Lazy Expression Evaluation :
	      lazy expression evaluation is that only evaluate a part of the computation.
	      for example,use matrix computation.
	      e.g.
	        Matrix m1(100, 100);
		Matrix m2(100, 100);
		Matrix m3 = m1 + m2;
		Matrix m4(100, 100);
		m1 = m4;

	      if m3 will be used immediately and all information is needed,lazy expression evaluation will not only slow computation,
	      it is also cost more memory.

	      if program only use a part of m3,then should not evaluate all of m3.
	      e.g.
	        m3(3, 2);  //  retrive value at position [3, 2] inside m3.

	      then lazy expression evaluation should only evaluate what is the result in m3(3, 2) from add m1 to m2.

	      for implement lazy expression evaluation,could let m3 hold a data struct that saves the copy of operands of the computation
	      and the operation of the computation.
	      (copy is also can be deferred,but have to make a promise even operands changed,the result of the operation is same as former)
	      any execute the operation when the result is needed.

	      as above example,if m3 is unused,then should not write such code to evaluate m3.

	  !!  C++ implemented with eager evaluation,but program is able to implement lazy expression evaluation via encapsulation.  !!
	  !!  should use lazy strategy judiciously,only use it when it necessary.  !!
		

  Item 18 : Amortize the cost of expected computations
       	  over-eager evaluation :
	    doing things before you are asked to do them.

	  the idea behind over-eager evaluation is that if you expect a computation to be requested frequently,you can lower the average
	  cost per request by designing your data structures to handle the requests especially efficiency.

	  amortize the cost :
	    cache
	    prefetching

	  eager-evaluation is do the work everytime.
	  lazy-evaluation is do the work only it is demanded.
	  over-evaluation is do the work before it been asked.

	  cache :
	    cache is an over-eager-evaluation strategy,it is always be used in database,operating system,reading from disk...
	    for example,Linux high speed page caching.

	    e.g.
	      std::map<string, string> &cacheRead(const string &key)
	      {
	        static std::map<string, string> keyword_cache;
		auto value(read_db(key));
		keyword_cache[key] = value;
		return keyword_cache;
	      }

	      string findValue(const string &key, auto cache)
	      {
	        decltype(cache)::iterator it = cache.find(key);
		if (it == cache.end()) {
		  cacheRead(key);
		  return cache.find(key);
		}

		return (*it).second;
	      }

	      auto cache_handle = cacheRead("C++");
	      return findValue("C++", cache_handle);

	  prefetching :
	    prefetching is an over-eager-evaluation strategy,it is alike cache.
	    CPU often cache more than one lines instructions from memory,this is prefetching.
	    so often combined cache and prefetching to improve performance for a software.

	    e.g.  //  container template
	      template<class T>
	      class {
	        T &operator[](int index)
		{
		  if (index < 0)
		    std::abort();
		  else if (index > _current_size) {
		    "allocate more memory than index."
		    "new size = index - _current_size + index"
		  }

		  return "the indexth element of the container";
		}
		...
	      };

	    "prefetching" more memory from operating system,the next time call to operator[] maybe need not to allocating.

	  !!  Computer Science : you can often trade space for time.
	      however,using larget objects means fewer fit on a virtual memory or cache page.in rare cases,making objects
	      bigger reduces the performance of software,because paging activity increases,cache hit rate decreases,or both.  !!
	  !!  use over-eager-evaluation strategy judiciously.  !!


  Item 19 : Understand the origin of temporary objects
       	  True temporary objects in C++ are invisible--they do not appear in source code.
	  they arise whenever a non-heap object is created but not named.
	  such unnamed objects usually arise in one of two situations :
	    1>  when implicit type conversions are applied to make function calls succeed.
	    2>  when functions return objects.

	  example 1>
	    int func(string &s) { return s.length(); }
	    int func1(const string &s) { return s.length(); }
	    
	    char buffer[] = "hello world.";

	    func(buffer);  //  ERROR
	    func1(buffer);  //  OK

	    @buffer is an object stored in stack.

	    when pass @buffer to func(),because parameter type is mismatch,C++ will implicit convert @buffer to string &.
	    there,a temporary object @unnamed will be make up and it is type of string,then @s bind to @unnamed.
	    but @unnamed is a temporary object,so if programmer expects modify actual argument in func() will be wrong.
	    ! so C++ prohibits the generation of temporaries for non-const reference parameters.

	    when pass @buffer to func1(),it as same as func(),but @s is const-reference,so C++ allows the generation of
	    temporary object for const-reference parameter.@unnamed will be made up and then bind to @s.

	  example 2>
	    template<typename _Type>
	    const _Type operator+(const _Type &arg1, const _Type &arg2)
	    {
	      ...
	      return result;
	    }

	    class intType x = 3 + 2;

	    @result will as return value for operator+,and why it is const that is because overload operator should not
	    change its behavior.
	    there the return value is unnamed,for return @result,first have to make up @unnamed,then assign @result to
	    @unnamed,because @result is local variable,it will be destroyed when control leave operator+.
	    so the costs have to pay for construct @unnamed and destruct it.
	    as above,after @x had been assigned to @unnamed,@unnamed will be destructed.

	  !!  Anytime you see a reference-to-const parameter,the possibility exists that a temporary will be created to
	      bind to that parameter.  !!
	  !!  Anytime you see a function returning an object,a temporary will be created(and later destroyed).  !!


  Item 20 : Faciliate the return value optimization
       	  the by-value return,including the constructor and destructor calls it implies,can not be eliminated.
	  a function either has to return an object in order to offer correct behavior or it does not.
	  some functions just have to return objects,That is the way it is.

	  because can not eliminated constructor and destructor for by-value return,the optimzation should focus
	  on how to reduce the cost of returned objects.
	  e.g.
	    const Type operator*(const Type &lhs, const Type &rhs)
	    {
	      //  Type temp(lhs.first() * rhs.first(), lhs.second() * rhs.second());
	      //  return temp;

	      return Type(lhs.first() * rhs.first(), lhs.second() * rhs.second());
	    }

	    the trick is to return constructor arguments instead of objects.
	    if create @temp and then return it,there will be twice constructs and destructs,
	    the first for @temp,the second for return value.

	    but if return arguments,there only once construct and destruct.

	    Type a, b;
	    Type c = a * b;

	    if compiler supports return value optimization,it might use the return value to instead the outside
	    object which is allocated in stack frame.then call to operator* will be zero cost.

	    furthermore,you can not do any better than this,because @c is a named object,and named objects can not
	    be eliminated.you can,however,eliminate the overhead of the call to operator* by declaring that function
	    inline!(code bloat)

	  !!  this particular optimization -- eliminating a local temporary by using a function's return location(
	      and possibly replacing that with an object at the function's call site) -- is both well-known and
	      commonly implemented.it even has a name : the return value optimization.  !!


  Item 21 : Overload to avoid implicit type conversions
       	  when a class has a type-conversion function,compiler will try to create an object which is type of the class
	  from the argument it is not type of the class.
	  e.g.
	    struct A {
	      A(int x);		//  type conversion (only one parameter received constructor)
	      A(double y);
	      ...
	    };

	    const A operator+(const A &a, const A &b);

	    A a1;
	    A a2 = a1 + 10;		//  temporary object created
	    A a3 = 10.1 + a2;		//  temporary object created

	  how the overloading is to avoid type conversion ?
	  > C++ will processes type conversion when the function is calling and parameter has different type to argument.
	    if the parameter and the argument have same type,such conversion will not happen.
	    function overloading allows programmer to create several functions each has different parameter set.

	  e.g.
	    const A operator+(const A &a, double x);
	    const A operator+(const A &a, int x);
	    const A operator+(double x, const A &a);
	    const A operator+(int x, const A &a);

	    //  now call to operator+ with int and A object is no longer need type conversion,double as same.
	    //  no temporary will be created,if parameters are const-reference type.

	    const A operator+(int x, int y);	//  ERROR

	    this is because C++ required overloaded function at least receives one parameter is type of user-defined class.
	    if no this rule,that means programmer could to modify behavior and means to the language basic semantic.

	  !!  only use overloading when it is needed.(might it will improve efficiency of program or not)  !!
	  !!  overloading requires different parameter set,not return type.
	      the member function in base class which return the base class type is allowed to return derived class
	      type when redefined it inside derived class.  !!


  Item 22 : Consider using op= instead of stand-alone op
          op=  -->  += , -= , *= ...   (assignment version)
	  op   -->  + , - , * ...      (stand-alone version)

	  op could be implemented by op=.
	  e.g.
	    class OP {
	    public:
	      OP &operator+=(const OP &);
	      OP &operator-=(const OP &);
	      ...
	    };

	    const OP operator+(const OP &a, const OP &b)
	    {
	      return OP(a) += b;
	    }
	    const OP operator-(const OP &a, const OP &b)
	    {
	      return OP(a) -= b;	//  temporary object will be created
	    }
	    //  these two functions are eligible to return value optimization.
	    //  and they are implemented via += and -=,then just maintain assignment versions as well.
	    //  there is no longer need friend operator overloading,because += and -= always has a 
	    //  have known object to its left-hand.

	  normally,there is no relationship between operator+, operator-, and operator+=, so programmer
	  can freely implement them.it is like above.

	  three aspects of efficiency are worth noting here :
	    first>
	      in general,assignment versions of operators are more efficient than stand-alone versions,
	      because they have not to return value(just a reference).
	    second>
	      allow the difficult trade-off between efficiency and convenience.
	      e.g.
	        OP a, b, c, d, result;
		//  result = a + b + c + d;  //  three temporary objects
		result = a;
		result += b;
		result += c;
		result += d;		     //  no temporary object

	      by implementing the stand-alones in terms of the assignment versions,you ensure that when
	      clients switch from one to the other,the semantics of the operations remain constant.
	    third>
	      the example at above used unnamed object,if compiler supports to return value optimization,
	      there just once construct and once destruct,because no named object is exists.

	  !!  as a library designer,you should offer both,and as an application developer,you should consider
	      using assignment versions of operators instead of stand-alone versions whenever performance is
	      at a premium.  !!


  Item 23 : Consider alternative libraries
       	  Library design is an exercise in compromise.
	  libraries optimized for size and speed are typically not portable;
	  libraries with rich functionality are rarely intuitive;
	  bug-free libraries are limited in scope;
	  int the real world,you can not have everything;something always has to give.
       	  
	  for example,stdio is more faster and smaller than iostream,but any efficiency advantages of stdio
	  are highly implementation-dependent.

	  !!  the main point is that different libraries offering similar functionality often feature different
	      performance trade-offs,so once you have identified the bottlenecks in your software,you should see
	      if it is possible to remove those bottlenecks by replacing one library with another.  !!


  Item 24 : Understand the costs of virtual functions,multiple inheritance,virtual base classes,and RTTI
       	  Virtual functions :
	    most implementations use virtual tables and virtual table pointers.
	    virtual tables and virtual table pointers are commonly referred to as vtbls and vptrs,respectively.

	    vtbls is usually an array of function pointers(or link-table of function pointers).
	    each class will has its own vtbls and vptrs,if it had been declared virtual functions or inherited
	    virtual functions.

            vptr will as hidden data member in the class it has been declared virtual functions.(compiler adds it)

	    costs :
	      you have to set aside space for a virtual table for each class that contains virtual functions.
	      one virtual table per class.

	      compiler have to determines where the vtbls to be stored,there are two strategies.
	        1>  generate a copy of the vtbl in each object file that might need it,
		    and linker then strips out duplicate copies,leaving only a single instance of each vtbl in
		    the final executable or library.

		2>  a class's vtbl is generated in the object file containing the definition of the first non-inline
		    non-pure virtual function in that class.
		    but if all virtual functions are inline,then heuristic will fails,then compiler will use strategy1
		    to instead.
		    the way to prevent such problem is that do not declare virtual functions inline.
		    (compiler maybe ignore inline is because this)

	      you have to pay for an extra pointer inside each object that is of a class containing virtual functions.

	      compiler have to generate code to invoke the corresponding virtual function.
	      e.g.
	        void call(A *p)
		{
		  p->func();
		}

		-->

		void call(A *p)
		{
		  (*p->vptr[INDEX_OF_FUNC])(p);  //  p is this pointer
		}

		the cost of calling a virtual function is thus basically the same as that of calling a function through
		a function pointer.

		the third cost of virtual functions :
		  you effectively give up inlining.(virtual means wait until runtime to see which function is called)

            multiple-inheritance :
	      offset calculations to find vptrs within objects become more complicated,there are multiple vptrs within a
	      single object,and special vtbls must be generated for base classes in addition to the stand-alone vtbls.
	      (virtual base class part pointer)

	      as a result,both the per-class and the per-object space overhead for virtual functions increases,and the 
	      runtime invocation cost grows slightly,too.

	      virtual base classes may incur a cost of their own,because implementations of virtual base classes often
	      use pointers to virtual base class parts as the means for avoiding the replication,and one or more of 
	      those pointers may be stored inside objects.(middle classes maybe share vptr)

          RTTI runtime type identification :
	    RTTI lets us discover information about objects and classes at runtime,so there has to be a place to store
	    the information we're allowed to query.
	    that information is stored in an object of type type_info,operator typeid can access the object.

	    there only needs to be a single copy of the RTTI information for each class,but there must be a way to get to
	    that information for any object.(sound like a virtual function table)
	    the language specification states that we are guaranteed accurate information on an object's dynamic type
	    only if that type has at least one virtual function.
	    RTTI was designed to be implementable in terms of a class's vtbl.

	    maybe index 0 of vtbl contains the type_info object,so an additional entry in each class vtbl plus the cost
	    of the storage for the type_info object for each class.

          !!  it is equally important to understand that if you need the functionality these features offer,
	      you will pay for it,one way or another.  !!
	  !!  you are unlinkely to do better than the compiler-generated implementations by coding these
	      features yourself.  !!


Chapter Techniques >

  Item 25 : Virtualizing constructors and non-member functions
       	  a virtual constructor is a function that creates different types of objects depending on the input it is given.
	  e.g.
	    static <ReturnType> constructObject(input_stream_t istr)
	    {
	      //  read data from stream
	      //  construct data structure
	      //  put the data structure to the object.
	      ...
	    }

	    //  static function will be saved outside to the class space.
	    //  and all class objects will share the copy.

	  a virtual copy constructor returns a pointer to a new copy of the object invoking the function.
	  e.g.
	    virtual <ClassType> *copySelf() const
	    {
	      return new <ClassType>(*this);
	    }

	    //  we can let base class holds a pure virtual copy constructor,and redefine it in derived classes.

	  Making Non-Member Functions Act Virtual :
	    it is similar to virtual copy constructor.
	    for example,the operator<< would be overloaded in class,and it is used to print class's info.
	    e.g.
	      class A {};
	      class B : public A {
	        ostream &operator<<(ostream &) const;
	      };
	      class C : public A {
	        ostream &operator<<(ostream &) const;
              };

	      if these operator<< overload version are not friend function,they are member-function,then the syntax
	      is like this :
	        B b;
		b<<cout;
		C c;
		c<<cout;  //  BAD

              making non-member functions act virtual,the important point is that let the non-member function becomes
	      proxy function,which will calls classes' virtual functions.

	      e.g.
	        ostream &operator<<(ostream &c, const BaseClass *pB)
		{
		  return pB->print(c);  //  BaseClass pointer points to a derived class.
		}

		virtual ostream &A::print(ostream &) const =0;
		virtual ostream &B::print(ostream &c) const
		{
		  ...
		}
		virtual ostream &C::print(ostream &c) const
		{
		  ...
		  //  c<<member_a_;
		  //  c<<member_b_;
		  //  return c;
		}

          !!  virtualizing constructors and non-member functions maybe unlikely be used in practice,but if encountered
	      such situations,they are useful.  !!
	  !!  virtual behavior is determined by what the type the object is,this requires the object had been existed.
	      but virtualizing constructors and non-member functions can skip such requiring.  !!


  Item 26 : Limiting the number of objects of a class
       	  Allowing Zero or One Objects >
	    the easiest way to prevent objects of a particular class from being created is to declare the constructors
	    of that class private.
	    e.g.
	      class A {
	      private:
	        A() {}
		A(const A &) {}
              };

	      then no one could create such object.
	      can not to instantiate it.

	    but if want there is only one object is exist,then could use such design :
	    e.g.
	      class OnlyOne {
	      public:
	        friend OnlyOne &getOnlyOne(void);
	      private:
	        OnlyOne() {}
		OnlyOne(const OnlyOne &x) {}
	      };

	      OnlyOne &getOnlyOne(void)
	      {
	        static OnlyOne o;
		return o;
	      }

	      friend is able to access the private member,
	      static restrication can limit only one object is exist,
	      the constructors in private zone that prevent another one is able to create such object.

	      !! of course,static member function is able to implement the design.
	      class OnlyOne {
	      public:
	        static OnlyOne &getOnlyOne(void);
	      private:
	        OnlyOne() {}
		OnlyOne(const OnlyOne &x) {}
	      };

	      OnlyOne &OnlyOne::getOnlyOne(void)
	      {
	        static OnlyOne o;
		return o;
	      }  //  static object in a function not in a class,
	      	 //  you should not pay for things you do not use.

              why the functions are not inlining?
	      : functions with internal linkage may be duplicated within a program!
	      	so do not create inline non-member functions that contain local static data!

	      !! a different way to limit number of objects,that is use object counter.
	      class OnlyOne {
	      public:
	        OnlyOne()
		{
		  if (_numberObjects == 1)
		    throw IS_BEEN_EXISTED;
		  ++_numberObjects;
		}
		~OnlyOne()
		{
		  --_numberObjects;
		}
              private:
	        OnlyOne(const OnlyOne &x) {}  //  disable copying
		static unsigned short _numberObjects;
	      };

	      OnlyOne::_numberObjects = 0;

	      this way is attractive for a couple of reasons :
	        1>  everybody should be able to understand what is going on.
		2>  it is easy to generalize so that the maximum number of objects is some number other than one.

          Contexts for Object Construction >
	    suppose :
	      OnlyOne is inherited by another class,and it also inside to another class.
	      e.g.
	        class B : public OnlyOne {};
		class C { private: OnlyOne _o; };

		now the class OnlyOne objects can exist in three different contexts:
		  1>  _numberObjects()
		  2>  the part of OnlyOne in B
		  3>  the composition is OnlyOne in C

		but OnlyOne just permit one object is existed,so the exception IS_BEEN_EXISTED will be thrown.

            the Fact :
	    if the class has private constructors(in the absence of friend declarations),then it can not be the base class;
	    it also can not as composition inside another class.

	    suppose,the situation is that,there should has a class which is can not be derived and the number of 
	    instances is unlimited :
	    e.g.
	      (C++11)
	      class noDerived final {};

	      (C++99)
	      class noDerived {
	      public:
	        static noDerived *proxyCreate();  //  pseudo-constructor
	      private:
	        noDerived() {}
	      };

	      noDerived *noDerived::proxyCreate()
	      {
	        return new noDerived();
	      }
	      //  the caller who wish to have a instance of noDerived must call delete on it later.
	      //  smart pointer is useful for this problem.

          Allowing Objects to Come and Go >
	    if the class is required to be designed like this :
	      create object p1;
	      use p1;
	      destory p1;

	      create object p2;
	      use p2;
	      destory p2;

	    the method above can not satisfy the request.because,the class only allows one object is exist at a time.
	    but there is a way to achieve it :
	      <combine object-counting and pseudo-constructor>
	      class noDerived {
	      public:
	        static noDerived *proxyCreate();
		...
              private:
	        static const size_t _maxNumber;
		static size_t _current;
		noDerived()
		{
		  if (_current >= _maxNumber)
		    throw TOO_MANY_OBJECT;
		  ++_current;
		}

		~noDerived()
		{
		  --_current;
		}

		noDerived(const noDerived &);
	      };

	      const size_t noDerived::_maxNumber = 10;
	      size_t noDerived::_current = 0;

	      //  now the class allows maximum 10 objects are existed at a time.

          An Object-Counting Base Class >
	    not only the functions to manipulate the instance count,but also the instance count itself.
	    such way take an advantage,hidden counting and limiting from clients except class author.
	    this is means there will be a class which manages counting and limiting.
	    e.g.
	      template<class BeingCounted>
	      class Counted {
	      public:
	        class TooManyObjects {};  //  exception
		static size_t objectCount() { return _numObjects; }

              protected:
	        Counted() { init(); }
		Counted(const Counted<BeingCounted> &rhs) { init(); }
		~Counted() { --_numObjects; }

              private:
	        static size_t _numObjects;
		static const size_t _maxObjects;
		void init() noexcept(false)		//  pseudo-constructor
		{
		  if (_numObjects >= _maxObjects)
		    throw TooManyObjects();
		  ++_numObjects;
		}
	      };  //  the managing class

	      template<class BeingCounted>
	      size_t Counted<BeingCounted>::_numObjects;      //  put it in the file which
	      	     					      //  contains the implementation of Printer.
							      //  static variable default initialized to zero.

              /*  OR
	       *  class CountedClass;
	       *  template<>
	       *  size_t Counted<CountedClass>::_numObjects = 20;  
	       *  this syntax is also satisfy static const member initializing.
	       *  this is specializing syntax.
	       */
              template<class BeingCounted>
	      const size_t Counted<BeingCounted>::_maxObjects = <value>;  //  constant
	      //  the author which used template Counted have to determine the size of _maxObjects.
	      //  and put it in the class implementation file.

	      class Printer : private Counted<Printer> {
	      public:
	        using Counted<Printer>::objectCount;	 //  interface for client which require to check counter
		using Counted<Printer>::TooManyObjects;  //  exception for catch
		...

	      };

	      //  composition do not require virtual destructor.
	      //  base class will initialize at first.
	      /*  the template parameter @BeingCounted as template trait,so different template has different
	       *  static member object(@_numObjects and @_maxObjects).
	       */

          !!  this chapter had been introduced several methods to limiting the number of objects of a class,
	      in different case,pick up one to use or more than one and combine them could satisfy program design.  !!

  
  Item 27 : Requiring or prohibiting heap-based objects
       	  heap-based means the object is allocated on heap,and could delete it later.
	  there must no memory leak.

	  requiring heap-based objects >
	    for prevent clients from creating objects other than by calling new,should make
	    constructions and destructions illegal.

	    method1 :
	      make the destructor private and the constructors public.
	      define a proxy destructor to accessing the real destructor for delete object.

	    method2 :
	      it is also make the constructors private,but this require the class's author to remember
	      make all the constructors private.
	      then use proxy creation function to construct object.
	      so the better way is method1.

	    !  private destructor will forbid inheritance and containment,for solve this problem,
	       declare destructor protected.the class contains a object is requiring heap-based object,
	       should contains its pointer to instead object.

	    e.g.
	      class HeapBased {
	      public:
	        HeapBased();
	      protected:
	        ~HeapBased();  //  if this class is used in "is-a" inheritance,must declare virtual destructor.
	      ...
	      };

	      class A {
	      ...
	      private:
	        HeapBased *pHB;
	      };

	  determining whether an object is on the heap >
	    there are some tricks(ideas) to determine whether an object is on the heap,but they are not
	    work fine.
	      >  operator new calling indicator
	         e.g.
		   class A {
		     A()
		     {
		       if (!new_called)
		         throw EXCEPTION;
		       new_called = false;
		     }
		     void *operator new(size_t size)
		     {
		       new_called = true;
		       return ::operator new(size);
		     }
		   ...
		   private:
		     static bool new_called;
		   };

		 problems :
		   1 - if operator new[] was called,then operator new will not be called.
		       (of course,operator new[] could have a calling indicator)
		       operator new[] just be called once,then compiler calls constructors
		       on the memory units,the total of invocations is equal to @size.
		       the constructos will throw EXCEPTION expect the first element's constructor.
		   2 - if operator new was called twice,can not guarantee the steps is in
		       a expected order to be executed.
		       e.g.
		         A *x = new A(*new A);
			 //  may be compiler process operator new calling twice,
			 //  then calls constructors on the memory units.

	      >  memory address comparison
	      	 e.g.
		   bool onHeap(const void *address)
		   {
		     char x = 'x';
		     return address < &x;
		   }

		   many system organize C/C++ program like this figure :
		     TOP  STACK
		     ----------    [UNLINKED AREA]
		          HEAP
			  .bss
			  .data
			  .text
	           this trick is used to compare stack variable's address and heap address.
		   STACK grows from top to bottom,and HEAD grows from bottom to top.
		   if @address < &x,that means the object *address is under @x.

		 problem :
		   there is not to distinguish static variable and heap variable.
		   generally,static object is stored in .bss segment,and global object is
		   stored in .data segment.
		   so,if the object @r is static,then its address must less than @address!

		   !  this trick depends on system architecture,so it is not portable  !
		   !  if you absolutely,positively have to tell whether an address is on the heap,
		      you are going to have to turn to unportable,implementation-dependent system
		      calls  !

	      it is easier to determine whether it is safe to delete a pointer than to determine
	      whether a pointer points to somethting on the heap,because all we need to answer the
	      former question is a collection of address that have been returned by operator new.

	      >  abstract class to track pointer
	      	 for track pointer if it is returned by operator new,there could be a bookkeeping
		 to store entries from operator new,and "delete it" will remove it from bookkeeping,
		 this will be done in operator delete.
		 of course,function isOnHeap() should exist and used to determine @it is in bookkeeping.

		 e.g.
		   void *operator new(size_t size)
		   {
		     get memory;
		     if not null,store it in bookkeeping and return it;
		     else return nullptr;
		   }

		   void operator delete(void *it)
		   {
		     check if @it is in bookkeeping;
		     if @it is,then remove @it from bookkeeping,and delete it;
		     else do nothing or throw an exception;
		   }

		   bool isOnHeap(const void *ptr)
		   {
		     return if @ptr is in bookkeeping;
		   }

		 the problems occur in there is :
		   1 - should not add anything to global scope of C++,that will 
		       pollut namespace.
		   2 - efficiency,if it is not necessary,why we have to track it in
		       bookkeeping.
		   3 - objects with multiple or virtual base classes have multiple address,
		       so there is no guarantee that the address passed to isOnHeap() is the
		       same as the one returned from operator new,even if the object in question
		       was allocated on the heap.

		 for sovle these problems,we should design an abstract class,and each class we want
		 to track if it is on heap,should make it inherit from the abstract class.

		 e.g.
		   class HeapTracker {
		   public:
		     static void *operator new(size_t size);
		     static void operator delete(void *ptr);
		     bool isOnHeap() const;
		     virtual ~HeapTracker() = 0;
		   private:
		     std::list<void *> _bookkeeping;
		   };

		   bool HeapTracker::isOnHeap() const
		   {
		     const void *rawAddress = dynamic_cast<const void *>(this);
		     return _bookkeeping.find(rawAddress) != _bookkeeping.end();
		   }

		   dynamic_cast : this casting can only be used in inheritance hierarchy.
		   		  and it cast derived class to base class.
				  thus,dynamic_casting a pointer to void * yields a pointer
				  to the beginning of the memory for the object pointed to by
				  the pointer.
				  !  dynamic_cast is applicable only to pointers to objects
				     that have at least one virtual function.

	         !!  Attention :
		       this technique can not apply to built-in types,because they are no this
		       pointer.

          prohibiting heap-based objects >
	    if class'author wants preventing clients to allocate the class object on heap,the author
	    could overload operator new and operator delete,place them in same part.
	    e.g.
	      class HeapPreventing {
	      ...
	      private:
	        static void *operator new(size_t size);
		static void operator delete(void *ptr);
	      };

	      HeapPreventing a;  //  OKAY
	      HeapPreventing *x = &a;  //  OKAY
	      HeapPreventing *ptr = new HeapPreventing;  //  ERROR
	      		     	    			 //  attempts to call private method.

	   but there has some problems..
	     >  if operator new and operator delete in private part,that prevents HeapPreventing objects
	     	from being instantiated as base class parts of heap-based derived class objects.
		(if derived class did not define its own version)
		if derived class defined its own version,then HeapPreventing's methods will not effects
		heap allocating,that means HeapPreventing could be the base class part in a heap-based
		object.
             >  if there is a class which contains HeapPreventing,the heap-based object is allowed,
	     	even HeapPreventing has private new and delete.
		but if the class contains HeapPreventing* and try to allocate memory for it via new,
		that would be fail.

          !!  for requiring heap-based objects,could place destructor in protected zone.  !!
	  !!  for determine whether an object is heap-based,could use track pointer abstract class.  !!
	  !!  there is difficult to has a good way for prohibiting heap-based objects.  !!

  Item 28 : Smart pointers
       	  smart pointers are objects that are designed to look,act,and feel like built-in pointers,but to
	  offer greater functionality.

	  smart pointers'behavior :
	    construction and destruction
	    copying and assignment
	    dereferencing

	  smart pointers are generated from templates because,like built-in pointers,they must be strongle typed;
	  the template parameter specifies the type of object pointed to.

	  Construction,Assignment,and Destruction of Smart Pointers >
	    e.g.
	      template<typename _Type>
	      class SmartPointer {
	      public:
	        explicit SmartPointer(_Type *ptr) = default;
		~SmartPointer()
		{
		  if (_shared == 0)
		    delete ptr;
		  _shared--;
		}

		//  if unique pointer have to transfer ownership in these functions,
		//  then the parameters can not be constant.
		SmartPointer(const SmartPointer<_Type> &obj);
		SmartPointer &operator=(const SmartPointer<_Type> &obj);

		_Type &operator*() const;
		_Type *operator->() const;
	      private:
	        _Type *_internal_ptr;
		static size_t _shared;  //  increase in copy and assignment.
	      }; 

	      template<typename _Type>
	      size_t SmartPointer<_Type>::_shared = 0;

	    !  if the smart pointer is unique pointer,have to transfer the ownership of the object
	       which pointed to.notice that the assignment operator must delete the object it
	       owns before assuming ownership of a new object.
	    !  if the smart pointer is shared pointer,have to maintain the counter which would be
	       shared by all smart pointer object.
	    !  do not passing unique pointer by value!(ownership would be transferred in copying)

	  Implementing the Dereferencing Operators >
	    the dumb pointer has behavior with operator* and operator->,thus,smart pointer must
	    has these behaviors to emulate dumb pointer.

	    _Type &operator*() const
	    {
	      //  do somethings
	      return *_internal_ptr;
	    }
	    !  returns a reference to the object will not create any temporary object,
	       it is more efficiency,and C++ allows base-class reference to refers
	       an derived class object.

	    _Type *operator->() const
	    {
	      //  do somethings
	      return _internal_ptr;
	    }
	    !  operator-> is similar to operator*,whatever the function returns,it must apply
	       to member-selection operator.
	       e.g.
	         pt->func();  //  compiler interpreted this statement to (pt.operator->())->func()

          Testing Smart Pointers for Nullness >
	    smart pointer have to support comparison like dubm pointer :
	      char *x = &a;
	      char *y = &b;

	      SmartPointer<char> pChar1(&a);
	      SmartPointer<char> pChar2(&b);

	      x == y;
	      x < y;
	      x > y;
	      !x;
	      !y;

	      pChar1 == pChar2;
	      pChar1 < pChar2;
	      pChar1 > pChar2;
	      !pChar1;
	      !pChar2;

	    the most simply method to achieve this is define an implicit conversion which convert
	    SmartPointer to void *.
	    void * is built-in type,so C++ supply comparison to it.
	    e.g.
	      operator void*() const
	      {
	        return static_cast<void *>(_internal_ptr);
	      }
	    
	    !  implicit conversion often brings some problems,so programmer have to minimize
	       implicit conversions(just allow expected).

	    another way is to define implicit conversion SmartPointer -> bool type.
	    it suit of comparison.
	    e.g.
	      operator bool() const
	      {
	        return _internal_ptr != nullptr;
	      }

	    the best way is overload operator!,it is useful to test if smart pointer is null.
	    e.g.
	      bool operator!() const
	      {
	        return !_internal_ptr;
	      }  //  this is not implicit conversion,it is operator overloading.

	      if (!sp) {
	        ...
	      } else {
	        ...
	      }  //  such statement has been supported by operator!().
	      	 //  if (sp) ...  still an error  (no such conversion function has been defined)
		 //  if (sp == 0) ... still an error

          Converting Smart Pointers to Dumb Pointers >
	    !  provide implicit conversion to dumb pointers will no longer need to overload
	       operator!,operator void *,operator bool,etc.
	    !  dont provide implicit conversion operators to dumb pointers unless there is a compelling
	       reason to do so.
	       #  the std::unique_ptr class provide a function get() which is used to get the raw pointer.

	    e.g.
	      SmartPointer<char> pc = new char;
	      ...
	      delete pc;

	      //  pc is an object,thus it can not be deleted.
	      //  if there is a implicit conversion from SmartPointer to char *,
	      //  compilers want this function call(operator delete) to succeed,then
	      //  pc will be converted to char *,so,the pointer would be deleted twice.

	      class SmartPointerI {
	      public:
	        SmartPointerI(const char *arg);  //  constructor also a type-conversion operator
              ...
	      };
	      
	      void func(SmartPointerI &arg1, SmartPointerI &arg2);

	      SmartPointer<char> pc1 = new char, pc2 = new char;
	      func(pc1, pc2);
		
	      //  if want func() calls succeed,then compiler have to convert @pc1 and @pc2's type to
	      //  SmartPointerI,suppose implict conversion from SmartPointer to _Type,then
	      //  compiler will convert SmartPointer to _Type at first,convert _Type to SmartPointerI
	      //  at second.
	      //  but that will not success,because the converting sequence contains two user-defined
	      //  conversion functions.

          Smart Pointers and Inheritance-Based Type Conversions >
	    suppose where is an inheritance hierarchy :
	      	    	  Class A	  (TOP,all is "is-a")

		    Class B       Class C
		    
		    Class D

             void func(const SmartPointer<A> &arg);
	     
	     SmartPointer<B> pB = new B;
	     SmartPointer<C> pC = new c;
	     SmartPointer<D> pD = new D;

	     func(pB);	     //  ERROR
	     func(pC);	     //  ERROR
	     func(pD);	     //  ERROR

	     compiler would not compiles these function calls,because there is no conversion had been defined in
	     SmartPointer which lets SmartPointer<B> SmartPointer<C> SmartPointer<D> convert to SmartPointer<A>.

	     in the inheritance hierarchy,if the pointers are dumb pointer,then such converting is no problem.
	     but SmartPointer is an object,not dumb pointer,if no conversion had been defined,compiler can not
	     convert an object of type T1 to another object of type T2.

	     solve method :
	       1>  specialize SmartPointer template for _Type,add conversion to each template specializing.
	       	   (this is the most bad way,programmer have to add a lot of conversions manually)
	       2>  use member template.

	       e.g.1
	         SmartPointer<B>::operator SmartPointer<A>() const;
		 SmartPointer<C>::operator SmartPointer<A>() const;
		 ...

		 //  bad idea

	       e.g.2
	         template<typename _ToConvert>
		 SmartPointer<_Type>::operator SmartPointer<_ToConvert>() const
		 {
		   return SmartPointer<_ToConvert>(_internal_ptr);
		 }

		 //  compiler automatically find out template and instantiate it.
		 //  if the @_internal_ptr is type of _Type and which is able to be
		 //  converted to _ToConvert,then compiler will compiles code.

	       !!  Attention :
	       	     if there is an overload version for func() which is
		       void func(const SmartPointer<B> &arg);
	       	     after added member template for conversion,the following statements
		     will be ambiguity.

		     func(pB);
		     func(pC);

		     because convert @pC to Class B pointer is legal,of course convert it
		     to Class A pointer also legal,so compiler can not find out which
		     func() to be called.

            !  this technique needs compiler supporting member template.
	    !  smart pointers are smart,but they are not pointers.

          Smart Pointers and const >
	    conversions involving const are a one-way street :
	      it is safe to go from non-const to const,but it is not safe to go from const to
	      non-const.
	      furthermore,anything you can do with a const pointer you can do with a non-const
	      pointer,but with non-const pointers you can do other things,too.

	    const with dumb pointer :
	      const char *c;			//  c pointed-to-const-char-object
	      char * const c = &x;		//  const c pointed-to-char-object
	      const char * const d = &x;	//  const c pointed-to-const-char-object

	    const with smart pointer :
	      SmartPointer<const char> c;
	      const SmartPointer<char> c;
	      const SmartPointer<const char> c;

	      !  these three objects are different,if programmer wants to assign an object to another,
	      	 there must be a conversion function is existed.
		 e.g.
		   SmartPointer<char> x(&a);
		   SmartPointer<const char> y(x);  //  convert x to y.

		 #  member template could automatically generate conversion functions,but that is not
		    the best way.

	     inheritance between const and non-const :
	       this method will allows assign non-const object to const object.C++ default apply
	       derived class converts to based class.

	       template<typename _Type>
	       class SmartPointerConst {
	       ...
	       private:
	         const _Type *_internal_const_ptr;
	       };

	       template<typename _Type>
	       class SmartPointer : public SmartPointerConst<_Type> {
	       ...
	       private:
	         _Type *_internal_ptr;
	       };

	       but this way will waste space,because an object which type is SmartPointer will
	       contains @_internal_const_ptr.
	       the structure union could solve this problem.

	       e.g.
	         template<typename _Type>
		 class SmartPointerConst {
		 public:
		   SmartPointerConst<_Type>(_Type *x) : _internal_const_ptr(x) {}
		   ...
		 protected:
		   union {
		     const _Type *_internal_const_ptr;
		     _Type *_internal_ptr;
		   };
		 };

		 template<typename _Type>
		 class SmartPointer : public SmartPointerConst<_Type> {
		 public:
		   SmartPointer<_Type>(_Type *x) : SmartPointerConst<_Type>(x), _internal_ptr(x) {}
		   ...
		 };

          !!  Smart pointers should be used judiciously,but every C++ programmer will find them
	      useful at one time or another.  !!
	  !!  Smart pointers are objects not pointers,but they emulate the behaviors the dumb pointer owns.  !!


  Item 29 : Reference counting
       	  reference counting is a technique that allows multiple objects with the same value to share a 
	  single representation of that value.
	  there are two common motivations for the technique :
	    1>  bookkeeping
	    	(keeping track of an object's ownership is hard work)
            2>  shared object and reference counting
	    	(when an object employs reference counting,it owns itself)
		(no need store object more than once)

          bookkeeping is used in std::unique_ptr,there ownership would be transferred at the time that 
	  operator=(std::unique_ptr<_Type> &&) was called.
	  reference counting is used in std::shared_ptr,there several objects shared single value,and 
	  they maintain a reference counter.

	  as above,implemente reference counting have to maintain a reference counter between several
	  class objects.
	  e.g.
	    class SharedObject {
	    public:
	    ...
	    private:
	      static struct {
	        size_t _reference_counter;
		void _destroyInternalData(void)
		{
		  if (!(--_reference_counter))
		    delete[] _internal_array;
		}
	        char *_internal_array;
	      } _data;

	      /*
	      struct {
	        ...
              } *_data;  //  definition of struct as same as above
	      		 //  use pointer to instead static object
	      */
	    };

	    the private member @data contains a reference counter and an array which is type of char;
	    when copy operation is occured,have to increase @_reference_counter.
	    if an object which is type of SharedObject is going to be destroyed,the destructor have to
	    call @_destroyInternalData;

	    !  nesting a struct in the private part of a class is a convenient way to give access to the 
	       struct to all the members of the class,but to deny access to everybody else.
	    !  the class whose implementation is based on reference-counting should emulate non-reference-counting
	       version,that is if it is possible,should hide details from clients of that class.
	    !  pointer-to-implementation will reduce memory request when program is running,because 
	       this way is dynamically allocate or deallocate memory.
	       static memory can not be deallocate dynamically and longer existed until program exited.

          Copy-on-Write :
	    sharing a value with other objects until we have to write on our own copy of the value.

	    if an object is sharing a value with other and it would like to do write operation on the value,
	    should write to its own copy.(under reference-counting)

	    for implemente copy-on-write,we have to know what interface will be called for write a value,
	    then,deal with copy-on-write in the interface.

	    e.g.
	      const char & ShareObject::operator[](int index) const  //  read-only version
	      {
	        return _data->_internal_array[index];
	      }
	      char & ShareObject::operator[](int index)      	      //  read-write version
	      {
	        if (_data->_reference_counter > 1)  //  copy-on-write,this version maybe called for write
		{
		  --_data->_reference_counter;
		  _data = new value object;
		}
		return _data->_internal_array[index];
	      }

	      !  there is no way for C++ compilers to tell us whether a particular use of operator[] is
	      	 for a read or a write,so we must be pessimistic and assume that all calls to the
		 non-const operator[] are for writes.

          Pointers,References,and Copy-on-Write :
	    Reference-counting and Copy-on-Write will bring this problem :
	      ShareObject s1("hello world");
	      
	      char &r = s1[0];
	      char *p = &s1[1];

	      ShareObject s2 = s1;  //  now s2 and s1 share a value

	      r = 'd';  //  "hello world" => "dello world" <- s1 <- s2
	      *p = 't'; //  "dello world" => "dtllo world" <- s1 <- s2
	      	   	//  these statements have been modified both s1 and s2.

	    !  there is no way the ShareObject copy constructor can detect this problem.

	    sovling methods :
	      1>  ignore.to pretend it does not exist.(bad idea)
	      2>  define them out of existence.put somehing in the documentation that says,more or less,
	      	  "Don't do that.if you do,results are undefined."(not good)
	      3>  use shareable flag.(best)
	      	  add a flag to each class object indicating whether that object is shareable.
		  turn the flag on initially,but turn it off whenever the non-const operator[] is invoked
		  on the value represented by that object.(if the interface maybe write a value,have to turn
		  off the flag when it be called)
		  !  this way will reduce the amount of value sharing between objects.

		  e.g.
		    char &r = s1[0];  //  non-const version was called,flag will be truned off
		    ...
		    ShareObject s2(s1);  //  flag is false,copy-constructor will copy @s1 not sharing.

          A Reference-Counting Base Class :
	    abstract reference-counting as a base class,if the class needs reference-counting functionality,
	    it can inherit the base class.
	    e.g.
	      class RCObject {
	      public:
	        addRef();
		removeRef();
		isShared();
		isShareable();
		makeUnshareable();
		RCObject();
		RCObject(const RCObject &);
		RCObject &operator=(const RCObject &);
              protected:
	        virtual ~RCObject() = 0 {}
	
              private:
	        size_t _ref_counter;
		bool _shareable;
	      };

	      @_ref_counter default value is 0,the creator of the class is referring it,do not need to set
	      @_ref_counter to 1 at the time the object is initializing.
	      @_shareable default value is true,this flag maybe changed to false later if a writing is occurred.
	      removeRef() is a proxy destructor,it will not only decrease @_ref_counter,it also delete @this when
	      @_ref_counter is equal to 0.
	      operator=() will do nothing,because,reference-counter was assigned do not change the number of objects
	      sharing the same value.do nothing is do right thing.
	      protected destructor is used to forbid non-heap-based object been created,because "delete this;" is safely
	      only this pointer is the head of the memory space which had been allocated.

          Automating Reference Count Manipulations :
	    when an object is initialized and which is reference-counting and inherited RCObject,it have to calls 
	    addRef() manually,and calls removeRef() in its destructor,have to call corresponding interfaces anytime
	    anything interesting happens on it.
	    if the value container(inherited RCObject) which is composition of a class and implemented as pimpl,
            then smart-pointer can automatically detects such interesting happens and automatically calls the
	    corresponding interfaces.

	    e.g.
	      class A {
	      public:
	        class AValue : public RCObject {
		...
		};

              private:
	        SmartPointer<AValue> _avalue;
	      };

	      A::A() : _avalue(new AValue) {}

	      virtual A::AValue *A::AValue::virtual_copy_constructor()
	      {
	        return new A::AValue(*this);
	      }  //  supports to the case which virtual copying is required.
	      	 //  derived class can redefine this function for its own version.

	      template<typename _Type>
	      class SmartPointer {
	      ...
	      private:
	        _Type *pointee;
	      };

	      template<typename _Type>
	      SmartPointer<_Type>::SmartPointer(_Type *realP)
	      {
	        proxy_init();
	      }

	      template<typename _Type>
	      SmartPointer<_Type>::SmartPointer(const SmartPointer<_Type> &rhs)
	      {
	        proxy_init();
	      }

	      //  this function is a virtual constructor,which as a proxy to init object.
	      template<typename _Type>
	      static void SmartPointer<_Type>::proxy_init()
	      {
	        if (!pointee)
		  return;
	        if (!pointee->isShareable())
		  pointee = new _Type(*pointee);
		pointee->addRef();
	      }
	      

	      !  suppose there is class named K which is inherited A::AValue,and template parameter
	      	 _Type == A::Value,but pointee is realy points to a K,then the statement :
		   "pointee = new _Type(*pointee);"
		 needs supporting from virtual copy constructor in A::K :
		   "pointee = pointee->virtual_copy_constructor();"

          Putting it All Together :
	    e.g.

	       ShareObject{contains: SmartPointer<AValue>}
	       			     SmartPointer{contains: _Type *pointee -> pointed to Heap Memory}
	       AValue{contains: _data} public inherited RCObject
	       RCObject is a reference-counting class as the base class of others

	    apply the benefits of reference counting to some class which we
	    do not know its source code(object in library) :
	      e.g.
	        
		ShareObject{contains: SmartPointer<the_class_we_want_apply>}
				      SmartPointer{contains: struct CountHolder *counter}
				      CountHolder{contains: _Type *pointee -> pointed to @target} public inherited RCObject

          !!  Reference counting is an optimization technique predicated on the assumption that objects will commonly
	      share values.if this assumption fails to hold,reference counting will use more memory than a more conventional
	      implementation and it will execute more code.  !!
	  !!  reference counting is most useful for improving efficiency under the following conditions :
	        relatively few values are shared by relatively many object.
		object values are expensive to create or destroy,or they use lots of memory.(the values have to be shared)
          !!  use Reference-Counting judiciously.  !!


  Item 30 : Proxy classes
          !  array dimensions must be known during compilation,even operator new.

	  Objects that stand for other objects are often called proxy objects,and the classes
	  that give rise to proxy objects are often called proxy classes!(surrogates)
	  e.g.
	    template<typename _Type, unsigned short columns, unsigned short rows>
	    class Array2D {
	    public:
	      class Array1D {
	      public:
	        _Type &operator[](int index);
		...
              private:
	        _Type _inner_1D[rows];
	      };

	      ...
	      Array1D operator[](int index);
	      ...
	    private:
	      Array1D _inner_proxy_object[columns];
	    };

	    Array2D<char, 3, 5> the_array2d;
	    the_array2d[1][3];  //  -->  (the_array.operator[](1)).operator[](3);  <legal>
	    			//  kept the traditional syntax for multidimensions array
				//  of both C and C++.
				//  the_array(1, 3) a curious syntax it is look like a
				//  function invocation.

	    //  the class Array1D is a proxy class,which represent the one-dimension array
	    //  of the two-dimensions array,but the clients of Array2D will not be aware of
	    //  the existence of the proxy object _inner_proxy_object,which represents a
	    //  one-dimension array in Array2D.

          Distinguishing Reads From Writes via operator[] :
	    lvalue it might be modified,rvalue it can not be modified.
	    !  the function which returns by-value,C++ limits the use of such by-value returns to rvalue
	       contexts only.

	    the main concept for distinguish reads from writes via operator[] that is postpone the
	    stag of determining.in other words,we need not to examine whether operator[] is used for
	    read or write,we can see later the result from operator[] how to be used.
	    proxy class can stands for the object operator[] would returns,after operator[] returned,
	    such a proxy class object will represents the object we really wants accessing to.

	    e.g.
	      class Array {
	      public:
	        class ElementProxy {
		public:
		  ElementProxy(Array &, size_t);
		  ElementProxy &operator=(size_t);
		  ElementProxy &operator=(const ElementProxy &);
		  operator int() const;
		private:
		  Array &_representing;
		  size_t _index;
		};

                friend class ElementProxy;  //  bypass the ElementProxy object accessing the 
		       	     		    //  data in Array object via @_representing.
					    //  i.e. _representing.data->elements[_index]

		...

		ElementProxy operator[](int index)
		{
		  return ElementProxy{*this, index};
		}

		const ElementProxy operator[](int index) const
		{
		  //  returns a const object.
		  //  the calling to const_cast<Array &> is necessary for
		  //  satisfy the constructor of ElementProxy.
		  return ElementProxy{const_cast<Array &>(*this), index};
		}
		//  !!  const ElementProxy object can not calls ElementProxy::operator=
		//      because these functions are not const.(const this pointer)
		//      but such const this pointer is satisfy the requirement
		//      of ElementProxy::operator int() const
	      ...
	      };

          Limitations :
	    proxy have to emulates all the possbile behaviors(legal) of the real object which it is 
	    standing for.
	    e.g.
	      int Object;
	      Proxy<int> p(&Object);
	      p++;
	      int *pointer = &p;	//  if proxy does not defined such behaviors,
	      	  	     		//  these statements will no longer be compiled.

	    if the object the proxy class stands for has some member functions,then for make member function
	    invocation succeed,proxy class have to encapsulates all the member functions inside the object
	    it is standing for.
	    e.g.
	      std::string str1("Hello world");
	      Proxy<std::string> s(&str1);
	      s.c_str();		//  the same named function have to be defined in Proxy.

	    suppose there is a function which requires two char references as its parameters,then,
	    passed two Proxy<char> to it would not be compiled.
	    e.g.
	      void func(char &, char &);

	      ...
	      Proxy<char> pc1(&c1);
	      Proxy<char> pc2(&c2);

	      //  Proxy::operator _Type() has been defined.
	      func(pc1, pc2);  //  would fail.because Proxy::operator _Type() const returns by-value,
	      		       //  C++ refuses to bind reference to temporary object.

	      another :
	      void func2(std::string &);

	      ...
	      Proxy<std::string> ps1(&str1);
	      func2(ps1);  //  would fail.requires convert ps1 to std::string &,but C++ does not 
	      		   //  allow more than one user-defined converting function was invoked in
			   //  sequence.

          !!  use Proxy Classes judiciously.  !!
	  !!  Proxy Classes bring costs of constructor and destructor.  !!
	      
	      
  Item 31 : Making functions virtual with respect to more than one object
       	  C++ supports virtual function,and a virtual function is depend on only one object.if there is
	  a requestion that require a function which behavior depends on its several parameter,C++ virtual
	  function will not satisfy the request.

	  the C++ programmer from the object-oriented programming community know as a virtual function call
	  is termed a "message dispatch".
	  double-dispatch : a call that is virtual on two parameters is implemented through a "double dispatch".
	  multiple-dispatch : a function acting virtual on several parameters.

	  C++ is not directly supports such technique,but allows programmer go to achive it.
	  there are several implement methods for "message dispatch" >

	    Using Virtual Functions and RTTI :
	      RTTI is runtime type identification,for use this technique,have to include header <typeinfo>.
	      RTTI is only supports to the classes they are contain virtual function.
	      typeid() returns a reference refers to the type_info class for its parameter,parameter could
	      be the name of a class or an object of a class.
	      e.g.
	        class Base { virtual void func(); };
	        class A : public Base {};
		class B : public Base {};
		
		A a;
		B b;
		A c;
		
		if (typeid(a) == typeid(c)) ...;	//  TRUE,because @a and @c are same class type
		if (typeid(a) != typeid(b)) ...;	//  FALSE,because @a and @b are not same class type
		if (typeid(a) == typeid(A)) ...;        //  TRUE,@a is type of A

              virtual function is single dispatch,and this tenique shift the burden of generating and 
	      maintaining type-based function calls from programmers to compilers.
	      if the program has been employed RTTI,it will becomes unmaintainable,enhancement of such programs
	      eventually becomes unthinkable.

	      e.g.
	        class BaseClass {
		public:
		  virtual void doSomething(BaseClass &other) = 0;
		  ...
		};

		class DerivedA : public BaseClass {
		public:
		  virtual void doSomething(BaseClass &other);
		  ...
		};

		//  we do not need to check what the type info of *this is,because
		//  this function is virtual defined in DerivedA,*this must be DerivedA object.
		virtual void DerivedA::doSomething(BaseClass &other)
		{
		  const type_info tinfo_other(typeid(other));
		  
		  if (tinfo_other == typeid(BaseClass))
		    //  do something
		  else if (tinfo_other == typeid(*this))
		    //  do something
		  else
		    //  throw exception or report the situation encountered via different way

		  ...
		}

		!  if a new class which inherited BaseClass had been added into the system,
		   each RTTI if-then-else statement(clause) have to handle the new type.
		   that is,maintenance becomes difficult.

	      RTTI is not a good idea for program design at there,but sometimes it will be useful.

            Using Virtual Functions Only :
	      double dispatch require the two objects'types has known.but using RTTI,program will becomes
	      unmaintainable.
	      there is a way to implement double dispatch just use virtual function.
	      the principle is that,if the virtual function represents one dispatch,we can overload it
	      to achieve double dispatch.
	      e.g.
	        class BaseClass {
		public:
		  virtual void doSomething(BaseClass &) = 0;
		  virtual void doSomething(DerivedA &) = 0;
		  virtual void doSomething(DerivedB &) = 0;
		...
		};

		class DerivedA : public BaseClass {
		public:
		  virtual void doSomething(BaseClass &other)
		  {
		    other.doSomething(*this);
		  }


		  virtual void doSomething(DerivedA &other)
		  {
		    //  do something
		  }

		  virtual void doSomething(DerivedB &other);
		...
		};

		class DerivedB : public BaseClass { ... };

		!  inside the overloaded doSomething with BaseClass & as parameter,we just calls to
		   other_type::doSomething(*this),because we have been known the type of *this,it is
		   DerivedA.
		   we do not know what is the type of @other is,but we can calls its doSomething() with
		   *this,a reference refers to DerivedA object.
		   inside other::doSomething(),all two objects'types would be known.
		   this is the implementation for double dispatch through virtual function only.

              disadvantages :
	        1>  if there are several classes in the inheritance hierarchy,then the total number of 
		    virtual functions with its overloading will be 1 + n(1 is the base class,@n is the number
		    of classes under base class)
		    programmer have to overrides these overloadings in each inherited class.
		2>  lost extensibility.
		    if a new class will be added into the hierarchy,then every class have to contains a 
		    new overloading which parameter is new_class_type reference.
		3>  if author try to add new class into system,then it have to modify the class headers
		    and recompile the library.if program had been compiled in static compiling,then program
		    have to be recompile,too.RTTI no recompile request.

            Emulating Virtual Function Tables :
	      there is a way to improve virtual function only method.
	      we has known that C++ compiler do virtual function calling via vtbl,it is an array conceptually.
	      so,we also can do this ourself,that is emulating virtual function tables.
	      (This method conceptually as same as Lisp data-driven design.)

	      class member function pointer :
	        return-type ClassName::(*)(@arguments)
		!  a pointer points to a member object inside a class.
		   member object inside a class maybe a variable object/constant object or member function.
		   member function inside a class is an object,so '&' is used to retrive its address.

		e.g.
		  size_t std::string(*str_member_pointer)(void) = &std::string::length;
		  std::string x;
		  x.*str_member_pointer;
		  (&x)->*str_member_pointer;  //  structure accessing demands the target is an object,
		  			      //  so '*' is used to derefer the member pointer.

	      !  typeid() returns an object which type is type_info,and the member function name() could
	      	 retrive the class name which the type_info object is represeting.
		 (different implementations use different types to encapsulate the class name,it maybe std::string
		 or another type.)

	      std::map from STL can be used to establish mapping between two types.
	      for emulate virtual function table,we can establish mapping between class name and member function pointer.

	      e.g.
	        class BaseClass {
		public:
		  virtual void doSomething(BaseClass &) = 0;
		...
		};

		class DerivedA : public BaseClass {
		public:
		  typedef void (DerivedA::*MemberFunctionPtr)(BaseClass &);	   //  member function pointer
		  typdef std::map<std::string, MemberFunctionPtr> CUSTOMIZE_VTBL;  //  container

		  virtual void doSomething(BaseClass &other)
		  {
		    MemberFunctionPtr calling_entity = lookup(other);
		    if (calling_entity)
		      (this->*calling_entity)(other);
		    else
		      throw ERROR;
		    ...
		  }
		  
		  virtual void PeerIsDerivedA(BaseClass &);	//  these functions will be putted into container
		  virtual void PeerIsDerivedB(BaseClass &);
		  ...

		  static MemberFunctionPtr lookup(BaseClass &);  //  find the calling entity from CUSTOMIZE_VTBL

		  ...
		};

		class DerivedB : public BaseClass { ... };
		class DerivedC : public BaseClass { ... };

              !  RTTI is still needed,but it will be only used in one place where the class name is required,
	      	 there is inside the function lookup().
	         suppose,a new type will be added into the system,we just adjust the @CUSTOMIZE_VTBL and put
		 the handle function into the class which will interact to the new type as well.

            Initializing Emulated Virtual Function Tables : 
	      it is simple,just initialize a std::map object.
	      we can put all the steps into a private function which will initialize the std::map object for us.
	      e.g.
	        CUSTOMIZE_VTBL *DerivedA::initializeMap(void)
	        {
  		  CUSTOMIZE_VTBL *theVtbl = new CUSTOMIZE_VTBL;
		  (*theVtbl)["PeerIsDerivedA"] = &PeerIsDerivedA;
		  (*theVtbl)["PeerIsDerivedB"] = &PeerIsDerivedB;
		  return theVtbl;
	        }

		static DerivedA::MemberFunctionPtr DerivedA::lookup(const BaseClass &peer)
		{
		  static std::unique_ptr<CUSTOMIZE_VTBL> customize_vtbl(initializeMap());
		  //  smart pointer manages the resource.
		  ...
		}

              !  Attention : the type MemberFunctionPtr == void DerivedA::(*)(BaseClass &),
	      	 	     so all the elements will be putted into @CUSTOMIZE_VTBL must be same type,
			     that is none of element which is a function and expected an argument with
			     the type is "DerivedA &".
			     DO NOT EMPLOY reinterpret_cast operator try to cast function type,
			     that will be disaster in MI.
			     if necessary,member function is able to employs dynamic_cast operator to
			     casts the type of its argument for itself.
		   
