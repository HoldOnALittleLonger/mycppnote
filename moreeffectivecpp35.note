Chapter Basics >

  Item 1 : Distinguish between pointers and references
         Pointers use * or -> to indirectly access object
	 References use . to indirectly access object

	 Differences between reference and pointer :
	   1>  reference can not be a NULL reference
	   2>  pointer can be NULL pointer
	   3>  if design does not allow NULL object,then prefer reference,otherwise
	       use pointer.
	       ERROR e.g.
	         char *x = 0;  //  NULL pointer
		 char &y = *x;  //  refer to NULL object
           4>  C++ requires reference must be initialized when declare.
	   5>  no need to test reference if valid before use it.         
	       mut test pointer if valid before use it.
	   6>  pointer is allowed to reassignment,but reference is not allowed.

       !!  you should use a pointer whenever you need to take into account the possibility that
	   there is nothing to refer to or whenever you need to be able to refer to different
	   things at different times.  !!
       !!  you should use a reference whenever you know there will always be an object to refer to
	   and you also know that once you are referring to that object,you will never want to 
	   refer to anything else.
	   you should use a reference when implementing operators whose syntactic requirements make
	   the use of pointers undesirable.in all other cases,stick with pointers.  !!


  Item 2 : Prefer C++ style casts
         the traditional C-style casts'problems :
	   1>  C-style is designed for C,not C++,so that,
	       cast a pointer-to-const-object into a pointer-to-non-const-object and
	       a cast that changes a pointer-to-base-class-object into a pointer-to-derived-class-object
	       is no difference for C-style cast.
	   2>  tranditional C-style cast syntactically consist of little more than a pair of parentheses
	       and an identifier.
	       it belike this :
	         int a = 0;
		 float b = (float)a;
		 float c = float(a);
	       but everywhere in C++ might be parentheses are existed.
	       so there is a question,"Are any casts used in this program?"

	 Use C++-style casts to instead C-style casts :
	   static_cast<type>(expression)
	   dynamic_cast<type>(expression)
	   const_cast<type>(expression)
	   reinterpret_cast<type>(expression)


	   const_cast is used to remove constness of an object,but it is not realy remove it,just
	   make a copy from object and that is constless.
	   const_cast is used to remove volatileness of an object.
	   const_cast is only used for these two purposes.

	   reinterpret_cast is to cast between function pointer types.
	   example :
	     using funcPtr = void (*)();
	     funcPtr funcPtrArray[10];
	     int func1();
	     funcPtrArray[0] = func1;  //  ERROR,func1 has wrong type which is returns int.
	     funcPtrArray[1] = reinterpret_cast<funcPtr>(func1);
				       //  OK.
	   cast for function pointers is not portable!

	 following C++-style casts but compiler is not support :
	   template<typename _Type, typename _EType>
	   _Type static_cast(_EType expression)
	   {
	     return (_Type)(expression);
	   }

	   #define static_cast(TYPE, EXPRESSION) ((TYPE)(EXPRESSION))
	   #define dynamic_cast(TYPE, EXPRESSION) ((TYPE)(EXPRESSION))

	   //  but these functions would not report cast fails.

	 !!  prefer C++ style casts,even they are hard to type or ugly,because that style will improve
	     code readability,and designed for C++ programming.  !!


  Item 3 : Never treat arrays polymorphically
       	 dont mix polymorphism and pointer arithmetic.
	 e.g.
	   void printC(ostream &output, const TheClass Array[], int numElements)
	   {
	     for (unsigned i(0); i < numElements; ++i) {
	       output<<Array[i];
	     }
	   }

	   TheClass Array[10];  //  initialized by default constructor
	   printC(std::cout, Array, 10);  //  there is no polymorphism and pointer arithmetic mixing

	   DerivedTheClass DArray[10];  //  initialized by default constructor
	   printC(std::cout, DArray, 10);  //  there is polymorphism and pointer arithmetic mixing

	   //

	   Array and DArray are arrays one of type TheClass another of type DerivedTheClass.
	   every elements in array is an object,not a object pointer.
	   in the loop which print class contents,for each Array[i],compiler will generates
	   generic code which has form like this :
	     output<<*(Array + i);
		 
	     this form is no problem for TheClass Array,but it is not suit DerivedTheClass array.
	     DerivedTheClass is inherit from TheClass,so its size is greater than TheClass.
	     function printC() receives an array which type is TheClass,so compiler knows the displacement
	     for each elements in the array.
	     if pass an array type of DerivedTheClass,displacement between DerivedTheClass objects is not
	     same as displacement between TheClass objects.
	     this is problem!

	   not only loop would arise such problem,and "delete[] @array" will also bring the problem.
	   for delete an array contains class object,C++ have to calls every element's destructor,
	   that is a loop alike above.

	   the true way to use polymorphism in array :
	     TheClass *pArray[10];  //  initialize every pointer point to a DerivedTheClass object.

	     pointer point to TheClass is no difference with pointer point to DerivedTheClass.
	     be there,pointer arithmetic will do "*(pArray + i * sizeof(void *))",on x86,pointer
	     has length 8 bytes.

	     there is not real class object in the array,just pointer objects.
	     
	     note : 
	       if object is not from new,then can not delete it.
	       at above,the class object only destructed when program exit.
	       at above,if the class object is from new and assign address to the element in array,
	       have to manually delete every allocated memory where the class object be.

	     another discussion :
	       TheClass **pArray(new TheClass*[10]);
	       pArray[0] = new TheClass;
	       ...
	       pArray[9] = new TheClass;

	       delete[] pArray;  //  what happens ?
	       			 //  every element in pArray is a pointer point to TheClass object.
				 //  delete[] pArray,recycle all resources this pointer array occupied.
				 //  for delete pArray,have to delete every element in array at first.
				 //  delete pArray[0] will cause a call to TheClass::~TheClass() .
				 //  delete pArray[i] will cause a call to (*(pArray[i])).TheClass::~TheClass() .


           !!  do not mix polymorphism with pointer arithmetic.that would not bring
	       expected behaviors.  !!


  Item 4 : Avoid gratuitous default constructors
         a default constructor is the C++ way of saying you can get something for nothing.
	 a class lack a default constructor,its use may be problematic in three contexts :
	   1>  creation of arrays.
	       when create an array of type is such class which is lack default constructor,
	       that will failed.
	       e.g.
	         A array[10];  //  ERROR,every element has to be initialized by default constructor
		 A *pA = new A[10];  //  ERROR

	       there are three ways to get around this restriction :
	         >  declare and initialize.
		    e.g.
		      A array[2] = {A(3), A(4)};
		    but this way is not apply to heap array.
		 >  use an array of pointers instead of an array of objects.
		    this is apply to head array.
		    e.g.
		      A *pArray[10];
		      for (int i(0); i < 10; ++ i)
		        pArray[i] = new A(i);

	            but there are two disadvantages to this approach.
		    first :
		      have to remember to delete all the objects pointed to by the array.
		    second :
		      the total amount of memory increases,memory amount = pointers + objects.

		 >  to privent the space penalty,use the raw memory for the array :

		      void *pArray = operator new[] (10 * sizeof(A));  //  allocate object memory space(raw memory)
		      A *pA = static_cast<A*>(pArray);
		      for (int i(0); i < 10; ++i)
		        new (pA + i) A(i);      //  placement new.

		      there is no need to save pointers in an array.

		 this technique allows to create arrays of objects when a class lacks a default constructor;
		 it does not show how to bypass required constructor arguments.

		 for method 2,have to delete pointer manually.
		 for method 3,have to call destructor on each object in memory units at first,then delete raw memory.
		 !  do not call "delete[] pA;" for method 3,because pointer pA is not from new.(undefined behavior)

	   2>  ineligible for use with many template-based container classes.
	       that is because it is a common requirement for such templates that the type
	       used to instantiate the template provide a default constructor.
	       this requirement almost always grows out of the fact that inside the template,
	       an array of the template parameter type is being created.
	       e.g.
	         template<typename T>
		 class A {
		 public:
		   A(int size)
		   {
		     Data = new T[size];  //  if T is lack default constructor,this is an ERROR
		   }
		 private:
		   T *Data;
		 };

	       !  careful template design can eliminate the need for a default constructor,for example,
	       	  std::vector has no requirement that its type parameter have a default constructor.
		  but not all containers alike vector.

         virtual base classes lacking default constructors are a pain to work with :
	   the arguments for virtual base class constructors must be provided by the most derived class
	   of the object being constructed.
	   as a result,a virtual base class lacking a default constructor requires that all classes derived
	   from that class - no matter how far removed - must know about,understand the meaning of,and provide
	   for the virtual base class's constructors' arguments.

	   e.g.
	     class A {
	     public:
	       A(int x);
	     };

	     class B : virtual public A {
	     public:
	       B(int x, int y) : A(y)
	       {
	         ...
	       }
	     };

	     class C : public B {
	     public:
	       C(int x, int y, int z) : B(x, y), A(z)  //  C have to know and understand A's constructors' argument.
	       {
	         ...
	       }
	     }

	 !!  some people belive all classes should have default constructor even it does not have enough information to
	     fully initialize objects of that class.but inclusion of meaningless default constructors affects the 
	     efficiency of classes,too.code have to test to see if fields have truly been initialized,and have to handles
	     the case where the tests fail.of course,these bring code bloat.  !!
	 !!  default value to constructor could get behavior like default constructor.but the default value maybe still
	     meaningless,because the information used to create a class should from outside.
	     this method also confuse to other member functions.  !!


Chapter Operators >

  Item 5 : Be wary of user-defined conversion functions
       	 C allows implicit type conversions such char -> int or short -> double.
	 but covert a type double to short will lose information,etc.
	 C++ inherited C' attribute,so such conversions are included in C++.
	 (implicit type conversion,compiler does not report)

	 Two kinds of functions allow compilers to perform such conversions :
	   single-argument constructors
	   implicit type conversion operators

	   A single-argument constructor is a constructor that may be called with only one argument,
	   that is,the constructor is declared receives one argument,or more than one argument but
	   the argument after the first has a default value.
	   e.g.
	     struct A {
	       A(int x);		//  allows int -> A
	       A(float x, int y = 0);	//  allows float -> A
	     };

	   An implicit type conversion operator is simply a member function with a strange-looking name :
	   the word operator followed by a type specification.and can not specify a type for the function's
	   return value.
	   e.g.
	     struct A {
	       operator int();
	     };

	 the fundamental problem is that such functions often end up being called when neither want nor expect them to be.
	 e.g.
	   struct A {
	     operator int() const;
	   };

	   A a;
	   cout<<a;

	   //  there is no suit operator<< function to be called,so that should fails.
	   //  but compiler seen no suit operator<< function,then try to implicit type conversion to make
	   //  the invocation success.
	   //  so compiler convert a to int,because "operator int()" is defined.
	   //  but this is not a expected behavior.

	 so,these functions,their presence can lead to wrong function being called.

	 solution :
	   replace the operators with equivalent functions that do not have the syntactically magic names.
	   e.g.
	     struct A {
	       int asInt() const;  //  replace operator int()
	     };

	   this would insist explicit calling to do type conversion.

	   in most cases,the inconvenience of having to call conversion functions explicitly is more than
	   compensated for by the fact that unintended functions can no longer be silently invoked.

         another problem is single-argument constructors will be used as type conversion functions implicitly.
	 solutions :
	   1>  use "explicit" keyword.
	       e.g.
	         struct A {
		   explicit A(int x);
		   A operator+(const A &lhs, const A &rhs);
		 };

		 forbit compiler calls the function implicitly,just allows programer calls it explicitly.

		 A a(10);  //  OK
		 A b = a + 3;  //  ERROR,no suit operator+ and impilicit type conversion from int to A had been
		       	       //  forbidden.

		 //  A b = a + static_cast<Array<int> >(3); is still valid.
		 
		 !  expiclit keyword apply to a copy-constructor will forbids pass class object as function parameter or
		    return by value from function.

	   2>  use proxy class.
	       e.g.
	         template<typename T>
		 class Array {
		 public:
		   class ArraySize {
		   public:
		     ArraySize(int numElements) : theSize(numElements) {}
		     int size() const { return theSize; }
		   private:
		     int theSize;
		   };

		   Array(int lowBound, int highBound);
		   Array(ArraySize size);
		   ...
		 };

		 there is a rule followed by compiler when compiler try type conversion,that is :
		   a sequence of functions to be called for type conversion can only has one user-defined function.
		 
		 design class with the rule is able to disable implicit type conversion,like above.

		 Array<int> a(10);  //  Array<int> takes an ArraySize object as argument to construct object.
		 	    	    //  compiler found there is a way to construct ArraySize object via int value,
				    //  then it does this calling: Array<int>::ArraySize(10);
				    //  and use the ArraySize object to construct Array object.
				    //  OK

		 Array<int> b(10);  // OK

		 a == b[3];  //  ERROR
		      	     //  b[3] returns a value of int or a reference to int object.
			     //  for calls operator== ,there needs two Array objects,so compiler try to covert
			     //  int to Array.
			     //  the sequence is : calls Array<int>::ArraySize(10),returns tempArraySize,
			     //                    calls Array<int>(tempArraySize),returns tempArray.
			     //  but this sequence contains two user-defined functions,so it is violate the rule.

	       proxy class actually a specific instance of a more generial technique.
	       the proxy class ArraySize just used for conjure Array object up,each ArraySize object stands for
	       a Array object.


	 !!  proxy objects can give you control over aspects of your software's behavior,at above,it is 
	     implicit type conversion.  !!
	 !!  granting compilers license to perform implicit type conversions usually leads to more harm than godd,
	     so do not provide conversion functions unless you are sure you want them.  !!


  Item 6 : Distinguish between prefix and postfix forms of increment and decrement operators
       	 In C,prefix form of the increment operator is sometimes called "increment and fetch",
	 postfix form is often known as "fetch and increment".

	 C++ allows overload prefix/postfix increment/decrement.
	 for distinguish prefix from postfix,when write a postfix overload function,it takes a int parameter but
	 no real name,this can prevent compiler issue a warning that unused variable.
	 e.g.
	   struct A {
	     int x;
	     A &operator++()  //  prefix
	     {
	       ++x;
	       return *this;
	     }
	     const A operator++(int)  //  postfix
	     {
	       A tempA = *this;
	       ++(*this);
	       return tempA;
	     }
	   };

	 the reasons that prefix returns reference and postfix returns const object :
	   prefix is "increment / decrement and fetch",this means function have to increment/decrement *this at first,then
	   return it.
	   but why postfix returns const object?
	   if it returns reference as same as prefix,then there is
	     A a;
	     a++++;  //  this is conflict to built-in type.
	     	     //  int x; x++++;  is ERROR
           and postfix is "fetch and do something",that means retrive object at first then do something on original object.
	   
	   if it returns object but no const,then there is
	     A a;
	     a++++;  //  built-in type did not allow such form.
	     	     //  and it would not do something expected by client.
		     //  it would not increase a twice,
		     //  first,increase *this,
		     //  second,increase tempA.
           const object could prevent such calling,because tempA is const,can not increase it.

	   !  A good rule to follow then designing classes is when in doubt,do as the intS do,and the intS most certainly
	      do not allow double application of postfix increment.

         at above,the implementation of postfix is depends on prefix.because,at most times,postfix is behave alike prefix,
	 except the return type.thus,let postfix depends on prefix,that allow programmer just maintain prefix as well,postfix
	 depends on prefix.

	 !!  prefix operators has different semantics to postfix operators.for distinguish the form of prefix to postfix,the postfix
	     should take a no name parameter.  !!
	 !!  prevent double application of postfix operators on a object.that would not get expected behavior.  !!
	 !!  when dealing with user-defined types,prefix operators should be used whenever possible,because it is inherently more
	     efficient.  !!
	 !!  let postfix operators depend on prefix operators,that allows programmer just maintain prefix version as well,postfix
	     will automatically behave in a consistent fashion.(except return type).  !!


  Item 7 : Never overload &&, ||, or , .
         C and C++ employs short-circuit evaluation of boolean expressions.
	 this means that once the truth or falsehood of an expression has been determined,evaluation of the expression
	 ceases,even if some parts of the expression have not yet been examined.
	 e.g.
	   char *p;
	   ...
	   if (p != 0 && strlen(p) > 10)
	   ...

	   //  if p == nullptr,then,this short-circuit evaluation has value false,
	   //  strlen(p) would not be evaluated.of course,pass a nullptr to strlen() is wrong.

	 if overload && and || ,then the example is look like this :
	   if (operator&&(p != 0, strlen(p) > 10))  //  operator&& as global overload
	   ...

	 it becomes a function call,but function call semantics differ from short-circuit semantics in
	 two crucial ways.
	   first>  when a function call is made,all parameters must be evaluated,so when calling the functions
	   	   operator&& and operator||,both parameters are evaluated.
		   that is,there is no short-circuit.
	   second> the language specification leaves undefined the order of evaluation of parameters to a function call,
	   	   so there is no way of knowing whether expression1 or expression2 will be evaluated first.

	 as result,if overload && or ||,there is no way to offer programmers the behavior they both expect and have come
	 to depend on.

	 comma operator :
	   int a = 0, b = 3;
	   b = 3, a = a + 1 + b;

	   just as there are rules in C++ defining how && and || behave for built-in types,there are rules defining how
	   the comma operator behaves for such types.
	   an expression containing a comma is evaluated by first evaluating the part of the expression to the left of 
	   the comma,then evaluating the expression to the right of the comma;the result of the overall comma expression
	   is the value of the expression on the right.

	 if write operator, as a non-member function,you will never be able to guarantee that the left-hand expression is
	 evaluated before the right-hand expression.(it becomes a function call)
	 if write operator, as a member function,even here,it is can not rely on the left-hand operand to the comma
	 operator being evaluated first,because compilers are not constrained to do things that way.

	 as result,do not overload comma operator.

	 !!  overload operator the purpose is to make programs easier to read,write,and understand.
	     if you do not have a good reason for overloading an operator,do not overload it.
	     in the case of &&, ||, and , ,it is difficult to have a good reason,because no matter how hard
	     you try,you can not make them behave the way they are supposed to.  !!


  Item 8 : Understand the different meanings of new and delete
       	 new behave like this two fold :
	   >  allocates enough memory to hold an object of the type requested.
	   >  calls a constructor to initialize an object in the memory that was allocated.

	 programmer can not changes its behavior,just only be able to determine how the memory for an object is
	 allocated.

	 when programmer calls new to create heap-based object :
	   std::string *str = new std::string("test");

	   compiler probably creates such code :
	     void *tempP = operator new(sizeof(std::string));
	     calls std::string's constructor on tempP.
	     std::string *str = static_cast<std::string *>(tempP);

	   notice that the second step above involves calling a constructor,something you,a mere programmer,
	   are prohibited from doing.
	   programmer can not directly call the constructor necessary to initialize the object.(for heap-based object)

         if you holds some raw heap memory,and want to construct an object in the memory,could use palcement new :
	   #include <new>

	   void *tempP = operator new(sizeof(std::string));
	   std::string *str = new (tempP) std::string("test");

	   //  it looks like this :
	   void *operator new(size_t, void *location)
	   {
	     return location;
	   }

	 if you want to allocate memory and call constructor on it,use "new" statement.
	 if you just want to allocate memory only,use "operator new" statement.
	 if you want to construct an object in memory you have already got a pointer to,use "placement new" statement.
	 operator new and placement new could be overloaded.

	 deletion and memory deallocation :
	   the function operator delete is to the built-in delete operator as operator new is to the new operator.
	   when programmer delete an object,compiler mighe generate such code :

	     std::string *str = new std::string;

	     delete str; {
	       str->~std::string();   //  call destructor at first,
	       operator delete(str);  //  call operator delete function at second.
	     }

	   if you want to deal only with raw memory,you should bypass the new and delete operators entirely.
	   e.g.
	     void *buffer = operator new (sizeof(char) * 30);
	     operator delete(buffer);

	   do not call delete on a pointer which is returned by placement new,because nobody knows where the pointer
	   from.just undo the effect of the constructor by explicitly calling the object's destructor.	 
	   e.g.
	     std::string *str = new (buffer) std::string("test");
	     str->~std::string();

	 Arrays :
	   when create an array contains some objects,operator new[] would be called.(array new)
	   of course,operator new[] also could be overloaded.(if compiler does not support operator new[],then all
	   memory allocation is through operator new,in the case,do not overload operator new as well)

	   the new operator,for arrays,a constructor must be called for each object in the array,when the delete operator
	   is used on an array,it calls a destructor for each array element and then calls operator delete[] to deallocate
	   the memory.
	   e.g.
	     std::string *strArray = new std::string[10];
	     delete[] strArray;

	   operator delete [] is also could be overloaded,just like operator new [].(has some restrictions)

	 !!  when you think about customizing the behavior of the new and delete operators,remember that,you can not really
	     do it.you can modify how they do what they do,but what they do is fixed by the lanaguage.  !!  
	 !!  must pair new and delete,new[] and delete[].do not mix them.  !!


Chapter Exceptions >

  Item 9 : Use destructors top prevent resource leaks
       	 C++ from C,and of course,it supports error code returning.
	 but the difference between error code and exception,that is,exception can not be ignored.
	 when an exception was thrown,then program have to catch it,if it not,the default action is stop program.
	 where the exception is thrown,the statements after would be skipped,then resouce leaks risk is come in.
	 e.g.
	   void do_something(void)
	   {
	     for (int i = 0; i < 10; ++i) {
	       int *intPointer = createInt(i);
	       delete intPointer;
	     }
	   }

	   if function createInt() throw an exception,then the statements after call point would be skipped,
	   because do_something() does not catch the exception,so it will propagates to its caller.
	   statement "delete intPointer;" will be skipped,resouce leaks happens.

	   a good resolution is use smart pointer,follow RAII rule.
	   destructor always be called if the object's lifetime is end,be there,that is leave the loop scope.

	   void do_something(void)
	   {
	     for (int i = 0; i < 10; ++i) {
	       std::unique_ptr<int> intPointer(createInt(i));
	     }
	   }

	   //  destructor of std::unique_ptr will be called if intPointer encountered death.

	 C++ exception cause stack unwinding.this is behavior that C programmers can approach only by using setjmp
	 and longjmp,but longjmp exhibits a serious deficiency when used with C++ :
	   it fails to call destructors for local objects when it adjusts the stack.

	 !!  for prevent resource leak,should follow RAII rule,use smart pointer to instead raw pointer.  !!


  Item 10 : Prevent resource leaks in constructors
       	  what would happens if exception is thrown in constructor?
	  example :
	    struct A {
	      int *a;
	      int *b;
	      A()
	      {
	        a = createInt(10);  //  maybe throw
		b = createInt(11);  //  maybe throw
	      }

	      ~A()
	      {
	        delete a;
		delete b;
	      }
	    };

	    if a had been assigned,and exception is thrown when create b,then resouce leaks happen.

	  C++ refuse to call destructor on a not fully constructed object.an object is fully constructed if its constructor
	  had been completed.
	  e.g.
	    int main(void)
	    {
	      A testa;
	      return 0;
	    }
	    //  if exception is propagated from A::A(),then it is not fully constructed,its destructor would never be called.
	    //  the resource of A::a points to will leak forever.

	  to solve such problem,should do some clean up manully before exception propagates,that is :
	    A()
	    {
	      try {
	        a = createInt(10);
		b = createInt(11);
	      } catch(...) {
	      	delete a;  //  clean a
		delete b;  //  clean b
		throw;
	      }
	    }

	    C++ allows delete a nullptr.
	    because destructor does something as cleanup code,so there could prevent code duplication.
	      void A::private::cleanup()
	      {
	        delete a;
		delete b;
	      }

	      void A::~A()
	      {
	        cleanup();
	      }

	  there is another problem occur when pointer is const :
	    struct A {
	      ...
	      int const *a;
	      int const *b;
	    };

	    such pointer is able to be initialized only in member-initialize list.
	      A() : a(new int), b(new int) { ... }

	    but member-initialize list only allows expressions,can not place try-catch block be there.

	    as above,propagates an exception before cleanup executing,but cleanup have to be executed in try-catch block,
	    so place calling where in a help function,then let the expression invoke them.
	    e.g.
	      int *A::creatA(void)
	      {
	        int *x(new int);
		return (x) ? x : 0;
	      }

	      int *A::creatB(void)  //  because b is initialized after a has been initialized,so place try-catch in it.
	      {
	        int *x(nullptr);
		try {
		  x = new int(&x);
		} catch(...) {
		  delete a;
		  throw;
		}
		return x;
	      }

	      A() : a(creatA), b(creatB) { }

	      !  this method could deal with such problem,but it will reduce readability of code.so do not recommend.
	      !  creatA and creatB as a part of construcotr but separated.

	    a more useful method is use smart pointer.
	    e.g.
	      struct A {
	        const std::unique_ptr<int> a;
		const std::unique_ptr<int> b;
		A() : a(creatInt()), b(creatInt()) { ... }
		...
	      };

	      if exception is throw out when initializing A::a,then no resouce have to be destroyed.
	      if exception is throw out when initializing A::b,then resource of A::a have to be destroyed,but by the time,
	      A::a had been constructed completly,so the destructor of std::unique_ptr<int> would be called,it is fully
	      constructed object.

	  !!  as summary,the best way to prevent resouce leaks in constructor is use C++ smart pointer,follow RAII rule.  !!
	  !!  C++ refuses call destructor on a non-fully constructed object,because delete a nullptr is no sence.  !!
	      

  Item 11 : Prevent exceptions from leaving destructors
       	  There are two situations in which a destructor is called.
	    1>  when an object is destroyed under "normal" conditions.
	    2>  when an object is destroyed by the exception-handling mechanism during the stack-unwinding part of
	    	exception propagation.

          an exception may or may not be active then a destructor is invoked,but there is no way to distinguish these in
	  destructor.
	  so should always assume that an exception is active,because if control leaves a destructor due to an exception
	  while another exception is active,C++ calls the terminate function.

	  the second reason why it is bad practice to allow exceptions to propagate out of destructors :
	    if an exception is thrown from a destructor and is not caught there,that destructor won't run to completion.
	    if the destructor doesn't run to completion,it won't do everything it is supposed to do.

	  e.g.
	    struct A {
	      A()
	      {
	        dosomething();
	      }

	      ~A()
	      {
	        try {
		  doSomething();
		} catch(...) {}
	      }
	    };

	    //  if A::~A() was called because stack unwinding,and if might doSomething() throw an exception,
	    //  for prevent two exceptions is alive,have to prevent the exception leave A::~A().
	    //  there is just catch it but do nothing,all purpose is that do not let exception throw by doSomething()
	    //  leave A::~A().

	  !!  there are two good reasons for keeping exceptions from propagating out of destructors :
	        >  it prevents terminate from being called during the stack-unwinding part of exception propagation.
		>  it helps ensure that destructors always accomplish everything they are supposed to accomplish.
          !!


  Item 12 : Understand how throwing an exception differs from passing a parameter or calling a virtual function
          you can pass both function parameters and exceptions by value,by reference,or by pointer,however,there is
	  quite different.
	  e.g.
	    f(arg);
	    f(arg *);
	    f(arg &);

	    catch(arg);
	    catch(arg *);
	    catch(arg &);

	  when pass a parameter to function do a function invocation,the control would eventually returns to the call site.
	  but throw an exception,control will not return to throw site.
	  while catch an exception,regardless of whether it is passed by value or by reference,a copy will be made and pass
	  to catch clause.
	  e.g.
	    struct A {}
	    void func(A &x);
	    void func2()
	    {
	      A localA;
	      func(localA);
	      throw localA;  //  a copy of localA would be made.
	    } 	    	     //  when control leaves func2(),localA would be destructed,so copy is necessary.

	  C++ specifies that an object thrown as an exception is copied.
	  the copying occurs even if the object being thrown is not in danger of bing destroyed.
	  e.g.
	    void func2()
	    {
	      static A localA;
	      func(localA);
	      throw localA;  //  still a copy would be made.
	    }

	    //  even the exception is caught by reference,it can not modify the original object.

	  the mandatory copying of exception objects helps explain another difference between parameter passing and throwing an
	  exception: the latter is typically much slower than the former.
	  //  calls copy constructor to made copy.

	  attention :
	    the copy constructor in the class would be called is corresponding to the object's static type,not its dynamic type.
	    (inheritence will bring dynamic type)
	    //  in C++,copying is always based on an object's static type.

	  propagate an exception from catch block has two formats :
	  e.g.
	    {
	      throw derivedClass{};
	    }

	    catch (baseClass &w) {
	      ...
	      throw;
	    }  //  no copy made,even it is caught by a baseClass reference.
	    catch (baseClass &w) {
	      ...
	      throw w;
	    }  //  has copy made,a new exception is thrown,its type always be baseClass,because w's static type is baseClass.

	    first catch block just rethrow the exception but dont care about what its type is.(more efficient)
	    second catch block throw a new exception.

	 ! passing a temporary object to a non-const reference parameter is not allowed for function calls,but it is for exceptions.	  
	 ! if throw exception by value,then two copying would be made,one is temporary object,another is the parameter in catch clause.
	   (throw exception by value will always one more copying be made than pass value to function parameter)

	 exception is thrown by-pointer :
	   when throw an exception by-pointer,a copy of the pointer would be made,it as same as pass pointer to function.
	   so,dont let the pointer point to a local object(in the case throw an exception by-pointer)

	 no type conversions are applied to exception.
	 catch block specify the type of exception which expect to catch.so an exception is type of int,would not be caught by a
	 catch block which expect catch an exception is type of double.then the exception would propagated to next.
	 //  exception by-pointer only be caught by catch block which expect an exception by-pointer.

	 but there is some special cases :
	   1>  inheritance-based conversions.(baseClass->derivedClass)
	   2>  from a typed to an untyped pointer.(char *->void *)

	 the final difference between passing a parameter and propagating an exception is that catch clauses are always tried 
	 in the order of their appearance :
	   try {
	     ...
	   } catch (baseClass &x) { }
	     catch (derivedClass &x) { }

	   the first catch block catch an exception is type of baseClass reference,will catches all derivecClass exceptions,even
	   a catch block which expect such derivedClass exception and associated with a same try block!

	   //  this strategy is differ to virtual function invocation.
	   //  virtual function call strategy : best fit
	   //  exception handling strategy : first fit

	 !!  never put a catch clause for a base class before a catch clause for a derived class.  !!
	 !!  there are three primary ways in which passing an object to a function or using that object to invoke a virtual
	     function differs from throwing the object as an exception >
	       first : exception objects are always copied.(by-value,twice copied)
	       second : objects thrown as exceptions are subject to fewer forms of type conversion than are objects passed
	       	      	to functions.
	       three : catch clauses are examined in the order in which they appear in the source code,and the first one
	       	       that can succeed is selected for execution.
         !!
	    



	    