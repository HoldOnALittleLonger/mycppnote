Chapter Basics >

  Item 1 : Distinguish between pointers and references
         Pointers use * or -> to indirectly access object
	 References use . to indirectly access object

	 Differences between reference and pointer :
	   1>  reference can not be a NULL reference
	   2>  pointer can be NULL pointer
	   3>  if design does not allow NULL object,then prefer reference,otherwise
	       use pointer.
	       ERROR e.g.
	         char *x = 0;  //  NULL pointer
		 char &y = *x;  //  refer to NULL object
           4>  C++ requires reference must be initialized when declare.
	   5>  no need to test reference if valid before use it.         
	       mut test pointer if valid before use it.
	   6>  pointer is allowed to reassignment,but reference is not allowed.

       !!  you should use a pointer whenever you need to take into account the possibility that
	   there is nothing to refer to or whenever you need to be able to refer to different
	   things at different times.  !!
       !!  you should use a reference whenever you know there will always be an object to refer to
	   and you also know that once you are referring to that object,you will never want to 
	   refer to anything else.
	   you should use a reference when implementing operators whose syntactic requirements make
	   the use of pointers undesirable.in all other cases,stick with pointers.  !!


  Item 2 : Prefer C++ style casts
         the traditional C-style casts'problems :
	   1>  C-style is designed for C,not C++,so that,
	       cast a pointer-to-const-object into a pointer-to-non-const-object and
	       a cast that changes a pointer-to-base-class-object into a pointer-to-derived-class-object
	       is no difference for C-style cast.
	   2>  tranditional C-style cast syntactically consist of little more than a pair of parentheses
	       and an identifier.
	       it belike this :
	         int a = 0;
		 float b = (float)a;
		 float c = float(a);
	       but everywhere in C++ might be parentheses are existed.
	       so there is a question,"Are any casts used in this program?"

	 Use C++-style casts to instead C-style casts :
	   static_cast<type>(expression)
	   dynamic_cast<type>(expression)
	   const_cast<type>(expression)
	   reinterpret_cast<type>(expression)


	   const_cast is used to remove constness of an object,but it is not realy remove it,just
	   make a copy from object and that is constless.
	   const_cast is used to remove volatileness of an object.
	   const_cast is only used for these two purposes.

	   reinterpret_cast is to cast between function pointer types.
	   example :
	     using funcPtr = void (*)();
	     funcPtr funcPtrArray[10];
	     int func1();
	     funcPtrArray[0] = func1;  //  ERROR,func1 has wrong type which is returns int.
	     funcPtrArray[1] = reinterpret_cast<funcPtr>(func1);
				       //  OK.
	   cast for function pointers is not portable!

	 following C++-style casts but compiler is not support :
	   template<typename _Type, typename _EType>
	   _Type static_cast(_EType expression)
	   {
	     return (_Type)(expression);
	   }

	   #define static_cast(TYPE, EXPRESSION) ((TYPE)(EXPRESSION))
	   #define dynamic_cast(TYPE, EXPRESSION) ((TYPE)(EXPRESSION))

	   //  but these functions would not report cast fails.

	 !!  prefer C++ style casts,even they are hard to type or ugly,because that style will improve
	     code readability,and designed for C++ programming.  !!


  Item 3 : Never treat arrays polymorphically
       	 dont mix polymorphism and pointer arithmetic.
	 e.g.
	   void printC(ostream &output, const TheClass Array[], int numElements)
	   {
	     for (unsigned i(0); i < numElements; ++i) {
	       output<<Array[i];
	     }
	   }

	   TheClass Array[10];  //  initialized by default constructor
	   printC(std::cout, Array, 10);  //  there is no polymorphism and pointer arithmetic mixing

	   DerivedTheClass DArray[10];  //  initialized by default constructor
	   printC(std::cout, DArray, 10);  //  there is polymorphism and pointer arithmetic mixing

	   //

	   Array and DArray are arrays one of type TheClass another of type DerivedTheClass.
	   every elements in array is an object,not a object pointer.
	   in the loop which print class contents,for each Array[i],compiler will generates
	   generic code which has form like this :
	     output<<*(Array + i);
		 
	     this form is no problem for TheClass Array,but it is not suit DerivedTheClass array.
	     DerivedTheClass is inherit from TheClass,so its size is greater than TheClass.
	     function printC() receives an array which type is TheClass,so compiler knows the displacement
	     for each elements in the array.
	     if pass an array type of DerivedTheClass,displacement between DerivedTheClass objects is not
	     same as displacement between TheClass objects.
	     this is problem!

	   not only loop would raise such problem,and "delete[] @array" will also bring the problem.
	   for delete an array contains class object,C++ have to calls every element's destructor,
	   that is a loop alike above.

	   the true way to use polymorphism in array :
	     TheClass *pArray[10];  //  initialize every pointer point to a DerivedTheClass object.

	     pointer point to TheClass is no difference with pointer point to DerivedTheClass.
	     be there,pointer arithmetic will do "*(pArray + i * sizeof(void *))",on x86,pointer
	     has length 8 bytes.

	     there is not real class object in the array,just pointer objects.
	     
	     note : 
	       if object is not from new,then can not delete it.
	       at above,the class object only destructed when program exit.
	       at above,if the class object is from new and assign address to the element in array,
	       have to manually delete every allocated memory where the class object be.

	     another discussion :
	       TheClass **pArray(new TheClass*[10]);
	       pArray[0] = new TheClass;
	       ...
	       pArray[9] = new TheClass;

	       delete[] pArray;  //  what happens ?
	       			 //  every element in pArray is a pointer point to TheClass object.
				 //  delete[] pArray,recycle all resources this pointer array occupied.
				 //  for delete pArray,have to delete every element in array at first.
				 //  delete pArray[0] will cause a call to TheClass::~TheClass() .
				 //  delete pArray[i] will cause a call to (*(pArray[i])).TheClass::~TheClass() .


           !!  do not mix polymorphism with pointer arithmetic.that would not bring
	       expected behaviors.  !!


  Item 4 : Avoid gratuitous default constructors
         a default constructor is the C++ way of saying you can get something for nothing.
	 a class lack a default constructor,its use may be problematic in three contexts :
	   1>  creation of arrays.
	       when create an array of type is such class which is lack default constructor,
	       that will failed.
	       e.g.
	         A array[10];  //  ERROR,every element has to be initialized by default constructor
		 A *pA = new A[10];  //  ERROR

	       there are three ways to get around this restriction :
	         >  declare and initialize.
		    e.g.
		      A array[2] = {A(3), A(4)};
		    but this way is not apply to heap array.
		 >  use an array of pointers instead of an array of objects.
		    this is apply to head array.
		    e.g.
		      A *pArray[10];
		      for (int i(0); i < 10; ++ i)
		        pArray[i] = new A(i);

	            but there are two disadvantages to this approach.
		    first :
		      have to remember to delete all the objects pointed to by the array.
		    second :
		      the total amount of memory increases,memory amount = pointers + objects.

		 >  to privent the space penalty,use the raw memory for the array :

		      void *pArray = operator new[] (10 * sizeof(A));  //  allocate object memory space(raw memory)
		      A *pA = static_cast<A*>(pArray);
		      for (int i(0); i < 10; ++i)
		        new (pA + i) A(i);      //  placement new.

		      there is no need to save pointers in an array.

		 this technique allows to create arrays of objects when a class lacks a default constructor;
		 it does not show how to bypass required constructor arguments.

		 for method 2,have to delete pointer manually.
		 for method 3,have to call destructor on each object in memory units at first,then delete raw memory.
		 !  do not call "delete[] pA;" for method 3,because pointer pA is not from new.(undefined behavior)

	   2>  ineligible for use with many template-based container classes.
	       that is because it is a common requirement for such templates that the type
	       used to instantiate the template provide a default constructor.
	       this requirement almost always grows out of the fact that inside the template,
	       an array of the template parameter type is being created.
	       e.g.
	         template<typename T>
		 class A {
		 public:
		   A(int size)
		   {
		     Data = new T[size];  //  if T is lack default constructor,this is an ERROR
		   }
		 private:
		   T *Data;
		 };

	       !  careful template design can eliminate the need for a default constructor,for example,
	       	  std::vector has no requirement that its type parameter have a default constructor.
		  but not all containers alike vector.

         virtual base classes lacking default constructors are a pain to work with :
	   the arguments for virtual base class constructors must be provided by the most derived class
	   of the object being constructed.
	   as a result,a virtual base class lacking a default constructor requires that all classes derived
	   from that class - no matter how far removed - must know about,understand the meaning of,and provide
	   for the virtual base class's constructors' arguments.

	   e.g.
	     class A {
	     public:
	       A(int x);
	     };

	     class B : virtual public A {
	     public:
	       B(int x, int y) : A(y)
	       {
	         ...
	       }
	     };

	     class C : public B {
	     public:
	       C(int x, int y, int z) : B(x, y), A(z)  //  C have to know and understand A's constructors' argument.
	       {
	         ...
	       }
	     }

	 !!  some people belive all classes should have default constructor even it does not have enough information to
	     fully initialize objects of that class.but inclusion of meaningless default constructors affects the 
	     efficiency of classes,too.code have to test to see if fields have truly been initialized,and have to handles
	     the case where the tests fail.of course,these bring code bloat.  !!
	 !!  default value to constructor could get behavior like default constructor.but the default value maybe still
	     meaningless,because the information used to create a class should from outside.
	     this method also confuse to other member functions.  !!

