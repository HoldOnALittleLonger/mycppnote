chapter1> Fundamental

	Item1 : view c++ as a federation of languages
	      c++ is a multiparadigm programming language,one supporting
	      a combination of procedural,object-oriented,functional,generic,
	      and metaprogramming features.
	      the primary sub-languages of c++ is :
	      	  C language,C++ is still based on C
		  Object-Oriented C++
		    contains:
			classes
			encap-sulation
			inheritance
			polymorphism
			virtual function
			.etc
		  Template C++
		    contains:
			template rules to make generic programming
		  The STL
		    contains:
			containers
	
		iterators
			algorithms
			function objects
			
		#  for easier to understand c++,these sublanguages is very important.
		#  may be encounter situations where effective programming requires that
		   change strategy when switch from one sublanguage to another.
		#  for built-in type,pass-by-value is more efficient than pass-by-reference.
		   pass-by-reference-to-const is better when deal with C++ template.
		   but when using STL,pass-by-value rule applies again,because that iterators
		   and function objects are modeled on pointers in C.

	       !!  rules for effective c++ programming vary,depending on the part of c++ you are using  !!


	Item2 : prefer consts,enums,and inlines to #defines
	      because preprocessor isnt a part of c++ language,it is a behavior for compiler.
	      preprocess macro may be removed by the preprocessor before the source code ever
	      gets to a compiler,then it will not be contained into symbol table,this would
	      cause problem for use a constant.
	      this problem can also crop up in a symbolic debugger,because,again,the name of
	      macro may not be in the symbol table.

	      #define PI 3.1415             //  may be a problem 
	      const double pi = 3.1415;     //  better
	      enum : double {PI = 3.1415};  //  best

	      #  constant may be yield smaller code than macro definition,because compiler may
	         be produces more copies to that constant.

	      two special important case:
	        1> in the case defining constant pointers
		   e.g.
			const char *const example = "example"; //  const char * const bind symbol
			      	   	  	    	       //  example just refers to string "example"
			const std::string example("example");  //  best (as much as possible use c++
			      		  		       //  std::string to instead c-style string)

		2> class-specific constans
		   to limit the scope of a constant to a class,must make it a member,
		   and to ensure there is at most one copy of the constant.
		   e.g.
			struct A {
			       static const double pi;
			       enum : double {PI = 3.1415};  //  enum hack
			};
			const double A::pi = 3.1415;

			#  usually,static class member cant be initialized in declaration,
			   in-class initialization is allowed only for integral types and
			   only for constants.
			#  if need a contant in class declaration or definition,enumerated type
			   is more useful than constant declaration.
			#  enum hack never take an unnecessary memory allocation,but constant 
			   objects will take.

	      use inline template function to instead macro function:
	      	  macro function :
		  	#define CALL_FUNC(a, b) func((a) > (b) ? (a) : (b))
			int a = 3, b = 0;
			CALL_FUNC(++a, b);  //  a would increase twice,it's not right

		  inline template function:
		  	 template<class T>
			 inline void call_func(T &a, T &b)
			 {
				f(a > b ? a : b);
			 }

			 int a = 3, b = 0;
			 call_func(++a, b);  //  right,a just increase once

	      !!  for simple constants,prefer const objects or enums to #defines  !!
	      !!  for function-like macros,prefer inline functions to #defines  !!


	Item3 : use const whenever possible
	      the wonderful thing about const is that it allow you to specify a semantic
	      constraint - a particular object should not be modified - and compilers will
	      enforce that constraint.

	      const Type Obj;  //  declares an Obj of Type that is a constant.
	      Type *const Obj; //  declares a pointer of Type and this pointer is constant
	      const Type *Obj; //  declares a pointer of Type and the object which points to
	      	    	       //  is constant
	      const Type *const Obj;  //  declares a pointer is constant which points to an 
	      	    	 	      //  object of Type that is constant

	      #  const Type *obj; as same with Type const *obj;
	      #  having a function return a constant value is generally inappropriate,but
	         sometimes doing so can reduce the incidence of client errors without
		 giving up safety or efficiency.
		 E.g.
		   struct A {
		   	  struct A operator*(const struct A &a, const struct A &b)
			  {
				...
				return *this;
			  }
			  struct A operator=(const struct A &a) { ... }
		   };

		   struct A a, b, c;
		   a * b = c;  //  a.operator*(&a, &b) returned a
		       	       //  a.operator=(c)
			       //  it's work but should not assign an lvalue to rvalue
			       //  ill-form

		   if (a * b = c);  //  suppose operator==() been defined.
		      	       	    //  if operator=() doesnt return constant value,
				    //  this expression would pass checking by compiler.

				    //  if operator=() returns constant value,
				    //  compiler would throw error try to changing a constant object.
				    //  that is helpful to avoid logical error.

	      const member functions:
	      	    the purpose of const on member functions is to identify which member functions
		    may be invoked on const objects
		    there has two important reasons to do this:
		    	  first>
				they make the interface of a class easier to understand.

			  second>
				they make it possible to work with const objects.

			  #  one of the fundamental ways to improve a c++ program's performance is to
			     pass objects by reference-to-const,this technique is viale only if there are
			     const member functions with which to manipulate that resulting const-qualified
			     objects.
			  #  a fact:
			       member functions differing only in their constness can be overloaded,this is an
			       important feature of c++.
			       E.g.
				struct A {
				       char &operator[](std::size_t pos) { ... }
				       //  realy parameters of this overload operator [] is
				       //  char &operator[](struct A &, std::size_t);

				       const char &operator[](std::size_t pos) const { ... }
				       //  realy parameters of this overload operator [] is 
				       //  const char &operator[](const struct A &, std::size_t);
				};
				//  const member function works with a const object,so,cant modify anything of
				//  the const object in the body of that const member function.(excluding static
				//  data members,because them are not inside to class object)

		    bitwise constness AND logical constness:
		    	    bitwise-constness> (it's c++'s definition of constness)
				a member function is const if and only if it doesnt modify any of the object's
				data members(excluding static data member),if it doesnt modify any of the bits
				inside the object.

			    logical-constness>
				even create a constant object and invoke only const member functions on it,may
				still change its value.

			    #  a const member function might modify some of the bits in the object on which it's
			       invoked,but only in ways that clients cant detect.

			    E.g.
				struct A {
				       char *strC;
				       char &operator[](std::size_t pos) const { ... };
				};

				const struct A a;	//  constant object
				char *pChar(nullptr);
				pChar = &a[0];		//  invoked a const member function of a constant object
				*pChar = '\0';		//  but still can change bits inside the constant object
				       	 		//  there has a way make operator[] becomes bitwise-constness
							//  is that return a const reference.

		    a way to change bits of object in a const member function that is
		    use 'mutable' keyword,'mutable' frees non-static data members from the
		    constraints of bitwise constness.
		    E.g.
			struct A {
			       mutable std::size_t _length;
			       ...
			       std::size_t getLength(void) const
			       {
					return _length = std::strlen(<char pointer>);
			       }
			};
		    
	      avoiding duplication in const and non-const member functions:
	      	    may be some overload member functions do same procedure in their body,for avoiding
		    duplication,can make a member function to wrap that procedure,and use function calling
		    to instead procedure codes.
		    but this is still duplication be there.
		    a way to avoiding duplication :
		      let version A to call version B,and invoke that procedure function in version B.

		    for const and non-const member functions,when using that way to avoid duplication
		    have to limit order between them :
		    	 version A must be non-const member function,
			 version B must be const member function

			 reason : const member function did a promise that never change bits on which invoked.
			 	  non-const member function didnt does that promise.this means non-const member
				  function can freely change anything in the object.
				  if reverse order,the promise would be ridded temporary in const member function
				  when control deliver to non-const member function,it's wrong.

			 E.g.
				struct A {
				       const char &operator[](std::size_t pos) const { ... }
				       char &operator[](std::size_t pos)
				       {
						...
						return const_cast<char &>(static_cast<const char &>(*this)[pos]);
				       }
				       ...
				};

				//  casting away is not a good idea,but for avoiding duplication,there isnt other
				//  way to avoid duplication between const and non-const member functions.

	      !!  declaring something const helps compilers detect usage errors.const can be applied
	          to objects at any scope,to function parameters and return types,and to member functions
		  as a whole  !!
	      !!  compilers enforce bitwise constness,but you should program using logical constness  !!
	      !!  when const and non-const member functions have essentially identical implementations,
	          code duplication can be avoided by having the non-const version call the const version !!

	 Item4 : make sure that objects are initialized before they're used
	       reading uninitialized values yields undefined behavior,that may halt program,or readed semi-random
	       bits,and then pollute the object you read the bits into,eventually leading to inscrutable program
	       behavior and a lot of unpleasant debugging.

	       For example :
	       	   int a;
		   int b;
		   return a + b;  //  a + b maybe equals to 10, a = 3, b = 7, or a = 1, b = 9, or a = -2, b = 12

		   int *a;
		   *a = 36;	  //  a had not initialized,if the address a points to in the process address space,
		      		  //  it just has exception,if it is not,systemctl will send SIGSEGV,that would occurs
				  //  process exit.

	      built-in type :
	      	       int a(10);
		       char c('c');
		       const char *const conststr("hello world");
		       struct the_data td{x, y, z};

		       #  built-in type is in C part of C++,that almost alike in assignment,
		       	  but shouldnt use any objects of built-in type before initialized.

	      user-defined C++ type :
	      	       class A {
		       	     A() { ... }
			     A(const std::string &s1, const std::string &s2, const std::vector &v2, std::size_t st)
			     {
			       _s1 = s1, _s2 = s2;
			       _v1 = v1;
			       _st = st;
			     }
			     A(const std::string &s1, const std::string &s2, const std::vector &v2, std::size_t st)
			     : _s1(s1), _s2(s2), _v1(v1), _st(st) { }

		       private:
		         std::string _s1, _s2;
			 std::vector _v1;
			 std::size_t _st;
		       };

		       there has two versions :
		       	     <1> assignment-based
			     <2> member-initialization-list-based

			     <1> : first use default constructor to construct _s1, _s2, _v1
			           second use assignment-constructor to assign _s1, _s2, _v1
				   finished.

			     <2> : first use copy-constructor to construct _s1, _s2, _v1
			     	   finished.
				   //  less cost

			so <2> is better than <1>,but may be there has several constructors they has
			such member-initialization-list,for simply work,if some data member is not
			used immediately,can place them into a function which use assignment to
			assign them.
			E.g.
				private:
				  A_init_built_in(arg-list) { <assignment with data member> }
				  //  constructor can calls this function

			but base class object have to initialized before derived class object!!!

			!!  c++ class data member would be initialized in the order them is declared,
			    that is,the order of member-initialization-list doesnt influence the order
			    they will be initialized.
			    in the example, _s1 -> _s2 -> _v1 -> _st  !!

	      translation unit : 
	      		  A translation unit is the source code giving rise to a single object file.
			  It's basically a single source file,plus all of its #include files.

			  A static object is one that exists from the time it's constructed until the end of
			  the program.stack and heap-based objects are thus excluded.included are global
			  objects,objects defined at namespace scope,objects declared static inside classes,
			  objects declared static inside functions,and objects declared static at file scope.

			  local static object is such object which is static and in a function's body.
			  others known as non-local static objects.

			  !!  relative order of initialization of non-local static objects defined in different
			      translation units is undefined  !!

			  E.g.
				file1.c : int a = 10;
				file2.c : int b = a;
				file3.c : int c = b;

				the order of initialization for them is undefined,because these file are
				different translation units.

				maybe c would be initialized at first,then them has error values.

			  How to prevent this ?
			  :  let non-local static objects become local static objects.

			  can define a function which contains local static object and it will returns a reference to
			  these local static object.
			  like this :

			       int &global_value_a(void)
			       {
			         static int a = 16;
				 return a;
			       }

			  //  a would be created and initialized when function global_value_a() is invoke,and a will be
			  //  recycle after program exit.if dont call that function at anywhere,it will not incur 
			  //  runtime cost.

			  //  the better way is define such function as inline function.
			  //  not only built-in type can do this,other user-defined c++ type also can do this as well.
			      struct X &global_object_sX(arg-list)
			      {
			        static struct X sX{arg-list};
				return sX;
			      }


	         !!  manually initialize objects of built-in type,because c++ only sometimes initializes them itself  !!
		 //  initializes them to zero,but not always

		 !!  in a constructor,prefer use of the member initialization list to assignment inside the body of
		     the constructor.list data members in the initialization list in the same order they're declared 
		     in the class. (for prevent confusion)  !!
		 !!  avoid initialization order problems across translation units by replacing non-local static objects
		     with local static objects.  !!
			      		   
Chapter2> Constructors,Destructors,and Assignment Operators

	 Item5 : known what functions C++ silently writes and calls
	       a class is an empty if c++ isnt get through with it.
	       if there is none of constructor or destructor or copy constructor or copy assignment operator was
	       defined in a class,compiler will automatically defines them implicitly,if they are needed,but it
	       doesnt take much to need them.all these function will both public and inline.
	       (from c++11,compiler will defines move constructor move assignment operator implicitly,if they were
	       not defined)

	       if there is a constructor was defined,have to defined a default constructor be there,of course,
	       use =default specifier is the other way.

	       #  the generated destructor is non-virtual unless it's for a class inheriting from a base class that
	          itself declares a virtual destructor.
	       #  compiler generated copy assignment operator only when the resulting code is both legal and has a
	          reasonable chance of making sense.
		  if a base class placed its copy assignment operator in private,then compiler will refuse to defines
		  copy assignment operator implicitly for derived class.

	       #  the compiler generated copy constructor and copy assignment operator will does shallow duplication,
	          that is,copy bits not copy object.

	       !!  compilers may implicitly generate a class's default constructor,copy constructor,copy assignment 
	           operator,and destructor.  !!


	 Item6 : explicitly disallow the use of compiler-generated functions you dont want
	       for preventing compiler-generated version can eliminate some bugs when try to copy a class inadvertently.
	       
	       method1>
			declare copy-constructor and copy-assignment as private members and never implement them.
			E.g.
				class A {
				public:
				  ...

				private:
				  A(const A &);
				  A &operator=(const A &);
				};

				//  just declaring,dont implement.
				//  if anywhere try to copy class A through these functions,
				//  linker would throw error.

	       method2>
			define a empty base class,and declare its copy-constructor and copy-assignment as private members,
			dont implement them.
			other class which dont want to be copied can inherit from the class.
			E.g.
				class Uncopyable {
				private:
				  Uncopyable(const Uncopyable &);
				  Uncopyable &operator=(const Uncopyable &);
				};

				//  neednt inherit Uncopyable with public
				//  and neednt declare its destructor as a virtual function(it has no data)
				class A : private Uncopyable {
				  ...
				};

				//  compiler would generates copy-constructor and copy-assignment for class A if anywhere
				//  try to copy class A.
				//  but for copy class A,the base class Uncopyable have to be copied as well,so compiler
				//  try to copy it through its copy-constructor or copy-assignment,but them are private,
				//  derived class cant access base class'private members straight.
				//  compiler would throw an error.

			#  Uncopyable contains no data,so it is eligible for the empty base class optimization,but 
			   because it is a base class,use of this technique could lead to multiple inheritance.
			   Multiple-Inheritance,in turn,can sometimes disable the empty base class optimization.


	       method3>
			from c++11,function-qualifier = delete can declare that the function was deleted.
			E.g.
				class A {
				public:
				  A(const A &) = delete;
				  A &operator=(const A &) = delete;
				  ...
				};

				//  anywhere try to call deleted function,compiler would throws error.


	       #  for method1,error would be thrown while link-time,
	       	  for method2 and method3,error would be thrown while compile-time.
		  throw error at compile-time is better than throw error at link-time.(if program use dynamic library,
		  	      	 	      	 	     	   	    	       link-time error would crash program)

	       !!  to disallow functionality automatically provided by compilers,declare the corresponding member functions
	           private and give no implementations.
		   Using a base class like Uncopyable is one way to do this.  !!

		    
	 Item7 : declare destructors virtual in polymorphic base classes
	       c++ specifies that when a derived class object is deleted through a pointer to a base class with a 
	       non-virtual destructor,results are undefined.

	       if try to delete a derived class object through a base class pointer,then the resource of derived
	       would not be deleted.
	       E.g.
			class A { ... };  //  destructor of A is not a virtual function
			class B : public A { ... };

			A *ab = new class B;
			delete ab;  //  resoure of B would not be deleted.

	       if a class has virtual function,then pointer vptr and array vtbl would be contained.
	       vptr is "virtual table pointer"
	       vtbl is "virtual table"
	       	    //  exactly form of them is designed by implementation detail.
		    //  maybe not an array.
		    //  vptr and vtbl is not portiable! (it is the second part of C++)

	       it A has a virtual destructor,then statement 'delete ab' would invoke B::~B() first,then invoke
	       A::~A().

	       vtbl is used to determine which function should be invoke through object pointer or reference.
	       so,vptr and vtbl would increase size of class,if dont want such class as base class,should not
	       declare any virtual function in it.
	       (a class maybe occopied 64bits,but it will occopied 128bits if there has a virtual function in it.)

	       !!  polymorphic base classes should declare virtual destructors,if a class has any virtual functions,
	           it should have a virtual destructor.  !!
	       !!  classes not designed to be base classes or not designed to be used polymorphically should not
	           declare virtual destructors.  !!
		   #  STL and std::string and std::input_iterator_tag and etc. are not designed to allow the
		      manipulation of derived class objects via base class interfaces.
		      (dont inherit from STL !!)

	       !!  occasionally it can be convenient to give a class a pure virtual destructor,a class has pure virtual
	           function would be abstract class,it cant be instantiated.but if declare the destructor of this class
		   as a virtual function,have to defined its body,because of it is that when delete resource of a derived
		   class via destructor,the lateast invocation of function must be base class destructor.  !!


	 Item8 : Prevent exceptions from leaving destructors
	       C++ doest allows one too many exceptions is existed in program.
	       suppose,container v is destroying,then all element in it have to be destroyed,too.
	       the first destroy failed and throw an exception,but remainder is still have to be
	       destroyed,then the second exception is thrown in encountered.by the time,program
	       has two exceptions aliving,this is a problem.

	       if exception from destructor,then there is hard to react the condition that exception
	       was thrown.
	       several exceptions is aliving that cause premature program termination or undefined 
	       behavior.

	       First method :
	       	     use try { ... } catch () { ... } in destructor,there can ignore an exception from
		     try {} or deal with it in catch {}.
		     suppose a destructor will calls func() to does some works,but it maybe throw an
		     exception,then have to put the invocation of it into try {}.
		     deal with the exception or ignore it(just record log,but do nothing) is optional.

		     #  deal with the exception to terminate the program.
		     #  swallow the exception,record log and ignore it.

	       Second method :
	       	      wrap such function it might throw exception as a user interface,user should call that interface
		      manually even it recycle class resource.there has a way to capture such exception and can
		      react the condition in debugging time.of course,could deal with it or ignore it in program.

		      #  the exception has to come from some non-destructor function.

	       !!  destructors should never emit exceptions.if functions called in a destructor may throw,the destructor should
	           catch any exceptions,then swallow them or terminate the program(std::abort()). !!
	       !!  if class clients need to be able to react to exceptions thrown during an operation,the class should provide 
	           a regular function that performs the operation.  !!


	 Item9 : Never call virtual functions during construction or destruction
	       C++ dont allow to call virtual function during construction or destruction.
	       If base class call virtual function during constructor,and the derived class has override the virtual function,
	       when derived class is constructing,its virtual function would never be called by base class that the virtual
	       function had not been initialized.
	       During base class construction,virtual functions never go down into derived classes.
	       Calling down to parts of an object that have not yet been initialized is inherently dangerous.

	       E.g.
	         class A {
		   public:
		     A() { vfunction(); ... }
		     virtual void vfunction(void) { ... }
		     ...
		 };

		 class B : A {
		   public:
		     B() { ... }
		     //  during constructor of A,the vfunction is point to A::vfunction,not B::vfunction.
		     //  if A::vfunction is a pure virtual function,linker would cant find such function for link.
		     //  because instanse of the virtual function was made up after object of B is created.
		     virtual void vfunction(void) { *** }
		 };

	       #  not only do virtual functions resolve to the base class,but the parts of the language using runtime type
	       #  information treat the object as a base class type.(dynamic_cast ...)

	       An object doesnt become a derived class object until execution of a derived class constructor begins !
	       An object is a derived class object until execution of a derived class destructor begins !

	       The same reasoning applies during destruction.Once a derived class destructor has run,the object's derived class
	       data members assume undefined values.so at the time,the type of this object is that of base class.

	       #  All functions called in constructor or destructor each also cant calls virtual function.

	       Cant use virtual functions to call down from base classes during construction,but for compensate,can having derived
	       classes pass necessary construction information up to base class constructors.
	       Use a special named function in derived class to make parameter for base class constructor is more readable.

	       !!  dont call virtual functions during construction or destruction,because such calls will never go to a more
	           derived class than of the currently executing constructor or destructor.  !!


	 Item10 : Have assignment operators return a reference to *this
	 	The convention for assignment that is assignment returns a reference to its left-hand argument.
		So there could has such statement :
		  int x = 3;
		  int y, z;
		  y = z = x + 3;
		  //  y = (z = (x + 3))

		Ofcourse,the c++ class' assignment operator should follow the convention.
		Thus,these prototype is allowed in c++ class :
		  Class &Class::operator=(const Class &);
		  Class &Class::operator+=(const Class &);

		Each of these operator overload function should has statement "return *this;".

		#  The convention just a suggestion,code could pass compile without such convention,but all built-in types
		   are follow the convention,and the types in standard library also.

		!!  Have assignment operators return a reference to *this  !!


	 Item11 : Handle assignment to self in operator=
	 	self-assignment-safe :
		  int x = 3;
		  x = x;

		The statement is work fine,but in a class operator= overload,have to care implement code.
		>
		  class A {
		    public:
		      A &operator=(const A &oa)
		      {
		        delete vc;
			vc = makevc(oa.vc);
			return *this;
		      }

		      std::vector<char> *makevc(std::vector<char> *oldvc);

		      std::vector<char> *vc;
		  };

		  the operator= overload function in class A is both self-assignment-unsafe and exception-unsafe.
		  if &oa == this and an exception occured in makevc() ,the rest that is vc point to a deleted pointer.
		  (might another exception was thrown)

		  for prevent point to deleted pointer error,could add identity test top at the function.

		  A &operator=(const A &oa)
		  {
		    if (&oa == this)
		      return *this;
		    delete vc;
		    vc = makevc(oa.vc);
		    return *this;
		  }  //  identity test would reduce efficiency,if same objects assignment not often occur.

		  if &oa == this,then work fine,but while they are not,the function still exception-unsafe.
		  if an exception was thrown by makevc(),vc will point to a deleted pointer.
		  but there has a good idea to solve self-assignment-unsafe and exception-unsafe,that is assure the function
		  is exception-safe will let it becomes self-assignment-safe.

		  for prevent exception-unsafe could change order of statement(follow copy-and-swap) to deal with it :
		  
		  A &operator=(const A &oa)
		  {
		    decltype(this->vc) opvc = this->vc;
		    vc = makevc(oa.vc);
		    delete opvc;
		    return *this;
		  }

		  class could has swap() method to help implement copy-and-swap code.

		  void A::swap(A &a);
		  A &operator=(const A &oa)
		  {
			A temp(oa);
			swap(temp);
			return *this;
		  }

		  A variation on this theme takes advantage of the facs that 
		    a class's copy assignment operator may be declared to take its argument by value and 
		    passing something by value makes a copy of it
		    
		  A &operator=(A oa)
		  {
		    swap(oa);
		    return *this;
		  }

		  //  while call operator= for A,compiler would automatically create a temporary object that type of A.
		  //  then operator= invokes swap() to swap *this and oa.
		  //  but this approach sacrifices clarity.

		  //  A x, y;
		  //  x = y;  #  OK,y passed by value,then x swapped with temporary A object(copy of y).

		!!  make sure operator= is well-behaved when an object is assigned to itself.
		    Techniques include comparing address of source and target objects,
		    careful statement ordering,and copy-and-swap.  !!
		!!  make sure that any function operating on more than one objects behaves correctly
		    if two or more of the objects are the same.  !!


	 Item12 : Copy all parts of an object
	 	If data members for the class all type is built-in,then just use the compiler provided copy-constructor,
		program should work fine.
		but if it isnt in such case or the base class has data members isnt built-in type,the copy-constructor provided
		by compiler would cause problem.

		E.g.
		  class A {
		    public:
		      int x;
		      int y;

		    private:
		      char c;
		      void copyC(const A &);
		  };

		  the compiler provides copy-constructor is like this function :
		    A(const A &j)
		    {
		      x = j.x;
		      y = j.y;
		      copyC(j);
		    };  //  it's work well

		  but in another case, class has dynamic pointer
		  class A {
		    public:
		      int *x;
		      A() { x = new int[5]; }
		      ~A() { delete[] x; x = nullptr; }
		  }

		  the compiler provided copy-constructor just do assignment "x = j.x",after j was destroyed,
		  program try to access i.x would occur segmentfault,or occur the error while destroy i.
		  (access a memory is not in bound of program or delete a pointer twice)

		  for solve such problem,have to defined copy-constructor manually :
		    A::A(const A &j)
		    {
			x = new int[5];
			memcpy(x, j.x, sizeof(int) * 5);
		    }

		  the copy-assignment operator have to follow same conventions.
		  of course,dont just copy all parts of the derived class,should copy all parts of the base class as well.
		  E.g.
		    class A : public B { ... };
		    A::A(const A &x) : B(x) { ... }
		    //  derived class cant access data members in private of base class B,so have to call constructor of B
		        to copy base class,there would happen top-force-convert B(x),x would be resolved to type B.
			(type of x is A,A public inherit from B)
			(object convert derived-to-base-safe,object convert base-to-derived-unsafe)
			(the parts of derived class is not defined in base class,but derived class has the parts of base class)

		    A &A::operator=(const A &x) { B::operator=(x); ... }  //  manually invoke B::operator=()
		    //  there has same principle.

		  if copy-assignment operator and copy-constructor has same behavior for the class,should put the copying
		  statements into a common function,and it would be called by them.
		  //  this means,dont call copy-assignment operator in copy-constructor or
		      call copy-constructor in copy-assignment operator,assignment operator applies only to objects 
		      that have already been initialized,it had been existed(but constructor build a new object).
		      and perform an assignment on an object under construction would mean doing something to a 
		      not-yet-initialized object that makes sense only for an initialized object.

		!!  copying functions should be sure to copy all of an object's data members and all of its base class parts.  !!
		!!  dont try to implement one of the copying functions in terms of the other.
		    instead,put common functionality in a third function that both call.  !!


Chapter3> Resource Management

	 Item13 : Use objects to manage resources
	   	The situations would cause memory leak :
		  1> forget to call delete for memory dynamically allocated.
		  2> try to delete memory before block exit but program exited the block before
		     the delete statement was executed.
		  3> before delete statement was executed,program thrown an exception.

		E.g.
		  int *f(void) { return new int; }  // caller may be forget to call delete.

		  void f(void) { int *x = new int; return; delete x; return; }
		  // delete statement would never be executed.
		  
		  void fex(void) noexcept(false)
		  {
		    throw 3;
		  }

		  void f(void)
		  {
		    int *x = new int;
		    fex();
		    delete x;
		    return;
		  }

		  // before the delete statement was executed,an exception occurred,
		  // but function f dont catch it,so the exception would be delivered to
		  // the caller of f (next to next until find try-catch block which catch int exception).
		  // there would happens stack-unwinding,the resource on stack would be
		  // automatically deleted,but the dynamic memory in heap,they would never
		  // be deleted.

		For prevent resource leaks,have to use class object to manage it,because the destructor would be automatically
		invoked while the block which contains the object exit.
		but if the manager is allocated also through dynamic memory allocating,would happens same problems.

		RAII (Resource Acquisition Is Initialization) :
		  
		  c++ provides smart pointer to help manage resource.
		  std::auto_ptr      	(deleted since c++11)

		  //  RCSP (reference-counting smart pointer) had been merged into RAII.
		  std::unique_ptr	(since c++11)
		  std::shared_ptr	(since c++11)

		  //  std::shared_ptr is the feature of TR1,but all TR1 features had merged into c++11 RAII.
		  //  before c++11,the shared_ptr has namespace resolve std::tr1::

		  for use RAII to manage resource,just do assignment to the class object with acquired pointer.

		  E.g.
		    int *x = new int;
		    std::auto_ptr<int> pI(x);  //  the destructor of auto_ptr would invoke delete to its pointer,
		    		       	       //  it means would execute "delete x;" in it.

		  #  dont delete a pointer more than once,so cant manually execute "delete x;" after assign x to pI.

		  #  std::auto_ptr is allowed to copying but have not same behavior with other copiable class.
		     E.g.
		       int *x = new int;
		       std::auto_ptr<int> pI1(x);
		       std::auto_ptr<int> pI2(pI1);

		       //  pI1 would delivers its ownership to pI2 for the pointer.
		       //  then pI2 == x,pI1 == null.
		  #  std::shared_ptr is allowed to copying.
		     the resource was managed by std::shared_ptr would be deleted until the last std::shared_ptr object is
		     destroyed.(this is alike of linux file descriptor)

		#  RAII object just invoke "delete" in its destructor,dont invoke "delete[]".
		   so cant use RAII object to manage an array pointer.
		   because STL container contains some array similar containers,if there is not reasonable,dont use
		   user-defined array structure.

		!!  to prevent resource leaks,use RAII objects that acquire resources in their constructors and release them
		    in their destructors.  !!
		!!  resource is not only contains memory,but also contains file-descriptor,socket,mutex,semphore,etc.  !!

	 Item14 : Think carefully about copying behavior in resource-managing classes
	 	For heap-resource,RAII classes work fine,but they cant be used for stack-resource,because the resource was 
		managed by RAII class object would be deleted after the destructor called.
		For this reason,have to implement a user-defined RAII-alike class to manage resource.

		There has some problems to do copy for such class object.
		Several possibilities :
		  1>  prohibit copying :
		        If copying makes no sense for an RAII class,should prohibit copying.
			(resource dont allows to be copied,or each such resource is unique)

		  2>  reference-count the underlying resource :
		        resource allows to be copied,but there should has a counter to count references.this is alike of 
			linux file-descriptor(or std::shared_ptr class).could simply let the user-defined class to contains
			std::shared_ptr object to implement reference-counter.but the resource is stack-resource,so the second
			argument of constructor of std::shared_ptr class should is a user-defined function(the Deleter) it dont
			delete resource.(std::shared_ptr default delete resource).

		  3>  copy the underlying resource :
		        for example,std::string class.when try to copy a string object,its copy-functions would does deep copying.
			so user-defined RAII-alike class also do deep copying as well.

		  4>  transfer ownership of the underlying resource :
		        maybe the resource if only if has one owner at same time,copy-function should not does deep copying,it have
			to transfer ownership for the resource to another class object.(e.g. std::unique_ptr)

		!!  if no sense to make copying,then prohibit it,if need reference-count,should use std::shared_ptr.  !!
		!!  copying an RAII object entails copying the resource it manages,so the copyong behavior of the resource 
		    determines the copying behavior of the RAII object.  !!
		!!  common RAII class copying behaviors are disallowing copying and peforming reference counting,but other behavior
		    are possible.  !!
		    (this means,the reference-counter should be a static data member,or take synchronization during copying)


	 Item15 : Provide access to raw resources in resource-managing classes
	 	Sometimes,code need to accesses the raw resource inside an RAII class.
		e.g.
		  void func(struct A *a);

		but if such struct object is managed by a RAII class,this invoke would fault :
		  std::unique_ptr<struct A> a = std::make_unique<struct A>();
		  func(a);  //  ERROR,func() expect an argument of type struct A pointer,
		  	    //  but a is type of std::unique_ptr.

		generally,there has two ways to support raw resource accessing :
		  1>  explicit
		  2>  implicit

		  explicit :
		    use a member method to covert underlying resource explicitly.
		    some RAII class provide get() member method to supports raw resource accessing,
		    like this :
		      T* std::unique_ptr::get(void) const { return @__raw_resource_pointer; }

		    so func() could be invoke with these codes :
		      func(a.get());
		    if program accesses raw resource frequently,so everywhere try to access the raw resource have to use
		    get() member method.it is a off-putting way.

		  implicit :
		    use operator overload to implement implicit coverting.
		    like this :
		      T *operator RAW_TYPE(RAII_TYPE) const { return @__raw_resoure_pointer; }
		    this way could prevent off-putting explicit convert,but it also cause some problem.
		    that is unintended type conversions.

		    //  T *struct USER_RAII::operator T*(struct USER_RAII &c) const
		    //	{
		    //	  return c.@__raw_pointer;
		    //	}
		    struct USER_RAII<struct A> ur(new struct A);
		    struct A *la = ur;
					//  ur is an RAII class can has managed a unamed struct A object.
					//  la = ur try to assign ur to la,there would occurs implicit covert,
					//  type USER_RAII -> type struct A*.
		  
		    the raw resource would be released after ur was destructed,la would becomes dangle pointer.

		other problems :
		  provide a way to access raw resource maybe occurs encapsulation contrary.
		  but RAII class dont exist to encapsulate something,it exist to ensure that a particular action
		  - resource release - takes places.
		  mention this is for noticify that the design detail have to be pay attention.
		  but c++ class supports friend declaring,that is same as this discussion..

		!!  APIs often require access to raw resources,so each RAII class should offer a way to get at the resource 
		    it manages.  !!
		!!  access may be via explicit conversion or implicit conversion.in general,explicit conversion is safer,but
		    implicit conversion is more convenient for clients.  !!


	 Item16 : Use the same form in corresponding uses of new and delete
	  	Two things happen during employ a new expression for create an object :
		  1>  memory allocated
		  2>  one or more constructors are called for that memory
		Two things happen during employ a delete expression for destroy memory :
		  1>  if it is exist,then call destructor for that memory
		  2>  destroy memory

		but there has a important question,how many constructors should be called?
		>  delete expression just destroy one unit of memory,so just one destructor
		   would be invoked.
		   but delete[] expression should destroy more memory units as well,so there
		   would happens such number of destructors to be invoked for the memory units.

		so,have to pair 'new' and 'delete',and also have to pair 'new[]' and 'delete[]'
		program would has fault for these case each is not a good pair :
		  new <> delete[]
		    SIGSEGV : try to destroy more memory units than allocated,
		    or the remainder units allow to be accessed,but they are not suit type possible
		    to be destroyed via destructor.
		  new[] <> delete
		    only destroy the first memory unit of the memory units were allocated by new[]

		attention :
		  caution of use typedef with an array :
		    typedef std::string theArray[4];
		    std::string *pS = new theArray;
		    delete pS;  //  wrong,must use delete[] to destroy pS because the underlying type of theArray
		    	   	//    is an array of std::string.

		    //  for prevent this,abstain use typedef to define custom array-like struct,use STL container to
		    //  instead.
		    //  e.g.  std::vector<std::string> *pS = new std::vector<std::string>;

		!!  if use [] in a new expression,must use [] in the corresponding delete expression.
		    if dont use [] in a new expression,must not use [] in the corresponding delete expression.  !!
		!!  abstain use typedef keyword to define custom array-like structure,use STL container to 
		    instead of such method as well.  !!


	 Item17 : Store newed objects in smart pointers in standalone statements
	 	Example :
		  int priority(void);
		  void processWidget(std::shared_ptr<Widget> pw, int priority);

		  A call to processWidget() :
		    processWidget(new Widget, priority());

		 if there has no member function which convert Widget to std::shared_ptr<Widget>,compiler would
		 throw an error.
		 of course,even the first parameter of processWidget is "std::shared_ptr<int> pi",then would 
		 thrown an error though passed a int pointer via (new int).(need a convert function)

		 another problem on there,the evaluate order for function argument is unknown.
		 In C program,all function parameter would be pushed into stack in the order right->left,
		 C++ program is apply such rule.

		 suppose,compiler executes (new Widget) at first,then call priority(),call constructor of 
		 std::shared_ptr::shared_ptr() at last;
		 if there is an exception thrown by priority(),then the memory allocated by new expression
		 would leak,its pointer lost.normally,the pointer should be managed by pw,but exception prevent the 
		 action to construct pw.

		 A good method is use standalong statement to construct the first argument for processWidget() :
		   std::shared_ptr<Widget> pw(new Widget);
		   processWidget(pw, priority());

		   //  it is possible to send reference to instead value copy for std::shared_ptr object.

		!!  store newed objects in smart pointers in standalone statements.failure to do this can lead to
		    subtle resource leaks when exception are thrown.  !!
		 
			


		       




		  




