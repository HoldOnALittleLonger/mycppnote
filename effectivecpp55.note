chapter1> Fundamental

	Item1 : view c++ as a federation of languages
	      c++ is a multiparadigm programming language,one supporting
	      a combination of procedural,object-oriented,functional,generic,
	      and metaprogramming features.
	      the primary sub-languages of c++ is :
	      	  C language,C++ is still based on C
		  Object-Oriented C++
		    contains:
			classes
			encap-sulation
			inheritance
			polymorphism
			virtual function
			.etc
		  Template C++
		    contains:
			template rules to make generic programming
		  The STL
		    contains:
			containers
	
		iterators
			algorithms
			function objects
			
		#  for easier to understand c++,these sublanguages is very important.
		#  may be encounter situations where effective programming requires that
		   change strategy when switch from one sublanguage to another.
		#  for built-in type,pass-by-value is more efficient than pass-by-reference.
		   pass-by-reference-to-const is better when deal with C++ template.
		   but when using STL,pass-by-value rule applies again,because that iterators
		   and function objects are modeled on pointers in C.

	       !!  rules for effective c++ programming vary,depending on the part of c++ you are using  !!


	Item2 : prefer consts,enums,and inlines to #defines
	      because preprocessor isnt a part of c++ language,it is a behavior for compiler.
	      preprocess macro may be removed by the preprocessor before the source code ever
	      gets to a compiler,then it will not be contained into symbol table,this would
	      cause problem for use a constant.
	      this problem can also crop up in a symbolic debugger,because,again,the name of
	      macro may not be in the symbol table.

	      #define PI 3.1415             //  may be a problem 
	      const double pi = 3.1415;     //  better
	      enum : double {PI = 3.1415};  //  best

	      #  constant may be yield smaller code than macro definition,because compiler may
	         be produces more copies to that constant.

	      two special important case:
	        1> in the case defining constant pointers
		   e.g.
			const char *const example = "example"; //  const char * const bind symbol
			      	   	  	    	       //  example just refers to string "example"
			const std::string example("example");  //  best (as much as possible use c++
			      		  		       //  std::string to instead c-style string)

		2> class-specific constans
		   to limit the scope of a constant to a class,must make it a member,
		   and to ensure there is at most one copy of the constant.
		   e.g.
			struct A {
			       static const double pi;
			       enum : double {PI = 3.1415};  //  enum hack
			};
			const double A::pi = 3.1415;

			#  usually,static class member cant be initialized in declaration,
			   in-class initialization is allowed only for integral types and
			   only for constants.
			#  if need a contant in class declaration or definition,enumerated type
			   is more useful than constant declaration.
			#  enum hack never take an unnecessary memory allocation,but constant 
			   objects will take.

	      use inline template function to instead macro function:
	      	  macro function :
		  	#define CALL_FUNC(a, b) func((a) > (b) ? (a) : (b))
			int a = 3, b = 0;
			CALL_FUNC(++a, b);  //  a would increase twice,it's not right

		  inline template function:
		  	 template<class T>
			 inline void call_func(T &a, T &b)
			 {
				f(a > b ? a : b);
			 }

			 int a = 3, b = 0;
			 call_func(++a, b);  //  right,a just increase once

	      !!  for simple constants,prefer const objects or enums to #defines  !!
	      !!  for function-like macros,prefer inline functions to #defines  !!


	Item3 : use const whenever possible
	      the wonderful thing about const is that it allow you to specify a semantic
	      constraint - a particular object should not be modified - and compilers will
	      enforce that constraint.

	      const Type Obj;  //  declares an Obj of Type that is a constant.
	      Type *const Obj; //  declares a pointer of Type and this pointer is constant
	      const Type *Obj; //  declares a pointer of Type and the object which points to
	      	    	       //  is constant
	      const Type *const Obj;  //  declares a pointer is constant which points to an 
	      	    	 	      //  object of Type that is constant

	      #  const Type *obj; as same with Type const *obj;
	      #  having a function return a constant value is generally inappropriate,but
	         sometimes doing so can reduce the incidence of client errors without
		 giving up safety or efficiency.
		 E.g.
		   struct A {
		   	  struct A operator*(const struct A &a, const struct A &b)
			  {
				...
				return *this;
			  }
			  struct A operator=(const struct A &a) { ... }
		   };

		   struct A a, b, c;
		   a * b = c;  //  a.operator*(&a, &b) returned a
		       	       //  a.operator=(c)
			       //  it's work but should not assign an lvalue to rvalue
			       //  ill-form

		   if (a * b = c);  //  suppose operator==() been defined.
		      	       	    //  if operator=() doesnt return constant value,
				    //  this expression would pass checking by compiler.

				    //  if operator=() returns constant value,
				    //  compiler would throw error try to changing a constant object.
				    //  that is helpful to avoid logical error.

	      const member functions:
	      	    the purpose of const on member functions is to identify which member functions
		    may be invoked on const objects
		    there has two important reasons to do this:
		    	  first>
				they make the interface of a class easier to understand.

			  second>
				they make it possible to work with const objects.

			  #  one of the fundamental ways to improve a c++ program's performance is to
			     pass objects by reference-to-const,this technique is viale only if there are
			     const member functions with which to manipulate that resulting const-qualified
			     objects.
			  #  a fact:
			       member functions differing only in their constness can be overloaded,this is an
			       important feature of c++.
			       E.g.
				struct A {
				       char &operator[](std::size_t pos) { ... }
				       //  realy parameters of this overload operator [] is
				       //  char &operator[](struct A &, std::size_t);

				       const char &operator[](std::size_t pos) const { ... }
				       //  realy parameters of this overload operator [] is 
				       //  const char &operator[](const struct A &, std::size_t);
				};
				//  const member function works with a const object,so,cant modify anything of
				//  the const object in the body of that const member function.(excluding static
				//  data members,because them are not inside to class object)

		    bitwise constness AND logical constness:
		    	    bitwise-constness> (it's c++'s definition of constness)
				a member function is const if and only if it doesnt modify any of the object's
				data members(excluding static data member),if it doesnt modify any of the bits
				inside the object.

			    logical-constness>
				even create a constant object and invoke only const member functions on it,may
				still change its value.

			    #  a const member function might modify some of the bits in the object on which it's
			       invoked,but only in ways that clients cant detect.

			    E.g.
				struct A {
				       char *strC;
				       char &operator[](std::size_t pos) const { ... };
				};

				const struct A a;	//  constant object
				char *pChar(nullptr);
				pChar = &a[0];		//  invoked a const member function of a constant object
				*pChar = '\0';		//  but still can change bits inside the constant object
				       	 		//  there has a way make operator[] becomes bitwise-constness
							//  is that return a const reference.

		    a way to change bits of object in a const member function that is
		    use 'mutable' keyword,'mutable' frees non-static data members from the
		    constraints of bitwise constness.
		    E.g.
			struct A {
			       mutable std::size_t _length;
			       ...
			       std::size_t getLength(void) const
			       {
					return _length = std::strlen(<char pointer>);
			       }
			};
		    
	      avoiding duplication in const and non-const member functions:
	      	    may be some overload member functions do same procedure in their body,for avoiding
		    duplication,can make a member function to wrap that procedure,and use function calling
		    to instead procedure codes.
		    but this is still duplication be there.
		    a way to avoiding duplication :
		      let version A to call version B,and invoke that procedure function in version B.

		    for const and non-const member functions,when using that way to avoid duplication
		    have to limit order between them :
		    	 version A must be non-const member function,
			 version B must be const member function

			 reason : const member function did a promise that never change bits on which invoked.
			 	  non-const member function didnt does that promise.this means non-const member
				  function can freely change anything in the object.
				  if reverse order,the promise would be ridded temporary in const member function
				  when control deliver to non-const member function,it's wrong.

			 E.g.
				struct A {
				       const char &operator[](std::size_t pos) const { ... }
				       char &operator[](std::size_t pos)
				       {
						...
						return const_cast<char &>(static_cast<const char &>(*this)[pos]);
				       }
				       ...
				};

				//  casting away is not a good idea,but for avoiding duplication,there isnt other
				//  way to avoid duplication between const and non-const member functions.

	      !!  declaring something const helps compilers detect usage errors.const can be applied
	          to objects at any scope,to function parameters and return types,and to member functions
		  as a whole  !!
	      !!  compilers enforce bitwise constness,but you should program using logical constness  !!
	      !!  when const and non-const member functions have essentially identical implementations,
	          code duplication can be avoided by having the non-const version call the const version !!

	 Item4 : make sure that objects are initialized before they're used
	       reading uninitialized values yields undefined behavior,that may halt program,or readed semi-random
	       bits,and then pollute the object you read the bits into,eventually leading to inscrutable program
	       behavior and a lot of unpleasant debugging.

	       For example :
	       	   int a;
		   int b;
		   return a + b;  //  a + b maybe equals to 10, a = 3, b = 7, or a = 1, b = 9, or a = -2, b = 12

		   int *a;
		   *a = 36;	  //  a had not initialized,if the address a points to in the process address space,
		      		  //  it just has exception,if it is not,systemctl will send SIGSEGV,that would occurs
				  //  process exit.

	      built-in type :
	      	       int a(10);
		       char c('c');
		       const char *const conststr("hello world");
		       struct the_data td{x, y, z};

		       #  built-in type is in C part of C++,that almost alike in assignment,
		       	  but shouldnt use any objects of built-in type before initialized.

	      user-defined C++ type :
	      	       class A {
		       	     A() { ... }
			     A(const std::string &s1, const std::string &s2, const std::vector &v2, std::size_t st)
			     {
			       _s1 = s1, _s2 = s2;
			       _v1 = v1;
			       _st = st;
			     }
			     A(const std::string &s1, const std::string &s2, const std::vector &v2, std::size_t st)
			     : _s1(s1), _s2(s2), _v1(v1), _st(st) { }

		       private:
		         std::string _s1, _s2;
			 std::vector _v1;
			 std::size_t _st;
		       };

		       there has two versions :
		       	     <1> assignment-based
			     <2> member-initialization-list-based

			     <1> : first use default constructor to construct _s1, _s2, _v1
			           second use assignment-constructor to assign _s1, _s2, _v1
				   finished.

			     <2> : first use copy-constructor to construct _s1, _s2, _v1
			     	   finished.
				   //  less cost

			so <2> is better than <1>,but may be there has several constructors they has
			such member-initialization-list,for simply work,if some data member is not
			used immediately,can place them into a function which use assignment to
			assign them.
			E.g.
				private:
				  A_init_built_in(arg-list) { <assignment with data member> }
				  //  constructor can calls this function

			but base class object have to initialized before derived class object!!!

			!!  c++ class data member would be initialized in the order them is declared,
			    that is,the order of member-initialization-list doesnt influence the order
			    they will be initialized.
			    in the example, _s1 -> _s2 -> _v1 -> _st  !!

	      translation unit : 
	      		  A translation unit is the source code giving rise to a single object file.
			  It's basically a single source file,plus all of its #include files.

			  A static object is one that exists from the time it's constructed until the end of
			  the program.stack and heap-based objects are thus excluded.included are global
			  objects,objects defined at namespace scope,objects declared static inside classes,
			  objects declared static inside functions,and objects declared static at file scope.

			  local static object is such object which is static and in a function's body.
			  others known as non-local static objects.

			  !!  relative order of initialization of non-local static objects defined in different
			      translation units is undefined  !!

			  E.g.
				file1.c : int a = 10;
				file2.c : int b = a;
				file3.c : int c = b;

				the order of initialization for them is undefined,because these file are
				different translation units.

				maybe c would be initialized at first,then them has error values.

			  How to prevent this ?
			  :  let non-local static objects become local static objects.

			  can define a function which contains local static object and it will returns a reference to
			  these local static object.
			  like this :

			       int &global_value_a(void)
			       {
			         static int a = 16;
				 return a;
			       }

			  //  a would be created and initialized when function global_value_a() is invoke,and a will be
			  //  recycle after program exit.if dont call that function at anywhere,it will not incur 
			  //  runtime cost.

			  //  the better way is define such function as inline function.
			  //  not only built-in type can do this,other user-defined c++ type also can do this as well.
			      struct X &global_object_sX(arg-list)
			      {
			        static struct X sX{arg-list};
				return sX;
			      }


	         !!  manually initialize objects of built-in type,because c++ only sometimes initializes them itself  !!
		 //  initializes them to zero,but not always

		 !!  in a constructor,prefer use of the member initialization list to assignment inside the body of
		     the constructor.list data members in the initialization list in the same order they're declared 
		     in the class. (for prevent confusion)  !!
		 !!  avoid initialization order problems across translation units by replacing non-local static objects
		     with local static objects.  !!
			      		   
Chapter2> Constructors,Destructors,and Assignment Operators

	 Item5 : known what functions C++ silently writes and calls
	       a class is an empty if c++ isnt get through with it.
	       if there is none of constructor or destructor or copy constructor or copy assignment operator was
	       defined in a class,compiler will automatically defines them implicitly,if they are needed,but it
	       doesnt take much to need them.all these function will both public and inline.
	       (from c++11,compiler will defines move constructor move assignment operator implicitly,if they were
	       not defined)

	       if there is a constructor was defined,have to defined a default constructor be there,of course,
	       use =default specifier is the other way.

	       #  the generated destructor is non-virtual unless it's for a class inheriting from a base class that
	          itself declares a virtual destructor.
	       #  compiler generated copy assignment operator only when the resulting code is both legal and has a
	          reasonable chance of making sense.
		  if a base class placed its copy assignment operator in private,then compiler will refuse to defines
		  copy assignment operator implicitly for derived class.

	       #  the compiler generated copy constructor and copy assignment operator will does shallow duplication,
	          that is,copy bits not copy object.

	       !!  compilers may implicitly generate a class's default constructor,copy constructor,copy assignment 
	           operator,and destructor.  !!


	 Item6 : explicitly disallow the use of compiler-generated functions you dont want
	       for preventing compiler-generated version can eliminate some bugs when try to copy a class inadvertently.
	       
	       method1>
			declare copy-constructor and copy-assignment as private members and never implement them.
			E.g.
				class A {
				public:
				  ...

				private:
				  A(const A &);
				  A &operator=(const A &);
				};

				//  just declaring,dont implement.
				//  if anywhere try to copy class A through these functions,
				//  linker would throw error.

	       method2>
			define a empty base class,and declare its copy-constructor and copy-assignment as private members,
			dont implement them.
			other class which dont want to be copied can inherit from the class.
			E.g.
				class Uncopyable {
				private:
				  Uncopyable(const Uncopyable &);
				  Uncopyable &operator=(const Uncopyable &);
				};

				//  neednt inherit Uncopyable with public
				//  and neednt declare its destructor as a virtual function(it has no data)
				class A : private Uncopyable {
				  ...
				};

				//  compiler would generates copy-constructor and copy-assignment for class A if anywhere
				//  try to copy class A.
				//  but for copy class A,the base class Uncopyable have to be copied as well,so compiler
				//  try to copy it through its copy-constructor or copy-assignment,but them are private,
				//  derived class cant access base class'private members straight.
				//  compiler would throw an error.

			#  Uncopyable contains no data,so it is eligible for the empty base class optimization,but 
			   because it is a base class,use of this technique could lead to multiple inheritance.
			   Multiple-Inheritance,in turn,can sometimes disable the empty base class optimization.


	       method3>
			from c++11,function-qualifier = delete can declare that the function was deleted.
			E.g.
				class A {
				public:
				  A(const A &) = delete;
				  A &operator=(const A &) = delete;
				  ...
				};

				//  anywhere try to call deleted function,compiler would throws error.


	       #  for method1,error would be thrown while link-time,
	       	  for method2 and method3,error would be thrown while compile-time.
		  throw error at compile-time is better than throw error at link-time.(if program use dynamic library,
		  	      	 	      	 	     	   	    	       link-time error would crash program)

	       !!  to disallow functionality automatically provided by compilers,declare the corresponding member functions
	           private and give no implementations.
		   Using a base class like Uncopyable is one way to do this.  !!

		    
	 Item7 : declare destructors virtual in polymorphic base classes
	       c++ specifies that when a derived class object is deleted through a pointer to a base class with a 
	       non-virtual destructor,results are undefined.

	       if try to delete a derived class object through a base class pointer,then the resource of derived
	       would not be deleted.
	       E.g.
			class A { ... };  //  destructor of A is not a virtual function
			class B : public A { ... };

			A *ab = new class B;
			delete ab;  //  resoure of B would not be deleted.

	       if a class has virtual function,then pointer vptr and array vtbl would be contained.
	       vptr is "virtual table pointer"
	       vtbl is "virtual table"
	       	    //  exactly form of them is designed by implementation detail.
		    //  maybe not an array.
		    //  vptr and vtbl is not portiable! (it is the second part of C++)

	       it A has a virtual destructor,then statement 'delete ab' would invoke B::~B() first,then invoke
	       A::~A().

	       vtbl is used to determine which function should be invoke through object pointer or reference.
	       so,vptr and vtbl would increase size of class,if dont want such class as base class,should not
	       declare any virtual function in it.
	       (a class maybe occopied 64bits,but it will occopied 128bits if there has a virtual function in it.)

	       !!  polymorphic base classes should declare virtual destructors,if a class has any virtual functions,
	           it should have a virtual destructor.  !!
	       !!  classes not designed to be base classes or not designed to be used polymorphically should not
	           declare virtual destructors.  !!
		   #  STL and std::string and std::input_iterator_tag and etc. are not designed to allow the
		      manipulation of derived class objects via base class interfaces.
		      (dont inherit from STL !!)

	       !!  occasionally it can be convenient to give a class a pure virtual destructor,a class has pure virtual
	           function would be abstract class,it cant be instantiated.but if declare the destructor of this class
		   as a virtual function,have to defined its body,because of it is that when delete resource of a derived
		   class via destructor,the lateast invocation of function must be base class destructor.  !!


	 Item8 : Prevent exceptions from leaving destructors
	       C++ doest allows one too many exceptions is existed in program.
	       suppose,container v is destroying,then all element in it have to be destroyed,too.
	       the first destroy failed and throw an exception,but remainder is still have to be
	       destroyed,then the second exception is thrown in encountered.by the time,program
	       has two exceptions aliving,this is a problem.

	       if exception from destructor,then there is hard to react the condition that exception
	       was thrown.
	       several exceptions is aliving that cause premature program termination or undefined 
	       behavior.

	       First method :
	       	     use try { ... } catch () { ... } in destructor,there can ignore an exception from
		     try {} or deal with it in catch {}.
		     suppose a destructor will calls func() to does some works,but it maybe throw an
		     exception,then have to put the invocation of it into try {}.
		     deal with the exception or ignore it(just record log,but do nothing) is optional.

		     #  deal with the exception to terminate the program.
		     #  swallow the exception,record log and ignore it.

	       Second method :
	       	      wrap such function it might throw exception as a user interface,user should call that interface
		      manually even it recycle class resource.there has a way to capture such exception and can
		      react the condition in debugging time.of course,could deal with it or ignore it in program.

		      #  the exception has to come from some non-destructor function.

	       !!  destructors should never emit exceptions.if functions called in a destructor may throw,the destructor should
	           catch any exceptions,then swallow them or terminate the program(std::abort()). !!
	       !!  if class clients need to be able to react to exceptions thrown during an operation,the class should provide 
	           a regular function that performs the operation.  !!


	 Item9 : Never call virtual functions during construction or destruction
	       C++ dont allow to call virtual function during construction or destruction.
	       If base class call virtual function during constructor,and the derived class has override the virtual function,
	       when derived class is constructing,its virtual function would never be called by base class that the virtual
	       function had not been initialized.
	       During base class construction,virtual functions never go down into derived classes.
	       Calling down to parts of an object that have not yet been initialized is inherently dangerous.

	       E.g.
	         class A {
		   public:
		     A() { vfunction(); ... }
		     virtual void vfunction(void) { ... }
		     ...
		 };

		 class B : A {
		   public:
		     B() { ... }
		     //  during constructor of A,the vfunction is point to A::vfunction,not B::vfunction.
		     //  if A::vfunction is a pure virtual function,linker would cant find such function for link.
		     //  because instanse of the virtual function was made up after object of B is created.
		     virtual void vfunction(void) { *** }
		 };

	       #  not only do virtual functions resolve to the base class,but the parts of the language using runtime type
	       #  information treat the object as a base class type.(dynamic_cast ...)

	       An object doesnt become a derived class object until execution of a derived class constructor begins !
	       An object is a derived class object until execution of a derived class destructor begins !

	       The same reasoning applies during destruction.Once a derived class destructor has run,the object's derived class
	       data members assume undefined values.so at the time,the type of this object is that of base class.

	       #  All functions called in constructor or destructor each also cant calls virtual function.

	       Cant use virtual functions to call down from base classes during construction,but for compensate,can having derived
	       classes pass necessary construction information up to base class constructors.
	       Use a special named function in derived class to make parameter for base class constructor is more readable.

	       !!  dont call virtual functions during construction or destruction,because such calls will never go to a more
	           derived class than of the currently executing constructor or destructor.  !!


	 Item10 : Have assignment operators return a reference to *this
	 	The convention for assignment that is assignment returns a reference to its left-hand argument.
		So there could has such statement :
		  int x = 3;
		  int y, z;
		  y = z = x + 3;
		  //  y = (z = (x + 3))

		Ofcourse,the c++ class' assignment operator should follow the convention.
		Thus,these prototype is allowed in c++ class :
		  Class &Class::operator=(const Class &);
		  Class &Class::operator+=(const Class &);

		Each of these operator overload function should has statement "return *this;".

		#  The convention just a suggestion,code could pass compile without such convention,but all built-in types
		   are follow the convention,and the types in standard library also.

		!!  Have assignment operators return a reference to *this  !!


	 Item11 : Handle assignment to self in operator=
	 	self-assignment-safe :
		  int x = 3;
		  x = x;

		The statement is work fine,but in a class operator= overload,have to care implement code.
		>
		  class A {
		    public:
		      A &operator=(const A &oa)
		      {
		        delete vc;
			vc = makevc(oa.vc);
			return *this;
		      }

		      std::vector<char> *makevc(std::vector<char> *oldvc);

		      std::vector<char> *vc;
		  };

		  the operator= overload function in class A is both self-assignment-unsafe and exception-unsafe.
		  if &oa == this and an exception occured in makevc() ,the rest that is vc point to a deleted pointer.
		  (might another exception was thrown)

		  for prevent point to deleted pointer error,could add identity test top at the function.

		  A &operator=(const A &oa)
		  {
		    if (&oa == this)
		      return *this;
		    delete vc;
		    vc = makevc(oa.vc);
		    return *this;
		  }  //  identity test would reduce efficiency,if same objects assignment not often occur.

		  if &oa == this,then work fine,but while they are not,the function still exception-unsafe.
		  if an exception was thrown by makevc(),vc will point to a deleted pointer.
		  but there has a good idea to solve self-assignment-unsafe and exception-unsafe,that is assure the function
		  is exception-safe will let it becomes self-assignment-safe.

		  for prevent exception-unsafe could change order of statement(follow copy-and-swap) to deal with it :
		  
		  A &operator=(const A &oa)
		  {
		    decltype(this->vc) opvc = this->vc;
		    vc = makevc(oa.vc);
		    delete opvc;
		    return *this;
		  }

		  class could has swap() method to help implement copy-and-swap code.

		  void A::swap(A &a);
		  A &operator=(const A &oa)
		  {
			A temp(oa);
			swap(temp);
			return *this;
		  }

		  A variation on this theme takes advantage of the facs that 
		    a class's copy assignment operator may be declared to take its argument by value and 
		    passing something by value makes a copy of it
		    
		  A &operator=(A oa)
		  {
		    swap(oa);
		    return *this;
		  }

		  //  while call operator= for A,compiler would automatically create a temporary object that type of A.
		  //  then operator= invokes swap() to swap *this and oa.
		  //  but this approach sacrifices clarity.

		  //  A x, y;
		  //  x = y;  #  OK,y passed by value,then x swapped with temporary A object(copy of y).

		!!  make sure operator= is well-behaved when an object is assigned to itself.
		    Techniques include comparing address of source and target objects,
		    careful statement ordering,and copy-and-swap.  !!
		!!  make sure that any function operating on more than one objects behaves correctly
		    if two or more of the objects are the same.  !!


	 Item12 : Copy all parts of an object
	 	If data members for the class all type is built-in,then just use the compiler provided copy-constructor,
		program should work fine.
		but if it isnt in such case or the base class has data members isnt built-in type,the copy-constructor provided
		by compiler would cause problem.

		E.g.
		  class A {
		    public:
		      int x;
		      int y;

		    private:
		      char c;
		      void copyC(const A &);
		  };

		  the compiler provides copy-constructor is like this function :
		    A(const A &j)
		    {
		      x = j.x;
		      y = j.y;
		      copyC(j);
		    };  //  it's work well

		  but in another case, class has dynamic pointer
		  class A {
		    public:
		      int *x;
		      A() { x = new int[5]; }
		      ~A() { delete[] x; x = nullptr; }
		  }

		  the compiler provided copy-constructor just do assignment "x = j.x",after j was destroyed,
		  program try to access i.x would occur segmentfault,or occur the error while destroy i.
		  (access a memory is not in bound of program or delete a pointer twice)

		  for solve such problem,have to defined copy-constructor manually :
		    A::A(const A &j)
		    {
			x = new int[5];
			memcpy(x, j.x, sizeof(int) * 5);
		    }

		  the copy-assignment operator have to follow same conventions.
		  of course,dont just copy all parts of the derived class,should copy all parts of the base class as well.
		  E.g.
		    class A : public B { ... };
		    A::A(const A &x) : B(x) { ... }
		    //  derived class cant access data members in private of base class B,so have to call constructor of B
		        to copy base class,there would happen top-force-convert B(x),x would be resolved to type B.
			(type of x is A,A public inherit from B)
			(object convert derived-to-base-safe,object convert base-to-derived-unsafe)
			(the parts of derived class is not defined in base class,but derived class has the parts of base class)

		    A &A::operator=(const A &x) { B::operator=(x); ... }  //  manually invoke B::operator=()
		    //  there has same principle.

		  if copy-assignment operator and copy-constructor has same behavior for the class,should put the copying
		  statements into a common function,and it would be called by them.
		  //  this means,dont call copy-assignment operator in copy-constructor or
		      call copy-constructor in copy-assignment operator,assignment operator applies only to objects 
		      that have already been initialized,it had been existed(but constructor build a new object).
		      and perform an assignment on an object under construction would mean doing something to a 
		      not-yet-initialized object that makes sense only for an initialized object.

		!!  copying functions should be sure to copy all of an object's data members and all of its base class parts.  !!
		!!  dont try to implement one of the copying functions in terms of the other.
		    instead,put common functionality in a third function that both call.  !!


Chapter3> Resource Management

	 Item13 : Use objects to manage resources
	   	The situations would cause memory leak :
		  1> forget to call delete for memory dynamically allocated.
		  2> try to delete memory before block exit but program exited the block before
		     the delete statement was executed.
		  3> before delete statement was executed,program thrown an exception.

		E.g.
		  int *f(void) { return new int; }  // caller may be forget to call delete.

		  void f(void) { int *x = new int; return; delete x; return; }
		  // delete statement would never be executed.
		  
		  void fex(void) noexcept(false)
		  {
		    throw 3;
		  }

		  void f(void)
		  {
		    int *x = new int;
		    fex();
		    delete x;
		    return;
		  }

		  // before the delete statement was executed,an exception occurred,
		  // but function f dont catch it,so the exception would be delivered to
		  // the caller of f (next to next until find try-catch block which catch int exception).
		  // there would happens stack-unwinding,the resource on stack would be
		  // automatically deleted,but the dynamic memory in heap,they would never
		  // be deleted.

		For prevent resource leaks,have to use class object to manage it,because the destructor would be automatically
		invoked while the block which contains the object exit.
		but if the manager is allocated also through dynamic memory allocating,would happens same problems.

		RAII (Resource Acquisition Is Initialization) :
		  
		  c++ provides smart pointer to help manage resource.
		  std::auto_ptr      	(deleted since c++11)

		  //  RCSP (reference-counting smart pointer) had been merged into RAII.
		  std::unique_ptr	(since c++11)
		  std::shared_ptr	(since c++11)

		  //  std::shared_ptr is the feature of TR1,but all TR1 features had merged into c++11 RAII.
		  //  before c++11,the shared_ptr has namespace resolve std::tr1::

		  for use RAII to manage resource,just do assignment to the class object with acquired pointer.

		  E.g.
		    int *x = new int;
		    std::auto_ptr<int> pI(x);  //  the destructor of auto_ptr would invoke delete to its pointer,
		    		       	       //  it means would execute "delete x;" in it.

		  #  dont delete a pointer more than once,so cant manually execute "delete x;" after assign x to pI.

		  #  std::auto_ptr is allowed to copying but have not same behavior with other copiable class.
		     E.g.
		       int *x = new int;
		       std::auto_ptr<int> pI1(x);
		       std::auto_ptr<int> pI2(pI1);

		       //  pI1 would delivers its ownership to pI2 for the pointer.
		       //  then pI2 == x,pI1 == null.
		  #  std::shared_ptr is allowed to copying.
		     the resource was managed by std::shared_ptr would be deleted until the last std::shared_ptr object is
		     destroyed.(this is alike of linux file descriptor)

		#  RAII object just invoke "delete" in its destructor,dont invoke "delete[]".
		   so cant use RAII object to manage an array pointer.
		   because STL container contains some array similar containers,if there is not reasonable,dont use
		   user-defined array structure.

		!!  to prevent resource leaks,use RAII objects that acquire resources in their constructors and release them
		    in their destructors.  !!
		!!  resource is not only contains memory,but also contains file-descriptor,socket,mutex,semphore,etc.  !!

	 Item14 : Think carefully about copying behavior in resource-managing classes
	 	For heap-resource,RAII classes work fine,but they cant be used for stack-resource,because the resource was 
		managed by RAII class object would be deleted after the destructor called.
		For this reason,have to implement a user-defined RAII-alike class to manage resource.

		There has some problems to do copy for such class object.
		Several possibilities :
		  1>  prohibit copying :
		        If copying makes no sense for an RAII class,should prohibit copying.
			(resource dont allows to be copied,or each such resource is unique)

		  2>  reference-count the underlying resource :
		        resource allows to be copied,but there should has a counter to count references.this is alike of 
			linux file-descriptor(or std::shared_ptr class).could simply let the user-defined class to contains
			std::shared_ptr object to implement reference-counter.but the resource is stack-resource,so the second
			argument of constructor of std::shared_ptr class should is a user-defined function(the Deleter) it dont
			delete resource.(std::shared_ptr default delete resource).

		  3>  copy the underlying resource :
		        for example,std::string class.when try to copy a string object,its copy-functions would does deep copying.
			so user-defined RAII-alike class also do deep copying as well.

		  4>  transfer ownership of the underlying resource :
		        maybe the resource if only if has one owner at same time,copy-function should not does deep copying,it have
			to transfer ownership for the resource to another class object.(e.g. std::unique_ptr)

		!!  if no sense to make copying,then prohibit it,if need reference-count,should use std::shared_ptr.  !!
		!!  copying an RAII object entails copying the resource it manages,so the copyong behavior of the resource 
		    determines the copying behavior of the RAII object.  !!
		!!  common RAII class copying behaviors are disallowing copying and peforming reference counting,but other behavior
		    are possible.  !!
		    (this means,the reference-counter should be a static data member,or take synchronization during copying)


	 Item15 : Provide access to raw resources in resource-managing classes
	 	Sometimes,code need to accesses the raw resource inside an RAII class.
		e.g.
		  void func(struct A *a);

		but if such struct object is managed by a RAII class,this invoke would fault :
		  std::unique_ptr<struct A> a = std::make_unique<struct A>();
		  func(a);  //  ERROR,func() expect an argument of type struct A pointer,
		  	    //  but a is type of std::unique_ptr.

		generally,there has two ways to support raw resource accessing :
		  1>  explicit
		  2>  implicit

		  explicit :
		    use a member method to covert underlying resource explicitly.
		    some RAII class provide get() member method to supports raw resource accessing,
		    like this :
		      T* std::unique_ptr::get(void) const { return @__raw_resource_pointer; }

		    so func() could be invoke with these codes :
		      func(a.get());
		    if program accesses raw resource frequently,so everywhere try to access the raw resource have to use
		    get() member method.it is a off-putting way.

		  implicit :
		    use operator overload to implement implicit coverting.
		    like this :
		      T *operator RAW_TYPE(RAII_TYPE) const { return @__raw_resoure_pointer; }
		    this way could prevent off-putting explicit convert,but it also cause some problem.
		    that is unintended type conversions.

		    //  T *struct USER_RAII::operator T*() const
		    //	{
		    //	  return @__raw_pointer;
		    //	}
		    struct USER_RAII<struct A> ur(new struct A);
		    struct A *la = ur;
					//  ur is an RAII class can has managed a unamed struct A object.
					//  la = ur try to assign ur to la,there would occurs implicit covert,
					//  type USER_RAII -> type struct A*.
		  
		    the raw resource would be released after ur was destructed,la would becomes dangle pointer.

		other problems :
		  provide a way to access raw resource maybe occurs encapsulation contrary.
		  but RAII class dont exist to encapsulate something,it exist to ensure that a particular action
		  - resource release - takes places.
		  mention this is for noticify that the design detail have to be pay attention.
		  but c++ class supports friend declaring,that is same as this discussion..

		!!  APIs often require access to raw resources,so each RAII class should offer a way to get at the resource 
		    it manages.  !!
		!!  access may be via explicit conversion or implicit conversion.in general,explicit conversion is safer,but
		    implicit conversion is more convenient for clients.  !!


	 Item16 : Use the same form in corresponding uses of new and delete
	  	Two things happen during employ a new expression for create an object :
		  1>  memory allocated
		  2>  one or more constructors are called for that memory
		Two things happen during employ a delete expression for destroy memory :
		  1>  if it is exist,then call destructor for that memory
		  2>  destroy memory

		but there has a important question,how many constructors should be called?
		>  delete expression just destroy one unit of memory,so just one destructor
		   would be invoked.
		   but delete[] expression should destroy more memory units as well,so there
		   would happens such number of destructors to be invoked for the memory units.

		so,have to pair 'new' and 'delete',and also have to pair 'new[]' and 'delete[]'
		program would has fault for these case each is not a good pair :
		  new <> delete[]
		    SIGSEGV : try to destroy more memory units than allocated,
		    or the remainder units allow to be accessed,but they are not suit type possible
		    to be destroyed via destructor.
		  new[] <> delete
		    only destroy the first memory unit of the memory units were allocated by new[]

		attention :
		  caution of use typedef with an array :
		    typedef std::string theArray[4];
		    std::string *pS = new theArray;
		    delete pS;  //  wrong,must use delete[] to destroy pS because the underlying type of theArray
		    	   	//    is an array of std::string.

		    //  for prevent this,abstain use typedef to define custom array-like struct,use STL container to
		    //  instead.
		    //  e.g.  std::vector<std::string> *pS = new std::vector<std::string>;

		!!  if use [] in a new expression,must use [] in the corresponding delete expression.
		    if dont use [] in a new expression,must not use [] in the corresponding delete expression.  !!
		!!  abstain use typedef keyword to define custom array-like structure,use STL container to 
		    instead of such method as well.  !!


	 Item17 : Store newed objects in smart pointers in standalone statements
	 	Example :
		  int priority(void);
		  void processWidget(std::shared_ptr<Widget> pw, int priority);

		  A call to processWidget() :
		    processWidget(new Widget, priority());

		 if there has no member function which convert Widget to std::shared_ptr<Widget>,compiler would
		 throw an error.
		 of course,even the first parameter of processWidget is "std::shared_ptr<int> pi",then would 
		 thrown an error though passed a int pointer via (new int).(need a convert function)

		 another problem on there,the evaluate order for function argument is unknown.
		 In C program,all function parameter would be pushed into stack in the order right->left,
		 C++ program is apply such rule.

		 suppose,compiler executes (new Widget) at first,then call priority(),call constructor of 
		 std::shared_ptr::shared_ptr() at last;
		 if there is an exception thrown by priority(),then the memory allocated by new expression
		 would leak,its pointer lost.normally,the pointer should be managed by pw,but exception prevent the 
		 action to construct pw.

		 A good method is use standalong statement to construct the first argument for processWidget() :
		   std::shared_ptr<Widget> pw(new Widget);
		   processWidget(pw, priority());

		   //  it is possible to send reference to instead value copy for std::shared_ptr object.

		!!  store newed objects in smart pointers in standalone statements.failure to do this can lead to
		    subtle resource leaks when exception are thrown.  !!


Chapter4> Designs and Declarations
	  Software designs :
	    begin as fairly gerneral ideas,but they eventually become detailed enough to allow for the development
	    of specific interfaces.these interfaces must then be translated into c++ declarations.

	  A good design for interfaces :
	    they should be easy to use correctly and hard to use incorrectly.

	    <correctness,efficiency,encapsulation,maintainability,extensibility,conformance to convention ...>

	 Item18 : Make interfaces easy to use correctly and hard to use incorrectly
		C++ is awash in interfaces,interface allows client to interact with code.
		if the interface does not do the work client wants it to do,then code would not compile;
		if the code does compile,it will do what the client wants.

		develop an interface which is easy to use correctly and hard to use incorrectly,that means
		developer have to consider the kinds of mistakes that clients might make.

		if there is not reasonable dont let interface has difference to built-in types.
		because non-local static objects has different initialization orders,so have to use wrapper to wrap
		theit initialization as well.
		the real reason for avoiding gratuitous imcompatibilities with the built-in types is to offer interfaces
		that behave consistency,for example,C++ STL containers have a member function size() to indicates how many
		elements in it,and for std::string,has length() member method to indicates how many characters in it.
		such methods has same effect with the subscript index of built-in array type.

		//  inconsistency imposes mental friction into a developer's work.
		//  any interface that requires that clients remember to do something is prone to incorreect use,
		    because clients can forget to do it.

		could create a new type and restrict its behavior to prevent some interface errors :
		  E.g.
		    void func(unsigned day, unsigned month, unsigned year);

		    struct Day {
		      ...
		      unsigned d;
		    };

		    struct Month {
		      ...
		      unsigned m;
		    };

		    struct Year {
		      ...
		      unsigned y;
		    };

		    void func(const Day &day, const Month &month, const Year &year);  //  new version

		    //  these structures should has some methods to check assignment and get current data member!
		    //  if it is possible,should prevent use enum type because enum can be used like int.
		    //  for predefine type Month from January to December,code could defines some static function which
		    //  has same name as January ... December like this : (the following code does not use enum type)
		    	  static struct Month January(void)
			  {
			    return Month(1);
			  }
			  static struct Month February(void) { return Month(2); }
			  ...


 		"cross-DLL" error :
		  this problem crops up when an object is deleted using "new" in one dynamically linked library but is
		  deleted in a different DLL.(runtime error for a lot of platforms)
		>  smart pointer could solve such "cross-DLL" error,because smart pointer has a data member named deleter,
		   deleter is a function which would be called in smart pointer' destructor to delete underlying resource.
		   deleter have to be bound when smart pointer object creating,so the object and its deleter would in the 
		   same DLL.if another DLL try to delelte the object,then a DLL which contains its deleter also would be
		   loaded.(deleter would recycle underlying resource)

		//  Boost's shared_ptr (tr1::shared_ptr) is twice the size of a raw pointer,uses dynamically allocated
		    memory for bookkeeping and deleter-specific data,uses a virtual function call when invoking its 
		    deleter,and incurs thread synchronization overhead when modifying the reference count in an application
		    it believes is multithreaded.

		!!  good interfaces are easy to use correctly and hard to use incorrectly.should strive for these
		    characteristics in all interfaces.  !!
		!!  ways to facilitate correct use include consistency in interfaces and behavioral compatiblility with
		    built-in types.  !!
		!!  ways to prevent errors include creating new types,restricting operations on types,constrainting object
		    values,and eliminating client resource management responsibilities.  !!
		!!  smart pointer supports custom deleters,this prevents the cross-DLL problem,can be used to automatically
		    unlock mutexes.  !!


	 Item19 : Treat class design as type design
	   designing a new class is designing a new type.but good types have a natural syntax,intuitive semantics,
	   and one or more efficient implementations.

	   there has some questions about how to design a new type :
	     how should objects of new type be created and destroyed?
	       the answer would influences how to define constructor and destructor.

	     how should object initialization differ from object assignment?
	       the answer determines the behavior of and the differences between constructors and assignment operators.

	     what does it mean for objects of new type to be passed by value?
	       !copy-constructor defines the meaning.

	     what are the restrictions on legal values for new type?
	       !not all combinations of values is valid for class's data members.

	     does your new type fit into an inheritance graph?
	       if new type enter inheritance graph,then have to consider restrictions in the new type,
	       it would derives restrictions from base class,and restrict the child classes.

	     what kind of type conversion are allowed for new type?
	       explicit conversion is more safe than implicit conversion,but it is a matter for frequently call.
	       if wish the new type could convert to several types,then have to define many convert functions.

	     what operators and functions make sense for the new type?
	       the answer determines which functions will declare for class,some will be member methods,but some
	       will not.

	     what standard functions should be disallowed?
	       define the function as private member to prevent compiler automatically creates.

	     who should have access to the members of new type?
	       accessing permission.

	     what is the "undeclared interface" of new type?
	       kind of guarantees does it offer with respect to performance,exception-safety,and resource usage?
	       
	     how general is new type?
	       if wish to define a whole family of types,then should to define a new class template.

	     Is a new type really need?
	       sometimes,the built-in types does good works,and sometimes,define a derived class from built-in class
	       does good works,and sometimes,just define some non-member functions or templates is enough.

	       !!  class design is type design,before defining a new type,be sure to consider all the problems would
	       	   appears at designing.  !!


	 Item20 : Prefer pass-by-reference-to-const to pass-by-value
	 	function parameters are initialized with copies of the actual arguments,and function caller get back a
		copy of the value returned by the function.(inherit from C default)
		for copy object,have to call copy-constructor to the object,this would be expensive.

		a lot of C++ implementations treat reference as a pointer,so pass a pointer to bypass constructor and
		destructor is more efficient than pass-by-value on C++ class object.
		there has a example :
		  class A {
		    string a;
		    string b;
		  };
		  
		  class B : public {
		    string c;
		    string d;
		  };

		  function(class B cb);
		  class B theb;
		  function(theb);

		  //  there would happens six constructor invocation and six destructor invocation. 
		      1<B::constructor> + 2<B::string object constructors>
		      + 1<A::constructor> + 2<A::string object constructors>
		      destructor invocation is same.

		slice problem :
		  //  use above example.
		  function(class A a);
		  function(theb);

		  //  A::copy-constructor would be called, A::copy-constructor(const A &);
		      class B is inherit from class A,so a reference to A could refer a object is type of B.
		      but specialized features make the object behave like a derived class object are "sliced off".
		      
		  //  inside of function(),object a has same behavior as class A,but the argument theb
		      is treat as class A object,even it is type of class B inherit from class A.
		      (if there has some virtual function defined in them,slice problem would bring disaster.)

		  pass-by-reference can prevent slice problem,invoke virtual function via reference has different
		  behavior.
		  if dont want the object theb would be changed inside function(),have to use const qualified parameter.
		  pass-by-reference-const


		what is the time to pass-by-value?
		: 
		  use pass-by-value on inexpensive built-in-types(int,char, ...),
		  use pass-by-value on STL iterator and function object types(especial designed type).

		  but pay attention,double object is expensive,because it is longer than long int,
		  and have to use FPU unit(have to use XMM register save).so should pass a double object with
		  pass-by-reference-const is more efficent than pass-by-value.

		#  it is not all small object could pass-by-value,user-defined small type should not pass-by-value.
		   e.g.
		     struct b {
		       double bb;
		     };

		     double bbb;

		     //  bb and bbb might have different size in different C++ implementation,
		         and struct would be filled in normally.

		!!  prefer pass-by-reference-to-const over pass-by-value.it is typically more efficient and it avoids
		    the slicing problem.  !!
		!!  the rule doesnt apply to built-in types and STL iterator and function object types.for them,
		    pass-by-value is usually appropriate.  !!
		  

	 Item21 : Dont try to return a reference when you must return an object
	 	the sense of the title of current section is obviously.
		function can returns a pointer or reference of lvalue object,but if the lvalue object inside the 
		function is not	dynamically allocated,then it would be destroyed after function returned.
		if the function returns a lvalue reference which refers to an internal object but which is not
		dynamically allocated,then the lvalue reference would becomes a dangle reference,the object
		it refers to had been destroyed,it not exist.
		(after function returned,the data object in its frame would be recycle)

		E.g.
		  auto &func(void)
		  {
		    int a(3);
		    return a;
		  }

		  int b = func();  //  try to assign b with a insed func(),but the reference is a 
		      	  	   //  dangle reference.

		  auto &func(void)
		  {
		    std::string s("hello world!");
		    return s;
		  }

		  std::string ls(static_cast<const std::string &>(func()));
		  //  ERROR,no such std::string object is exist.

		  auto func(void)
		  {
		    std::string s("hello world!");
		    return s;
		  }

		  std::string ls(func());
		  //  OK,func() returns a rvalue has type std::string,
		  //  move-constructor std::string::string(const string &&) would be called.

		
		the another point,use dynamically allocated object how to prevent memory leak?
		if caller have to invoke delete on the pointer,but in some situations it is not possible
		to do.
		E.g.
		  class A {
		  public:
		    A &operator+(const A a, const A b)
		    {
		      A *tempA = new A(a.i + b.i);
		      return *tempA;
		    }
		  private:
		    int i;
		  };

		  A a(1), b(2), c(3);
		  A result = a + b + c;  //  potential memory leak.
		    	       	     	 //  a + b would create tempA on heap.
					 //  (a + b) + c would create another tempA on heap.
					 //  then the first tempA is no way to be destroyed,
					 //  because it is created during compound expression.


		of course,static local object could prevent memory leak,but it is not thread-safety.
		E.g.
		  struct A {
		    A &operator+(const A &a, const A &b)
		    {
		      static A tempA(a.i + b.i);
		      return tempA;
		    }
		    bool operator==(const A &a, const A &b)
		    {
		      return a.i == b.i;
		    }
		    int i;
		  };

		  A a(1), b(2), c(3), d(4);
		  if ((a + b) == (c + d))
		    <T expression>
		  else
		    <F expression>

		  //  the condition would always true.
		  //  because tempA would be constructed at first time operator+ is invoking.
		  //  tempA.i has value 3.
		  //  then (c + b) dont create new tempA object,because it is static storage duration.
		  //  (a + b) and (c + d) both returns same tempA object,so the condition always true.

		!!  never return a pointer or reference to a local stack object,a reference to a heap-allocated object,
		    or a pointer or reference to a local static object if there is a chance that more than one such
		    object will be needed.  !!

					 
	 Item22 : Declare data members private
	 	private offers encapsulation and accessing controls.
		for the public data members,anyone can read-write them,and they are unchangeable,because if they changed,
		all client code used them have to be rewritten.
		for the protected data members,they are as same as public data members,unencapsulation,unchangeable,all
		derived class can read-write them.if they changed,all derived class used them have to be rewritten.

		so public and protected doesnt offer implementation flexibility.
		why private data members offer encapsulation and accessing controls,and also offer implementation flexibility?
		>  first,private member just can be accessed by client via public interfaces,this provides accessing control.
		   //  because accessing via class method,designer can free to make some mechanisms for notify accessing in
		       thread environment(save mechanism)(fine-grained access control).

		   second,client code doesnt use private member directly,it accessing through public interface,so private
		   members is free to change,if public interface was not changed.this provides encapsulation.

		   third,if there has more effeciency implementation,can eazy to change their implementations,client just
		   need to recompile program.this provides implementation flexibility.
		   //  e.g. x % 10 ==> x - (x / 10) * 10

		protected data members are not more encapsulated than public data members.
		syntactic consistency and fine-grained access control is clearly as applicable to protected data as 
		to public data.

		something is encapsulation is inversely proportional to the amount of code that might be broken if that
		something changes.the encapsulatedness of a data member,then is inversely proportional to the amount of
		code that might be broken if that data member changes.

		//  if want to provide public interface to access private member,can follow this name-format :
		      T <action><member_name>(arg-list);
		    E.g.
		      class A {
		      public:
		        auto getInode(void) const { return _the_inode; }
			void setInode(decltype(_the_inode) i) { _the_inode = i; }
		      private:
		        unsigned _the_inode;
		      };

		!!  declare data members private.it gives clients syntactically uniform access to data,affords
		    fine-grained access control,allows invariants to be enforced,and offers class authors 
		    implementation flexibility.  !!
		!!  protected is no more encapsulated than public.  !!


	 Item23 : Prefer non-member non-friend functions to member functions
	 	object-oriented principles dictate that data and the functions that operate on them should be bundled
		together.object-oriented principles dictate that data should be as encapsulated as possible.
		but the principles does not dictate have to pack compound-functionality together.
		  for example :
		    object A has actions jump,walk,run
		    when try to encapsulate it,there should has action functions jump,walk,run
		    but should not has action function run-jump,walk-jump,
		    because the compound functionality is not own to A,they are compounded actions,
		    if such action functions were existed,will lost some encapsulation,
		    counterintuitive,will yield greater packaging flexibility and fewer compilation dependecies and
		    increase extensibility.

		if something is encapsulated,it is hidden from view,the more something is encapsulated,the fewer things
		can see it,the greater flexibility we have to change it,because our changes directly affect only those
		things that can see what we change.
		encapsulation affords the flexibility to change things in a way that affects only limited number of clients.
		the more functions that can access it,the less encapsulated the data.

		//  member functions and friend functions have same access to private member,
		//  but non-member non-friend function have to access private member via member functions or friend functions,
		//  so define a non-member non-friend function to operate object does not less encapsulation,because the more
		//  functions that can access it,the less encapsulated the data.

		//  note,a function be a non-member of one class doesnt mean it cant be a member of another class.

		benefits of non-member non-friend functions :
		  convenience functions(functionality) could be defined in another namespace another source file,
		  dont have to be contained in class definition file.
		  for example,std::vector in <vector>,std::list in <list>,if user dont need such functionality,then dont
		  need include such headers,because there is no reason for these functionality to be compilation dependent on.
		  user could free to extend functionality just create new header and define convenience functions.
		  class member function is encapsulated and closed to extension by other user,even class could be derived,
		  but not all class is allowed to be inherited.if create a new class inherited from other,then there has more
		  class status have to be keep and pay attention.

		!!  prefer non-member non-friend functions to member functions.doing so increases encapsulation,
		    packaging flexibility,and functional extensibility.  !!


	 Item24 : Declare non-member functions when type conversions should apply to all parameters
	 	make implicit conversion for a class is not a good idea,but sometimes,it is necessary.
		for example,C++ built-in type conversion from int to double is reasonable,it would not loss data.
		(but from double to int is a bad idea)
		when design a class type,maybe let it supports some type conversion from built-in to class.
		
		a invocation of a function,compiler would try to convert parameter type for satisfy function parameter
		type if argument is not same type.for built-in type,C++ supports conversion,but for user-defined type,
		have to provide conversion by yourself.
		  e.g.
		    class Rational_Number {
		    	  ...
		    	  const Rational_Number operator*(const Rational_Number &);
		    };
		    
		    Rational_Number oneEight(1, 8);
		    Rational_Number result = oneEight * 2;   //  OK,call operator overload function
		    Rational_Number result2 = 2 * oneEight;  //  FAILED,because 2 does not has operator overload function

		    //  extend to function call form :
		      result = oneEight.operator*(2);  //  compiler does implicit conversion from 2 to temporary Rational_Number
		      	       			       //  through its constructor.(constructor cant be explicit requirement)
		      result = 2.operator*(oneEight);  //  compiler cant find a eligible operator* function to call

		    //  but multiplication is commutative.

		  parameters are eligible for implicit type conversion only if they are listed in the parameter list.
		  the implicit parameter corresponding to the object on which the member function is invoked-the one this points to -
		  is never eligible for implicit conversions.
		  there has a way to solve such problem that is non-member function :
		    const Rational_Number operator*(const Rational_Number &, const Rational_Number &);
		    //  the statement "result2 = 2 * oneEight",compiler can use this operator overload function to
		    //  implement function call and implicit type conversion from 2 to Rational_Number.

		remember,a function shouldnt be a member doesnt automatically mean it should be a friend.of course,maybe
		sometimes a non-member friend function is necessary,but for the example is no need.

		!!  if need type conversions on all parameters to a function(including the one that would otherwise
		    be pointed to by the this pointer),the function must be a non-member.  !!
		
		
		   
