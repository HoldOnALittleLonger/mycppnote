C++20>

> Feature testing macro
    Attributes
      __has_cpp_attribute(<attribute-token>)

      checks for the support of an attribute named by attribute-token
      __has_cpp_attribute can be expanded in the expression of #if and #elif.
      it is treated as a defined macro by #ifdef,#ifndef and defined but cannot be
      used anywhere else.

      attribute-token list :
      	attribute-token	   attribute			standard	value
      
        assume	      	   [[assume]]			C++23		202207L
	carries_dependency [[carries_dependency]]	C++11		200809L
	deprecated	   [[deprecated]]		C++14		201309L
	fallthrough	   [[fallthrough]]		C++17		201603L
	likely		   [[likely]]			C++20		201803L
	maybe_unused	   [[maybe_unused]]		C++17		201603L
	no_unique_address  [[no_unique_address]]	C++20		201803L
	nodiscard	   [[nodiscard]]		C++17		201603L || 201907L
	noreturn	   [[noreturn]]			C++11		200809L
	unlikely	   [[unlikely]]			C++20		201803L

      //  more language features and library features were predefined in standard,
      //  and cant not use __has_attribute to as checking for support,should use 
      //  #ifdef,#if defined,#ifndef,#if .etc
      	  e.g.
	    #if __cpp_aligned_new >= 201606L
	    ...
	    #endif


> Three-way comparison
    the three-way comparison operator expressions has the form 
      a <=> b
    the expression returns an object such that
      (a <=> b) < 0 if a < b
      (a <=> b) > 0 if a > b
      (a <=> b) == 0 if a and b are equal/equivalent

    //  if one of the operands is of type bool and the other is not,the program is ill-formed.
    //	if a narrowing coversion is required,the program is ill-formed.

    if a and b have integral type,the operator yields a prvalue of type std::strong_ordering :
      std::strong_ordering::equal if both operands are arithmetically equal.
      std::strong_ordering::less if the first operand is arithmetically less than the second.
      std::strong_ordering::greater otherwise.

    if a and b have floating-point type,and the operator yields a prvalue of type std::partial_ordering :
      std::partial_ordering::less if a is less than b.
      std::partial_ordering::greater if a is greater than b.
      std::partial_ordering::equivalent if a is equivalent to b.
      std::partial_ordering::unordered (NaN <=> anything is unordered)

    if both operands have type of enumeration type E,then the operands will convert to the 
    underlying type of E and compare again.

    if at least one of the operands is a pointer or pointer-to-member,array-to-pointer conversions,
    derived-to-base pointer conversions,function pointer conversions,and qualification conversions
    are applied as necessary to convert both operands to the same pointer type,and the resulting pointer
    type is an object pointer,p <=> q returns a prvalue of type std::strong_ordering :
      std::strong_ordering::equal if p == q.
      std::strong_ordering::less if p < q.
      std::strong_ordering::greater if p > q.
      unspecified result if comparison is unspecified for these pointer values.

    other situation means program is ill-form.

    //  header <compare>
    //  could not convert comparison object to bool type.


> Default comparisons (since C++20)
    provides a way to request the compiler to generate consistent comparison operators for a class.

    syntax :
      <return-type> <class-name>::operator<op>(cons <class-name>&) const &(optional) = default;
      friend <return-type> operator<op>(const <class-name>&, coonst <class-name>&) = default;
      friend <return-type> operator<op>(<class-name>, <class-name>) = default;
      <return-type> <class-name>::operator<op>(this const <class-name>&, const <class-name>&) = default;
      <return-type> <class-name>::operator<op>(this <class-name>, <class-name>) = default;

      return-type - return type  of the operator function,must be 
      		    auto or one of three comparison category types if op is <=>
		    otherwise,bool

    defaulted three-way comparison :
      the default operator<=> performs lexicographical comparison by successively comparing the base
      (left-to-right,depth-first) and then non-static member(in declaration order) subobjects of T to
      compute <=> ,recursively expanding array members(in order of increasing subscript),and stopping
      early when a not-equal result is found.

      //  it is unspecified whether virtual base subobjects are compared more than once.

    defaulted equality comparison :
      a class can define operator== as defaulted,with a return value of bool.this will generate an equality
      comparison of each base class and member subobject,in their declaration order.
      two objects are equal if the values of their base classes and members are equal.

    other defaulted comparison operators :
      any of the four relational operators(<,>,<=,>=) can be explicitly defaulted.
      a defaulted relational operator must have the return type bool.

    strong ordering :
      operator<=> that returns std::strong_ordering is an operator that compares every member of a class,
      except in order that is different from the default.

    weak ordering :
      operator<=> that returns std::weak_ordering is an operator that compares string members of a class
      in case-insensitive manner: this is different from the default comparison and it is possible to 
      distinguish two strings that compare equal under this comparison.

    partial ordering :
      partial ordering is an ordering that allows incomparable(unordered) values,such as NaN values in
      floating-point ordering.

    custom comparisons and comparison categories :
      when the default semantics are not suitable,such as when the members must be compared out of order,
      or must use a comparison that is different from their natural comparison,then the programmer can write
      operator<=> and let the compiler generate the appropriate two-way comparison operators.
      the kind of two-way comparison operators generated depends on the return type of the user-defined
      operator<=> .

    
> Designated initializers (since C++20)
    syntax :
      T object = {.des1 = arg1, .des2{arg2} ...};
      T object{.des1 = arg1, .des2{arg2} ...};

    each designator must name a direct non-static data member of T,and all designators used in the 
    expression must appear in the same order as the data members of T.

    //  Linux kernel style initializing in C allows different order.(not in C++)


> init-statements and initializers in range-for
    range-for,executes a for loop over a range.
    used as a more readable equivalent to the traditional for loop operating over a range of values,
    such as all elements in a container.

    syntax :
      <attr>(optional) for (<init-statement>(optional) <range-declaration> : <range-expression>)
      		         <loop-statement>


      init-statement : since C++20
        an expression statement(which may be a null statement ";").
	a simple declaration,typically a declaration of a variable with initializer,
	but it may declare arbitrarily many variables or be a structured binding declaration.
	an alias declaration.(since C++23)
	(init-statement end with a semicolon ";")
      range-declaration : 
        a declaration of a named variable,whose type is the type of the element of the sequence
	represented by range-expression,or a reference to that type.
      range-expression :
        any expression that represents a suitable sequence
	(array,object which defined begin() and end() or free functions,braced-init-list)

    if range-expression returns a temporary,its lifetime is extended until the end of the loop.(C++23)

    e.g.
      std::vector<int> intVec;
      intVec.push(0);
      intVec.push(1);
      intVec.push(2);

      for (int i(2); auto x : intVec) {
        std::cout<<"Value : ";
        std::cout<<i * x<<std::endl;
      }


> char8_t (since C++20)
    char8_t type : as the declaration of the type.
    (char16_t, char32_t, since C++11)


> new attributes 
    [[no_unique_address]]  since C++20
      allows this data member to be overlapped with other non-static data members or base class subobjects of
      its class.
      applies to the name being declared in the declaration of a non-static data member that is not a bit-field.

      e.g.
        struct A {};
	struct B : public A {
	  int x;
	  [[no_unique_address]] char c;
	};

    [[likely]], [[unlikely]]  since C++20
      allow the compiler to optimize for the case where paths of execution including that statement are more or 
      less likely than any alternative path of execution that does not include such a statement.

      e.g.
        if (i > 0) [[likely]] {
	  return i * 2;
	} else {
	  return i * 10;
	}

	switch (i) {
	  [[likely]] case 7:
	    return i + 3;
	  case 2:
	    return ++i;
	  default:
	    return i;
	}


> Pack-expansions in lambda init-captures
    template pack is could to extend on lambda init-captures (C++20)

    e.g.
      template<typename _Type, class ..._TypePack>
      void func(_Type &&arg, _TypePack... tp)
      {
        if (sizeof...(tp) != 0)
	  std::cout<<std::forward<_Type>(arg)<<std::endl;

        auto local_func = [&, tp...] (void)
	{
	  return func(tp...);
	};
      }

      void func(void) {};

    //  sizeof... operator is classified as a pack expansion as well.
    //  ellipsis appears on right side means do a pack expansion.
    //    e.g.  (tp + ...) => (tp0 + (tp1 + (tp2 + ...)))
    //	  e.g.  g(std::forward<_TypePack>(tp)...); => 
    //	  	g(std::forward<_TypePackE1>(A1), std::forward<_TypePackE2>(A2), ...);


> removed the requirement to use typename to disambiguate types in many contexts
    e.g.
      struct A {
        typedef UserCustomType int;
      };

      typename A::UserCustomType a;  //  a has type of int,
      	       	       	   	     //  but in C++20,does not need typename keywrod any more.


> consteval specifier and constinit specifier
    consteval - specifies that a function is an immediate function,that is,every call to the
    function must produce a compile-time constant.(contains function template)

    every potentially-evaluated call to the function must produce a compile time constant expression.
    an immediate function is a constexpr function,same as constexpr,a consteval specifier implies inline,
    but consteval may not be applied to destructors,allocation functions,or deallocation functions.
    e.g.
      consteval int sqr(int n) { return n * n; }
      constexpr int x = sqr(3);  //  OK,evaluate sqr(3) produce constant 3 * 3.
      consteval int sqrsqr(int n) { return sqr(sqr(n)); }  //  OK,but not a constant expression,
      		    	       	    	   		   //  because @n is variable.
      //  function enclose a consteval function have to be a consteval function too.

    constinit - asserts that a variable has static initialization, i.e. zero initialization and 
    constant initialization,otherwise the program is ill-formed.

    the constinit specifier declares a variable with static or thread storage duration.
    (have to use it with 'static' or 'thread_local' together)

    if a variable is declared with constinit,its initializing declaration must be applied with constinit.
    (constexpr can produce constant at compile-time)

    if a variable declared with constinit has dynamic initialization(even if it is performed as static
    initialization),the program is ill-formed.

    if no constinit declaration is reachable at the point of the initializing declaration,the program is 
    ill-formed,no diagnostic required.
    !!  constinit cannot be used together with constexpr or consteval.

    when the declared variable is a reference,constinit is equivalent to constexpr.
    when the declared variable is an object,constexpr mandates that the object must have static
    initialization and constant destruction and makes the object const-qualified,but constinit
    does not mandate constant destruction and const-qualified.
    e.g.
      static constinit int x(3);	//  variable x is static and initialized with 3
      thread_local constinit int y(4);	//  variable y is thread_local and initialized with 4
      
      const char *g() { return "dynamic initialization."; }
      constexpr const char *f(bool p) { return p ? "constant initializer" : g(); }
      constinit const char *c = f(true);  //  OK,f(true) returns const char *,and f() is constexpr
      //constinit const char *c = f(false);  //  ERROR,even g() returns const char *,but g() is not constexpr.


> further relaxed constexpr


> signed integers are 2's complement
    ones' complement : -2^(N-1) - 1 -- 2^(N-1) - 1
      3 = 011 (signed)
      -3 = 100 (signed) (inverse all bits)

    two's complement : -2^(N-1) -- 2^(N-1) - 1
      3 = 011 (signed)
      -3 = 101 (signed) (inverse all bits and plus 1)


> bitwise shift operators unified behavior
    the value of a << b is the unique value congruent to a * 2^b modulo 2^N where N
    is the number of bits in the return type.
    that is,bitwise left shift is performed and the bits that get shifted out of the 
    destination type are discarded.
    the value of a >> b is a / 2^b,rounded down.
    in other words,right shift on signed a is arithmetic right shift.


> aggregate initialization using parentheses
    syntax :
      T object = {.des1 = arg1, .des2{arg2} ...};
      T object{.des1 = arg1, .des2{arg2} ...};


> coroutines (C++20)
    A coroutine is a function that can suspend execution to be resumed later.
    coroutines are stackless:
      they suspend execution by returning to the caller and the data that is required to
      resume execution is stored separately from the stack.

    this allows for sequential code that executes asynchronously,and also supports algorithms
    on lazy-computed infinite sequences and other uses.

    a function is a coroutine if its definition contains any of the following :
      the co_await expression to suspend execution until resumed.
      the co_yield expression to suspend execution returning a value.
      the co_return statement to complete execution returning a value.

      //  every coroutine must have a return type that satisfies a number of requirements.
    restrictions :
      coroutines cannot use variadic arguments,plain return statements,or placeholder return
      types.
      consteval functions,constexpr functions,constructors,destructors,and the main function
      cannot be coroutines.

    each coroutine associated with -
      the promise object,manipulated from inside the coroutine,coroutine submits its result or
      exception through this object.
      the coroutine handle,manipulated from outside the coroutine,this is a non-owning handle
      used to resume execution of the coroutine or to destroy the coroutine frame.
      the coroutine state which is internal,dynamically-allocated storage,object that contains -
        the promise object,
	the parameter,all copied by value,
	suspension point,
	local variables and temporaries whose lifetime spans the current suspension point.

    routine execution :
      it will performs the following :
        allocates the coroutine state object via operator new().

	copies all function parameters to the coroutine state,by-value parameters are moved
	or copied,by-reference parameters remain references.

	calls the constructor for the promise object,if the promise type has a constructor that
	takes all coroutine parameters,that constructor is called,with post-copy coroutine arguments,
	otherwise the default constructor is called.

	calls promise.get_return_object() and keeps the result in a local variable,it will be returned
	to the caller when the coroutine first suspends,any exceptions thrown up to and including this 
	step propagate back to the caller,not placed in the promise.

	calls promise.initial_suspend() and co_awaits its result,typical promise types either return a
	std::suspend_always,for lazily-started coroutines,or std::suspend_never,for eagerly-started 
	coroutines.
	  std::suspend_always :
	    empty class used to indicates that await awaiter always suspend coroutine and dont 
	    produce value.
	  std::suspend_never :
	    empty class used to indicates that await awaiter never suspend coroutine and dont
	    produce value.

	when co_await promise.initial_suspend() resumes,starts executing the body of the coroutine.
	(co_await promise::initial_suspend() means program will invokes three functions in the
	 awaiter returned by initial_suspend().
	 awaiter::await_ready -> awaiter::await_suspend -> awaiter::await_resume.
	 after awaiter::resume() has been finished,initial_suspend() resumed.)

	//  caller calls coroutine_handle<PromiseType>.resume() or coroutine_handle<PromiseType>()
	//  will resume coroutine from initial_suspend(),if it returned std::suspend_always.

    when a coroutine reaches a suspension point :
      the return object obtained earlier(from get_return_object()) is returned to the caller/resumer,
      after implicit conversion to the return type of the coroutine,if necessary.

    when a coroutine reaches the co_return statement :
      it performs the following :
        calls promise.return_void() for
          co_return;
	  co_return <expr>; where expr has type void
	  falling off the end of the coroutine,the behavior is undefined if the promise type has no
	  promise::return_void() member function in this case.

        or calls promise.return_value(<expr>) for "co_return <expr>;" where expr has non-void type.
      
        destroys all variables with automatic storage duration in reverse order they were created.
      
        calls promise.final_suspend() and co_awaits the result.


    if coroutine state object is destroyed,then destructor of promise object will be called,also
    calls function parameters' destructor,and free memory used by coroutine state,transfers 
    execution back to the caller/resumer.

    coroutine state is allocated dynamically via non-array operator new,if promise type has a class-level
    operator new() for replacement,then calls this,otherwise calls ::new().

    //  the call to operator new() can be optimized out(even if custom allocator is used) if 
     	  the lifetime of the coroutine state is strictly nested within the lifetime of the caller,and
	  the size of coroutine frame is known at the call site.

    coroutine handle :
      a coroutine handle behaves a lot like a C pointer.it can be easily copied,but it does not have 
      a destructor to free the memory associated with coroutine state.to avoid leaking memory,user must
      generally destroy coroutine state by calling the coroutine_handle::destroy method.
      if coroutine handle had been destroyed,it can not be use again.
      for access a coroutine from outer,have to existed a coroutine_handle which is refers to the coroutine.
      there has three ways to do this :
      >
        defintion a struct which is inherited from std::coroutine_handle<PromiseType>,coroutine will returns
	an object is type of this struct,caller could call handle.resume() or handle() to access coroutine.
	e.g.
	  struct promise;
	  struct coroutine : std::coroutine_handle<promise> {
	    using promise_type = promise;
	    ...
	  };
      >
        let the type CoroutineReturn contains promise_type,and represented a handle is type of 
	std::coroutine_handle<PromiseType>.
	define coversions covert CoroutineReturn to std::coroutine_handle<PromiseType> and std::coroutine_handle<>,
	coroutine caller can easy to delcared a handle which is used to hold the coroutine_handle returned by 
	coroutine.
	e.g.
	  struct coroutine {
	    struct promise_type {
	      ...
	    };
	    std::coroutine_handle<promise_type> handle;
	    operator std::coroutine_handle<promise_type>() const { return handle; }
	    operator std::coroutine_handle<>() const { return handle; }
	  };
      > define awaiter that hold a std::coroutine_handle pointer object,and assign it with the coroutine handle
        in await_suspend().this is require coroutine receive a std::coroutine_handle pointer as the argument
	of awaiter's constrouctor.
	e.g.
	  struct coroutine;
	  struct promise;
	  struct awaiter {
	    std::coroutine_handle<> *_pPromise;
	    ...
	    void await_suspend(std::coroutine_handle<> h) { *_pPromise = h; }
	    ...
	  };

	  //  template<typename _PromiseType> struct coroutine_handle : coroutine_handel<>;

	  coroutine function(std::coroutine_handle<> *p)
	  {
	    /*  co_await promise::initial_suspend(); */
	    /*  awaiter::resume() executed,the return value as expression value  */

	    //  before encouter "co_await a;",coroutine should not return to caller,
	    //  this ensure that caller has a way to access coroutine.(awaiter sets promise object for handle)
	    //  so initial_suspend() have to returns std::suspend_never.
	    awaiter a{p};
	    co_await a;
	  }

	  void caller(void)
	  {
	    std::coroutine_handle<> outer_handle;
	    function(&outer_handle);
	    outer_handle();
	  }


    promise :
      the promise type is determined by the compiler from the return type of the coroutine using
      std::coroutine_traits.
      coroutine library use the typename promise_type as an identifier for a promise,like this
      CoroutineType::promise_type.(CoroutineType have to be an object type and nested promise_type)

      a promise object at least must has these members :

        CoroutineType get_return_object();
	  get_return_object() have to returns coroutine object instance.its result will saved
	  in a local variable,and will be returned to coroutine caller when first suspend.
	  that is the time to co_await the result of inital_suspend().
	  this is why a coroutine definition has a return value is of type CoroutineType object.
	  generally,use "std::coroutine_handle<CoroutineType>::from_promise(*this)" is able to
	  get the coroutine object instance.

	Awaiter initial_suspend();
	  initial_suspend() will be called once when the coroutine is start to executing.

	Awaiter final_suspend();
	  final_suspend() will be called when encouter "co_return" statement.

	//  Awaiter == std::suspend_never || std::suspend_always || others

	void return_void();
	  for return void.

	void unhandled_exception();
	  for exception deal with.

	//  Awaiter will be used when "co_await" statement is process.
	//  promise object could has more data members.

      if client wants to access promise_type,should use a handle "std::coroutine_handle<PromiseType>" 
      instance,member method promise() will return a reference to promise_type object.

      e.g.
        struct coroutine {
	  struct promise_type {
	    int i;
	    ...
	  };
	  std::coroutine_handle<promise_type> _ptch;
	  operator std::coroutine_handle<promise_type>() const { return _ptch; }
	};

	struct awaiter {
	  ...
	  coroutine::promise_type *_pp;
	  ...
	  void await_suspend(std::coroutine_handle<coroutine::promise_type> h)
	  {
	    _pp = &h.promise();
	  }
	  coroutine::promise_type *await_resume() { return _pp; }
	};

	//  this awaiter let coroutine is able to access its own promise object in coroutine state
	//  instance.

	coroutine func()
	{
	  awaiter a;
	  co_await a;  //  suspend coroutine,

	  	       //  when first suspend(co_await intial_suspend()),
		       //  the coroutine object returned by get_return_object()
		       //  will return to caller.
	}

	void main1(void)
	{
	  std::coroutine_handle<coroutine::promise_type> chcp = func();  //  calls covert function
	  coroutine::promise_type &promise = chcp.promise();
	  promise.i;
	  promise.destroy();  //  destroy
	}

	//  generally,outer of promise_type struct does not hold any data members that will be 
	//  accessed in caller,except handle object.
	//  a conventional method that is let promise_type holds such data members,and follow
	//  the example code above to access them in caller.


    co_await :
      the unary operator co_await suspends a coroutine and returns control to the caller.its operand
      is an expression that either is of a class type that defines a member operator co_await or
      may be passed to a non-member operator co_await;or is convertible to such a class type by
      means of the current coroutine's promise::await_transform.

      a co_await expression can only apper in a potentially-evaluated expression within a regular
      function body,and cannot appear -
        in an exception handler,
	in a declaration statement,unless it appears in an initializer of that declaration statement,
	in the simple declaration of an init-statement,unless it appears in an initialize of that
	init-statement,
	in a default argument,or in the initializer of a block-scope variable with static or thread
	storage duration.

      <first>
      expr is converted to an awaitable as follows :
        if expr is produced by an initial suspend point,a final suspend point,or a yield expression,
	the awaitable is expr,as-is.
	otherwise,if the current coroutine's promise type has the member function await_transform,
	then the awaitable is promise.await_transform(expr).
	otherwise,the awaitable is expr,as-is.
 
      awaiter object is obtained,as follows :
        if overload resolution for operator co_await gives a single best overload,the awaiter is the
	result of that call :
	  awaitable.operator co_await() for member overload,
	  operator co_await(static_cast<Awaitable&&>(awaitable())) for non-member overload.
	otherwise,if overload resolution finds no operator co_await,the awaiter is awaitable,as-is.
	otherwise,if overload resolution is ambiguous,the program is ill-formed.

      <second>
      awaiter.await_ready() is called,if its result,contextually-converted to bool is false,then,
      the coroutine is suspended,awaiter.await_suspend(handle) is called.

      <third>
      awaiter.await_suspend(handle) is called,where handle is the coroutine handle representing the
      current coroutine.inside that function,the suspended coroutine state is observable via that
      handle,and it is this function's responsibility to schedule it to resume on some executor,
      or to be destroyed.

      if await_suspend returns void,control is immediately returned to the caller/resumer of the
      current coroutine.
      if await_suspend returns bool,the value true returns control to the caller/resumer of the
      current coroutine,the value false resumes the current coroutine.
      if await_suspend returns a coroutine handle for some other coroutine,that handle is resumed.
      if await_suspend throws an exception,the exception is caught,the coroutine is resumed,and
      the exception is immediately re-thrown.

      <finally>
      awaiter.await_resume() is called(whether the coroutine was suspended),and its result is the
      result of the whole "co_await <expr>;" expression.
      if the coroutine was suspended in the co_await expression,and is later resumed,the resume
      point is immediately before the call to awaiter.await_resume().


    co_yield :
      co_yield expression returns a value to the caller and suspends the current coroutine,it is the
      common building block of the resumable generator functions.

      co_yield <expr>;
      co_yield <braced-init-list>;

      it is equivalent to 
        co_await promise.yield_value(expr);

	a typical generator's yield_value would store its argument into the generator object and return
	std::supend_always,transferring control to the caller/resumer.

    co_return :
      to signal the end of a coroutine,C++ adds a new co_return operator.there are three ways for a 
      coroutine to signal that it is complete :
        the coroutine can use "co_return e;" to return a final value e.
	the coroutine can use "co_return;" with no value(or with a void expression) to end the coroutine
	without a final value.
	the coroutine can let execution fall off the end of the function which is similar to previous case.

      if co_return returns void,then function "promise::return_void" will be called.
      if co_return returns a value,then function "promise::return_value" will be called.

      to find out if a coroutine is complete,user can call "coroutine_handle::done" on its coroutine_handle
      instance.do not confuse coroutine_handle::done() with coroutine_handle::operator bool(),the latter
      merely checks whether the coroutine hanlde contains a non-null pointer to coroutine memory,not 
      whether execution is complete.

    example:
      #include<coroutine>
      #include<iostream>
      
      struct promise;
      struct coroutine : std::coroutine_handle<promise> {
        using promise_type = ::promise;
      };

      struct promise {
        coroutine get_return_object() { return {coroutine::from_promise(*this)}; }
	std::suspend_always initial_suspend() noexcept { return {}; }
	std::suspend_always final_suspend() noexcept { return {}; }
	void return_void() {}
	void unhandled_exception() {}
      };

      coroutine func()
      {
        coroutine h = [](int i) -> coroutine
	{
	  std::cout<<i;
	  co_return;
	} (0);
	//  there,lambda function is a coroutine,argument is 0.
	//  co_return; returns control to caller/resumer,this statement calls 
	//  promise::return_void
	

	h.resume();
	h.destroy();
      }

    coroutine process figure :
      caller calls a coroutine ->
      enter coroutine ->

      allocate memory for coroutine state object ->
      copy all parameter to coroutine state object ->

      construct promise object ->
      calls promise::get_return_object() ->
      save result of get_return_object() in local storage(on heap) ->

      calls promise::initial_suspend() ->
      co_await the result of initial_suspend() ->
      calls awaiter::await_ready() ->
      awaiter::await_ready() returned false ->
      suspend coroutine ->
      calls awaiter::await_suspend(handle) ->
      calls awaiter::await_resume() ->

      return execution to caller ->
      caller resume coroutine ->

      coroutine have been resumed from intial_suspend() ->
      execute coroutine body ->

      encouter co_await <expr> statement ->
      try to covert expr to awaitible object(if necessary) ->

      calls awaiter::await_ready() ->
      await_ready() returned false ->
      suspend coroutine -> 
      calls awaiter::await_suspend(handle) ->
      calls awaiter::await_resume() ->

      return execution to caller(await_suspend() returns void or true) ->

      caller re-call coroutine ->
      coroutine resume,and execute next code ->

      ...
      ...

      encouter end of coroutine ->
      execute co_return or co_return v ->

      calls promise::return_void() or promise::return_value() ->
      free memory for local data(in reverse order) ->

      calls promise::final_suspend() ->
      co_await the result of final_suspend() ->

      coroutine stop,and return to caller.
      
      
> modules(C++20)
    most C++ projects use multiple translation units,and so they need to share declarations and
    definitions across those units.the usage of header is prominent for this purpose,an example
    being the standard library whose declarations can be provided by including the corresponding
    header.
    modules are a language feature to share declarations and definitions across translation units.
    they are an alternative to some use cases of headers.
    modules are orthogonal to namespaces.

    syntax :
      export(optional) module <module-name> <module-partition>(optional) <attr>(optional);
      export <declaration>
      export { <declaration-seq>(optional) }
      export(optional) import <module-name> <attr>(optional);
      export(optional) import <module-partition> <attr>(optional);
      export(optional) import <header-name> <attr>(optional);
      module;
      module : private;

      1>  module declaration,declares that the current translation unit is a module unit.
      2,3>  export declaration,export all namespace-scope declarations in declaration or
      	    declaration-seq.
      4,5,6>  import declaration,import a module unit/module partition/header unit.
      7>  starts a global module fragment.
      8>  starts a private module fragment.

    module declarations :
      a translation unit may have a module declaration,in which case it is cosidered a module
      unit.(all content in this translation unit)
      module declaration must be the first declaration of the translation unit,if provided.
      (except the global module fragment)
      each module unit is associated to a module name.a named module is the collection of
      module units with the same module name.

      module interface unit : module unit whose declaration has the keyword 'export' are termed
      	     	       	      module interface unit.
      module implementation unit : other module units than module interface unit are termed
      	     		    	   module implementation unit.
      primary module interface unit : every named module.there must be exactly one module interface
      	      	     	       	      unit that specifies no module partition,this module unit is
				      termed the primary module interface unit.
				      its exported content will be available when importing the
				      corresponding named module.

      export module hello_world;      //  primary module interface unit.
      module hello_world;	      //  module implementation unit.
      export module A, B, C, D.E;     //  several primary module interface units.
      module A;	       	     	      //  module implementation unit.
      module B;
      module C;
      module D.E;

    exporting declarations and definitions :
      module interface units can export declarations,definitions,which can be imported by
      other translation units.
      to export a declaration,either prefix it with the 'export' or else place it inside
      an 'export' block.

      export int a = 3;
      export { int func(void){} void func2(int c){} }

    importing modules and headers :
      modules are imported via an import declaration.

      export(optional) import <module-name> <attr>(optional);

      all declarations and definitions exported in the module interface units of the given named
      module will be avaiable in the translation unit using the import declaration.
      import declarations can be exported in a module interface unit.that is,if module A export-imports
      B,then importing A will also make visible all export from B.

      in module units,all import declarations must be grouped after the module declaration and before
      all other declarations.

      e.g.
        export module A;	//  primary module interface unit
	export int a = 3;	//  export definition

	export module B;	//  primary module interface unit
	export import A;	//  export-import A

	export module C;	//  primary module interface unit
	import B;     		//  import B

	int b = a;		//  because B export-imports A.

	#include<iostream>
	  ...

      #include should not be used in a module unit(outside the global module fragment),because all
      included declartions and definitions would be considered part of the module.

      export(optional) import <header-name> <attr>(optional);

      importing a header will make accessible all its definitions and declarations.
      preprocessor macros are also accessible,but preprocessing macros defined in the translation
      unit will not affect the processing of the header.global module fragment can resolve this
      problem.

      e.g.
        export module A;
	import <vector>;
	export import <iostream>;

	#ifdef definitions or other processor macros in <vector> or <iostream> is not effect the header.

    global module fragment :
      module units can be prefixed by a global module fragment,which can be used to include headers when
      importing the headers is not possible.

      module;
      <preprocessing-directives>(optional)
      <module-declaration>

      if a module-unit has a global module fragment,then its first declaration must be 'module;'.
      a standard module declaration makrs the end of the global module fragment.

      e.g.
        module;		  //  global module fragment prefix
	
	#ifdef DEBUG
	...
	#endif

	#include<iostream>  //  #include can be used in global module fragment.

	export module A;  //  A marks global module fragment end

	...

    private module fragment :
      primary module interface unit can be suffixed by a private module fragment,which allows
      a module to be represented as a single translation unit without making all of the contents
      of the module reachable to importers.(alike static declaration)

      module : private;
      <declaration-seq>(optional)

      e.g.
        export module A;
	import <iostream>;
	
	export int a = 3;

	module : private;
	
	void function(void) {}	//  function is not reachable from importers of A.
      
      private module fragment ends the portion of the module interface unit that can affect the behavior
      of other translation units.if a module unit contains a private module fragment,it will be the only
      module unit of its module.

    module partitions :
      a module can have module partition units.they are module units whose module declarations include
      a module partition,which starts with a colon ':' and is placed after the module name.
      a module partition represents exactly one module unit,they are visible only from inside the named
      module.
      a module partition can be imported by module units of the same named module.other translation unit
      can import module partition directly.

      module <module-name>:<module-partition>;
      export module <module-name>:<module-partition>;
      export(optional) import <module-partition> <attr>(optional);

      e.g.
        export module A:B;	//  file1	partition module interface unit :B

	module A:C;   		//  file2	module parition unit :C

	export module A;	//  file3	primary module interface unit
	import :C;
	export import :B;	//  export-import module partition unit(also a interface)

      all definitions and declarations in a module partition are visible by the importing module unit,
      whether exported or not.
      a module parition unit prefix 'export' also a module interface unit.they must be export-imported
      by the primary module interface unit,and their exported statements will be visible when the module
      is imported.

    module ownership :
      in general,if a declaration appears after the module declaration in a module unit,it is attached to that
      module.
      if a declaration of an entity is attached to a named module,that entity can only be defined in that module.
      all declarations of such an entity must be attached to the same module.
      if a declaration is attached to a named module,and it is not exported,the declared named has module
      linkage.

      //  have to prevent ambiguity.

      module ownership modle :
        in the weak module ownership model,such declarations are considered to declare the same entity.
        in the strong module ownership model,they are considered to declare different entities.

	e.g.
	  file1 :
	    export module A;
	    export void func(void) {}

	  file2 :
	    export module B;
	    export void func(void) {}

	  file3 :
	    import A;
	    import B;

	    //  void func(void){} now is visible in file3.
	    //  weak :
	    	  A::func and B::func are considered to declare the same entity,
		  linker may pick either
		strong :
		  A::func and B::func are different entities.

      //  e.g.
            export module A;

	    namespace dd {		    //  namespace definitions with external linkage.
	      export extern "C++" int f();  //  declarations within a language linkage specification.
	      export extern "C++" int g();
	      export int h();
	    }

	    //  f and g are not attached to A.
	    //  h is attached to A.
	    //  dd::h must be defined in A,dd::f and dd::g can be defined in somewhere outside A.


> constraints and concepts
    class templates,function templates,and non-template functions(typically members of class templates)
    may be associated with a constraint,which specifies the requirements on template arguments,which
    can be used to select the most appropriate function overloads and template specializations.
    the named sets of such requirements are called concepts.

    concept is predicate,evaluated at compiling time,and becomes a part of the interface of a template
    where it is used as a constraint.

    concept is made for model semantic categories rather than syntactic restrictions.

    concept :
      a concept is a named set of requirements,the definition of a concept must appear at 
      namespace scope.

      syntax :
        template<template-parameter-list>
	concept <concept-name> <attr>(optional) = <constraint-expression>;

      concept can be a part in id-expression.
      concept can be named in a type-constraint,as part of type template parameter declaration,
      placeholder type specifier,compound requirement.

      attention :
        concept is not allowed to recursive.
	concept is not allowed to explicit instantiation,explicit specialization,partial specialization.
	(the meaning of the original definition of a constraint cant be changed)

	in a type-constraint,a concept takes one less template argument than its parameter list demands,
	because the contextually deduced type is implicitly used as the first argument of the concept.
	e.g.
	  template<class T, class U>
	  concept C = std::is_base_of<U, T>::value;

	  template<C<Base> T>  //  T as the first argument.
	  void func(void) {}

    constraints :
      a constraint is a sequence of logical operations and operands that specifies requirements on 
      template arguments.they can appear within require expressions or directly as bodies of 
      concepts.

      the constraint associated with a declaration are determined by normalizing a logical AND
      expression whose operands are in the following order :
        >  the constraint expression introduced for each constrained type template parameter or
	   non-type template parameter declared with a constained placeholder type,in order of
	   appearance.
	>  the constraint expression in the requires clause after the template parameter list.
	>  the constraint expression introduced for each parameter with constrained placeholer type
	   in an abbreviated function template declaration.
	>  the constraint expression in the trailing requires clause.

	e.g.
	  template<class T>
	  concept C = requires (T a) {
	    typename a::value; 	  //  a must has type value.
	    ++a;     		  //  a must supports ++a operation.
	  };

	  template<class X>
	  void function(void) requires C<X> {}

	  template<class Y>
	  requires C<Y>
	  void g(void) {}

	  template<C Y>
	  void h(void) {}

      constraint is allows to redeclare but have to using the same syntactic form.
      e.g.
        template<C Y>
	void g(void) {}
	
	template<class Y>
	requires C<Y>		//  logically-equivalent-but-syntactically-different
	void g(void) {}		//  ill-form

	
      

      three type of constraints :
        conjunctions >
	  the conjunction of two constraints is formed by using the && operator in the 
	  constraint expression.

	disjunctions >
	  the disjunction of two constraints is formed by using the || operator in the
	  constraint expression.

	atomic constraints >
	  an atomic constraint consists of an expression E and a mapping from the template
	  parameters that appear within E to template arguments involving the template
	  parameters of the constrained entity,called its parameter mapping.
	
	  atomic constraints are formed during constraint normalization.E is never a logical
	  AND or logical OR expression.

	  atomic constraints checking have to do parameter mapping,use template arguments
	  do substitution for template parameter which appears in E.if E is not an valid
	  type or expression,checking will failure,otherwise,do lvalue-to-rvalue conversion,
	  shall be a prvalue constant expression of type bool.if result is true,satisfied,
	  if result is false,satisfy failed.

      constraint normalization :
        constraint normalization is the process that transforms a constraint expression into
	a sequence of a conjunctions and disjunctions of atomic constraints.

      partial ordering of constraints :
        before any further analysis,constraints are normalized by substituting the body of
	every named concept and every requires expression until what is left is sequence of
	conjunctions and disjunctions on atomic constraints.

	a constraint P is said to subsume constraint Q if it can be proven that P implies
	Q up to the identify of atomic constraints in P and Q.

	(N > 0 does not subsume N >= 0)

      requires expression :
        yields a prvalue expression of type bool that describes the constraints.

	syntax :
	  requires { <requirement-seq> }
	  requires (<parameter-list>(optional) { <requirement-seq> }

	  requirement-seq : sequence of requirements,each requirements is one of the following
	  		      simple requirement
			      type requirements
			      compound requirements
			      nested requirements

        simple requirements :
	  a simple requirement is an arbitrary expression statement that does not start with the
	  keyword requires.it asserts that the expression is valid.the expression is an unevaluated
	  operand;only language correctness is checked.

	  e.g.
	    template<class T>
	    concept C = requires(T a) {
	      typename a::tag;
	      ++a;
	    };

	type requirements :
	  a type requirements is the keyword typename followed by a type name,optionally qualified.
	  the requirement is that the named type is valid :
	    this can be used to verify that a certain named nested type exists,or that a class
	    template specialization names a type,or that an alias template specialization names
	    a type.

	  a type requirement naming a class template specialization does not require the type to
	  be complete.

        compound requirements :
	  a compound requirement has the form :
	    { <expression> } noexcept(optional) <return-type-requirement>(optional);

	    return-type-requirement : -> <type-constraint>

	    if return-type-requirement is present,then :
	      template arguments are substituted into the return-type-requirement,
	      decltype((expression)) must satisfy the constraint imposed by the 
	      type-constraint.other wise,the enclosing requires-expression is false.

        nested requirements :
	  a nested requirement has the form :
	    requires <constraint-expression>;

	  it can be used to specify additional constraints in terms of local parameters.
	  the constraint-expression must be satisfied by the subsiituted template arguments,
	  if any.

	  
	  

