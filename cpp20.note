C++20>

> Feature testing macro
    Attributes
      __has_cpp_attribute(<attribute-token>)

      checks for the support of an attribute named by attribute-token
      __has_cpp_attribute can be expanded in the expression of #if and #elif.
      it is treated as a defined macro by #ifdef,#ifndef and defined but cannot be
      used anywhere else.

      attribute-token list :
      	attribute-token	   attribute			standard	value
      
        assume	      	   [[assume]]			C++23		202207L
	carries_dependency [[carries_dependency]]	C++11		200809L
	deprecated	   [[deprecated]]		C++14		201309L
	fallthrough	   [[fallthrough]]		C++17		201603L
	likely		   [[likely]]			C++20		201803L
	maybe_unused	   [[maybe_unused]]		C++17		201603L
	no_unique_address  [[no_unique_address]]	C++20		201803L
	nodiscard	   [[nodiscard]]		C++17		201603L || 201907L
	noreturn	   [[noreturn]]			C++11		200809L
	unlikely	   [[unlikely]]			C++20		201803L

      //  more language features and library features were predefined in standard,
      //  and cant not use __has_attribute to as checking for support,should use 
      //  #ifdef,#if defined,#ifndef,#if .etc
      	  e.g.
	    #if __cpp_aligned_new >= 201606L
	    ...
	    #endif


> Three-way comparison
    the three-way comparison operator expressions has the form 
      a <=> b
    the expression returns an object such that
      (a <=> b) < 0 if a < b
      (a <=> b) > 0 if a > b
      (a <=> b) == 0 if a and b are equal/equivalent

    //  if one of the operands is of type bool and the other is not,the program is ill-formed.
    //	if a narrowing coversion is required,the program is ill-formed.

    if a and b have integral type,the operator yields a prvalue of type std::strong_ordering :
      std::strong_ordering::equal if both operands are arithmetically equal.
      std::strong_ordering::less if the first operand is arithmetically less than the second.
      std::strong_ordering::greater otherwise.

    if a and b have floating-point type,and the operator yields a prvalue of type std::partial_ordering :
      std::partial_ordering::less if a is less than b.
      std::partial_ordering::greater if a is greater than b.
      std::partial_ordering::equivalent if a is equivalent to b.
      std::partial_ordering::unordered (NaN <=> anything is unordered)

    if both operands have type of enumeration type E,then the operands will convert to the 
    underlying type of E and compare again.

    if at least one of the operands is a pointer or pointer-to-member,array-to-pointer conversions,
    derived-to-base pointer conversions,function pointer conversions,and qualification conversions
    are applied as necessary to convert both operands to the same pointer type,and the resulting pointer
    type is an object pointer,p <=> q returns a prvalue of type std::strong_ordering :
      std::strong_ordering::equal if p == q.
      std::strong_ordering::less if p < q.
      std::strong_ordering::greater if p > q.
      unspecified result if comparison is unspecified for these pointer values.

    other situation means program is ill-form.


> Default comparisons (since C++20)
    provides a way to request the compiler to generate consistent comparison operators for a class.

    syntax :
      <return-type> <class-name>::operator<op>(cons <class-name>&) const &(optional) = default;
      friend <return-type> operator<op>(const <class-name>&, coonst <class-name>&) = default;
      friend <return-type> operator<op>(<class-name>, <class-name>) = default;
      <return-type> <class-name>::operator<op>(this const <class-name>&, const <class-name>&) = default;
      <return-type> <class-name>::operator<op>(this <class-name>, <class-name>) = default;

      return-type - return type  of the operator function,must be 
      		    auto or one of three comparison category types if op is <=>
		    otherwise,bool

    defaulted three-way comparison :
      the default operator<=> performs lexicographical comparison by successively comparing the base
      (left-to-right,depth-first) and then non-static member(in declaration order) subobjects of T to
      compute <=> ,recursively expanding array members(in order of increasing subscript),and stopping
      early when a not-equal result is found.

      //  it is unspecified whether virtual base subobjects are compared more than once.

    defaulted equality comparison :
      a class can define operator== as defaulted,with a return value of bool.this will generate an equality
      comparison of each base class and member subobject,in their declaration order.
      two objects are equal if the values of their base classes and members are equal.

    other defaulted comparison operators :
      any of the four relational operators(<,>,<=,>=) can be explicitly defaulted.
      a defaulted relational operator must have the return type bool.

    strong ordering :
      operator<=> that returns std::strong_ordering is an operator that compares every member of a class,
      except in order that is different from the default.

    weak ordering :
      operator<=> that returns std::weak_ordering is an operator that compares string members of a class
      in case-insensitive manner: this is different from the default comparison and it is possible to 
      distinguish two strings that compare equal under this comparison.

    partial ordering :
      partial ordering is an ordering that allows incomparable(unordered) values,such as NaN values in
      floating-point ordering.

    custom comparisons and comparison categories :
      when the default semantics are not suitable,such as when the members must be compared out of order,
      or must use a comparison that is different from their natural comparison,then the programmer can write
      operator<=> and let the compiler generate the appropriate two-way comparison operators.
      the kind of two-way comparison operators generated depends on the return type of the user-defined
      operator<=> .

    
> Designated initializers (since C++20)
    syntax :
      T object = {.des1 = arg1, .des2{arg2} ...};
      T object{.des1 = arg1, .des2{arg2} ...};

    each designator must name a direct non-static data member of T,and all designators used in the 
    expression must appear in the same order as the data members of T.

    //  Linux kernel style initializing in C allows different order.(not in C++)


> init-statements and initializers in range-for
    range-for,executes a for loop over a range.
    used as a more readable equivalent to the traditional for loop operating over a range of values,
    such as all elements in a container.

    syntax :
      <attr>(optional) for (<init-statement>(optional) <range-declaration> : <range-expression>)
      		         <loop-statement>


      init-statement : since C++20
        an expression statement(which may be a null statement ";").
	a simple declaration,typically a declaration of a variable with initializer,
	but it may declare arbitrarily many variables or be a structured binding declaration.
	an alias declaration.(since C++23)
	(init-statement end with a semicolon ";")
      range-declaration : 
        a declaration of a named variable,whose type is the type of the element of the sequence
	represented by range-expression,or a reference to that type.
      range-expression :
        any expression that represents a suitable sequence
	(array,object which defined begin() and end() or free functions,braced-init-list)

    if range-expression returns a temporary,its lifetime is extended until the end of the loop.(C++23)

    e.g.
      std::vector<int> intVec;
      intVec.push(0);
      intVec.push(1);
      intVec.push(2);

      for (int i(2); auto x : intVec) {
        std::cout<<"Value : ";
        std::cout<<i * x<<std::endl;
      }


> char8_t (since C++20)
    char8_t type : as the declaration of the type.
    (char16_t, char32_t, since C++11)


> new attributes 
    [[no_unique_address]]  since C++20
      allows this data member to be overlapped with other non-static data members or base class subobjects of
      its class.
      applies to the name being declared in the declaration of a non-static data member that is not a bit-field.

      e.g.
        struct A {};
	struct B : public A {
	  int x;
	  [[no_unique_address]] char c;
	};

    [[likely]], [[unlikely]]  since C++20
      allow the compiler to optimize for the case where paths of execution including that statement are more or 
      less likely than any alternative path of execution that does not include such a statement.

      e.g.
        if (i > 0) [[likely]] {
	  return i * 2;
	} else {
	  return i * 10;
	}

	switch (i) {
	  [[likely]] case 7:
	    return i + 3;
	  case 2:
	    return ++i;
	  default:
	    return i;
	}


> Pack-expansions in lambda init-captures
    template pack is could to extend on lambda init-captures (C++20)

    e.g.
      template<typename _Type, class ..._TypePack>
      void func(_Type &&arg, _TypePack... tp)
      {
        if (sizeof...(tp) != 0)
	  std::cout<<std::forward<_Type>(arg)<<std::endl;

        auto local_func = [&, tp...] (void)
	{
	  return func(tp...);
	};
      }

      void func(void) {};

    //  sizeof... operator is classified as a pack expansion as well.
    //  ellipsis appears on right side means do a pack expansion.
    //    e.g.  (tp + ...) => (tp0 + (tp1 + (tp2 + ...)))
    //	  e.g.  g(std::forward<_TypePack>(tp)...); => 
    //	  	g(std::forward<_TypePackE1>(A1), std::forward<_TypePackE2>(A2), ...);


> removed the requirement to use typename to disambiguate types in many contexts
    e.g.
      struct A {
        typedef UserCustomType int;
      };

      typename A::UserCustomType a;  //  a has type of int,
      	       	       	   	     //  but in C++20,does not need typename keywrod any more.


> consteval specifier and constinit specifier
    consteval - specifies that a function is an immediate function,that is,every call to the
    function must produce a compile-time constant.(contains function template)

    every potentially-evaluated call to the function must produce a compile time constant expression.
    an immediate function is a constexpr function,same as constexpr,a consteval specifier implies inline,
    but consteval may not be applied to destructors,allocation functions,or deallocation functions.
    e.g.
      consteval int sqr(int n) { return n * n; }
      constexpr int x = sqr(3);  //  OK,evaluate sqr(3) produce constant 3 * 3.
      consteval int sqrsqr(int n) { return sqr(sqr(n)); }  //  OK,but not a constant expression,
      		    	       	    	   		   //  because @n is variable.
      //  function enclose a consteval function have to be a consteval function too.

    constinit - asserts that a variable has static initialization, i.e. zero initialization and 
    constant initialization,otherwise the program is ill-formed.

    the constinit specifier declares a variable with static or thread storage duration.
    (have to use it with 'static' or 'thread_local' together)

    if a variable is declared with constinit,its initializing declaration must be applied with constinit.
    (constexpr can produce constant at compile-time)

    if a variable declared with constinit has dynamic initialization(even if it is performed as static
    initialization),the program is ill-formed.

    if no constinit declaration is reachable at the point of the initializing declaration,the program is 
    ill-formed,no diagnostic required.
    !!  constinit cannot be used together with constexpr or consteval.

    when the declared variable is a reference,constinit is equivalent to constexpr.
    when the declared variable is an object,constexpr mandates that the object must have static
    initialization and constant destruction and makes the object const-qualified,but constinit
    does not mandate constant destruction and const-qualified.
    e.g.
      static constinit int x(3);	//  variable x is static and initialized with 3
      thread_local constinit int y(4);	//  variable y is thread_local and initialized with 4
      
      const char *g() { return "dynamic initialization."; }
      constexpr const char *f(bool p) { return p ? "constant initializer" : g(); }
      constinit const char *c = f(true);  //  OK,f(true) returns const char *,and f() is constexpr
      //constinit const char *c = f(false);  //  ERROR,even g() returns const char *,but g() is not constexpr.


> further relaxed constexpr

    