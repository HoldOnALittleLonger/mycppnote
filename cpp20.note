C++20>

> Feature testing macro
    Attributes
      __has_cpp_attribute(<attribute-token>)

      checks for the support of an attribute named by attribute-token
      __has_cpp_attribute can be expanded in the expression of #if and #elif.
      it is treated as a defined macro by #ifdef,#ifndef and defined but cannot be
      used anywhere else.

      attribute-token list :
      	attribute-token	   attribute			standard	value
      
        assume	      	   [[assume]]			C++23		202207L
	carries_dependency [[carries_dependency]]	C++11		200809L
	deprecated	   [[deprecated]]		C++14		201309L
	fallthrough	   [[fallthrough]]		C++17		201603L
	likely		   [[likely]]			C++20		201803L
	maybe_unused	   [[maybe_unused]]		C++17		201603L
	no_unique_address  [[no_unique_address]]	C++20		201803L
	nodiscard	   [[nodiscard]]		C++17		201603L || 201907L
	noreturn	   [[noreturn]]			C++11		200809L
	unlikely	   [[unlikely]]			C++20		201803L

      //  more language features and library features were predefined in standard,
      //  and cant not use __has_attribute to as checking for support,should use 
      //  #ifdef,#if defined,#ifndef,#if .etc
      	  e.g.
	    #if __cpp_aligned_new >= 201606L
	    ...
	    #endif


> Three-way comparison
    the three-way comparison operator expressions has the form 
      a <=> b
    the expression returns an object such that
      (a <=> b) < 0 if a < b
      (a <=> b) > 0 if a > b
      (a <=> b) == 0 if a and b are equal/equivalent

    //  if one of the operands is of type bool and the other is not,the program is ill-formed.
    //	if a narrowing coversion is required,the program is ill-formed.

    if a and b have integral type,the operator yields a prvalue of type std::strong_ordering :
      std::strong_ordering::equal if both operands are arithmetically equal.
      std::strong_ordering::less if the first operand is arithmetically less than the second.
      std::strong_ordering::greater otherwise.

    if a and b have floating-point type,and the operator yields a prvalue of type std::partial_ordering :
      std::partial_ordering::less if a is less than b.
      std::partial_ordering::greater if a is greater than b.
      std::partial_ordering::equivalent if a is equivalent to b.
      std::partial_ordering::unordered (NaN <=> anything is unordered)

    if both operands have type of enumeration type E,then the operands will convert to the 
    underlying type of E and compare again.

    if at least one of the operands is a pointer or pointer-to-member,array-to-pointer conversions,
    derived-to-base pointer conversions,function pointer conversions,and qualification conversions
    are applied as necessary to convert both operands to the same pointer type,and the resulting pointer
    type is an object pointer,p <=> q returns a prvalue of type std::strong_ordering :
      std::strong_ordering::equal if p == q.
      std::strong_ordering::less if p < q.
      std::strong_ordering::greater if p > q.
      unspecified result if comparison is unspecified for these pointer values.

    other situation means program is ill-form.


> Default comparisons (since C++20)
    provides a way to request the compiler to generate consistent comparison operators for a class.

    syntax :
      <return-type> <class-name>::operator<op>(cons <class-name>&) const &(optional) = default;
      friend <return-type> operator<op>(const <class-name>&, coonst <class-name>&) = default;
      friend <return-type> operator<op>(<class-name>, <class-name>) = default;
      <return-type> <class-name>::operator<op>(this const <class-name>&, const <class-name>&) = default;
      <return-type> <class-name>::operator<op>(this <class-name>, <class-name>) = default;

      return-type - return type  of the operator function,must be 
      		    auto or one of three comparison category types if op is <=>
		    otherwise,bool

    defaulted three-way comparison :
      the default operator<=> performs lexicographical comparison by successively comparing the base
      (left-to-right,depth-first) and then non-static member(in declaration order) subobjects of T to
      compute <=> ,recursively expanding array members(in order of increasing subscript),and stopping
      early when a not-equal result is found.

      //  it is unspecified whether virtual base subobjects are compared more than once.

    defaulted equality comparison :
      a class can define operator== as defaulted,with a return value of bool.this will generate an equality
      comparison of each base class and member subobject,in their declaration order.
      two objects are equal if the values of their base classes and members are equal.

    other defaulted comparison operators :
      any of the four relational operators(<,>,<=,>=) can be explicitly defaulted.
      a defaulted relational operator must have the return type bool.

    strong ordering :
      operator<=> that returns std::strong_ordering is an operator that compares every member of a class,
      except in order that is different from the default.

    weak ordering :
      operator<=> that returns std::weak_ordering is an operator that compares string members of a class
      in case-insensitive manner: this is different from the default comparison and it is possible to 
      distinguish two strings that compare equal under this comparison.

    partial ordering :
      partial ordering is an ordering that allows incomparable(unordered) values,such as NaN values in
      floating-point ordering.

    custom comparisons and comparison categories :
      when the default semantics are not suitable,such as when the members must be compared out of order,
      or must use a comparison that is different from their natural comparison,then the programmer can write
      operator<=> and let the compiler generate the appropriate two-way comparison operators.
      the kind of two-way comparison operators generated depends on the return type of the user-defined
      operator<=> .

    
> Designated initializers (since C++20)
    syntax :
      T object = {.des1 = arg1, .des2{arg2} ...};
      T object{.des1 = arg1, .des2{arg2} ...};

    each designator must name a direct non-static data member of T,and all designators used in the 
    expression must appear in the same order as the data members of T.

    //  Linux kernel style initializing in C allows different order.(not in C++)



    