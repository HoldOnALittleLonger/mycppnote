C++20>

> Feature testing macro
    Attributes
      __has_cpp_attribute(<attribute-token>)

      checks for the support of an attribute named by attribute-token
      __has_cpp_attribute can be expanded in the expression of #if and #elif.
      it is treated as a defined macro by #ifdef,#ifndef and defined but cannot be
      used anywhere else.

      attribute-token list :
      	attribute-token	   attribute			standard	value
      
        assume	      	   [[assume]]			C++23		202207L
	carries_dependency [[carries_dependency]]	C++11		200809L
	deprecated	   [[deprecated]]		C++14		201309L
	fallthrough	   [[fallthrough]]		C++17		201603L
	likely		   [[likely]]			C++20		201803L
	maybe_unused	   [[maybe_unused]]		C++17		201603L
	no_unique_address  [[no_unique_address]]	C++20		201803L
	nodiscard	   [[nodiscard]]		C++17		201603L || 201907L
	noreturn	   [[noreturn]]			C++11		200809L
	unlikely	   [[unlikely]]			C++20		201803L

      //  more language features and library features were predefined in standard,
      //  and cant not use __has_attribute to as checking for support,should use 
      //  #ifdef,#if defined,#ifndef,#if .etc
      	  e.g.
	    #if __cpp_aligned_new >= 201606L
	    ...
	    #endif


> Three-way comparison
    the three-way comparison operator expressions has the form 
      a <=> b
    the expression returns an object such that
      (a <=> b) < 0 if a < b
      (a <=> b) > 0 if a > b
      (a <=> b) == 0 if a and b are equal/equivalent

    //  if one of the operands is of type bool and the other is not,the program is ill-formed.
    //	if a narrowing coversion is required,the program is ill-formed.

    if a and b have integral type,the operator yields a prvalue of type std::strong_ordering :
      std::strong_ordering::equal if both operands are arithmetically equal.
      std::strong_ordering::less if the first operand is arithmetically less than the second.
      std::strong_ordering::greater otherwise.

    if a and b have floating-point type,and the operator yields a prvalue of type std::partial_ordering :
      std::partial_ordering::less if a is less than b.
      std::partial_ordering::greater if a is greater than b.
      std::partial_ordering::equivalent if a is equivalent to b.
      std::partial_ordering::unordered (NaN <=> anything is unordered)

    if both operands have type of enumeration type E,then the operands will convert to the 
    underlying type of E and compare again.

    if at least one of the operands is a pointer or pointer-to-member,array-to-pointer conversions,
    derived-to-base pointer conversions,function pointer conversions,and qualification conversions
    are applied as necessary to convert both operands to the same pointer type,and the resulting pointer
    type is an object pointer,p <=> q returns a prvalue of type std::strong_ordering :
      std::strong_ordering::equal if p == q.
      std::strong_ordering::less if p < q.
      std::strong_ordering::greater if p > q.
      unspecified result if comparison is unspecified for these pointer values.

    other situation means program is ill-form.

    //  header <compare>
    //  could not convert comparison object to bool type.


> Default comparisons (since C++20)
    provides a way to request the compiler to generate consistent comparison operators for a class.

    syntax :
      <return-type> <class-name>::operator<op>(cons <class-name>&) const &(optional) = default;
      friend <return-type> operator<op>(const <class-name>&, coonst <class-name>&) = default;
      friend <return-type> operator<op>(<class-name>, <class-name>) = default;
      <return-type> <class-name>::operator<op>(this const <class-name>&, const <class-name>&) = default;
      <return-type> <class-name>::operator<op>(this <class-name>, <class-name>) = default;

      return-type - return type  of the operator function,must be 
      		    auto or one of three comparison category types if op is <=>
		    otherwise,bool

    defaulted three-way comparison :
      the default operator<=> performs lexicographical comparison by successively comparing the base
      (left-to-right,depth-first) and then non-static member(in declaration order) subobjects of T to
      compute <=> ,recursively expanding array members(in order of increasing subscript),and stopping
      early when a not-equal result is found.

      //  it is unspecified whether virtual base subobjects are compared more than once.

    defaulted equality comparison :
      a class can define operator== as defaulted,with a return value of bool.this will generate an equality
      comparison of each base class and member subobject,in their declaration order.
      two objects are equal if the values of their base classes and members are equal.

    other defaulted comparison operators :
      any of the four relational operators(<,>,<=,>=) can be explicitly defaulted.
      a defaulted relational operator must have the return type bool.

    strong ordering :
      operator<=> that returns std::strong_ordering is an operator that compares every member of a class,
      except in order that is different from the default.

    weak ordering :
      operator<=> that returns std::weak_ordering is an operator that compares string members of a class
      in case-insensitive manner: this is different from the default comparison and it is possible to 
      distinguish two strings that compare equal under this comparison.

    partial ordering :
      partial ordering is an ordering that allows incomparable(unordered) values,such as NaN values in
      floating-point ordering.

    custom comparisons and comparison categories :
      when the default semantics are not suitable,such as when the members must be compared out of order,
      or must use a comparison that is different from their natural comparison,then the programmer can write
      operator<=> and let the compiler generate the appropriate two-way comparison operators.
      the kind of two-way comparison operators generated depends on the return type of the user-defined
      operator<=> .

    
> Designated initializers (since C++20)
    syntax :
      T object = {.des1 = arg1, .des2{arg2} ...};
      T object{.des1 = arg1, .des2{arg2} ...};

    each designator must name a direct non-static data member of T,and all designators used in the 
    expression must appear in the same order as the data members of T.

    //  Linux kernel style initializing in C allows different order.(not in C++)


> init-statements and initializers in range-for
    range-for,executes a for loop over a range.
    used as a more readable equivalent to the traditional for loop operating over a range of values,
    such as all elements in a container.

    syntax :
      <attr>(optional) for (<init-statement>(optional) <range-declaration> : <range-expression>)
      		         <loop-statement>


      init-statement : since C++20
        an expression statement(which may be a null statement ";").
	a simple declaration,typically a declaration of a variable with initializer,
	but it may declare arbitrarily many variables or be a structured binding declaration.
	an alias declaration.(since C++23)
	(init-statement end with a semicolon ";")
      range-declaration : 
        a declaration of a named variable,whose type is the type of the element of the sequence
	represented by range-expression,or a reference to that type.
      range-expression :
        any expression that represents a suitable sequence
	(array,object which defined begin() and end() or free functions,braced-init-list)

    if range-expression returns a temporary,its lifetime is extended until the end of the loop.(C++23)

    e.g.
      std::vector<int> intVec;
      intVec.push(0);
      intVec.push(1);
      intVec.push(2);

      for (int i(2); auto x : intVec) {
        std::cout<<"Value : ";
        std::cout<<i * x<<std::endl;
      }


> char8_t (since C++20)
    char8_t type : as the declaration of the type.
    (char16_t, char32_t, since C++11)


> new attributes 
    [[no_unique_address]]  since C++20
      allows this data member to be overlapped with other non-static data members or base class subobjects of
      its class.
      applies to the name being declared in the declaration of a non-static data member that is not a bit-field.

      e.g.
        struct A {};
	struct B : public A {
	  int x;
	  [[no_unique_address]] char c;
	};

    [[likely]], [[unlikely]]  since C++20
      allow the compiler to optimize for the case where paths of execution including that statement are more or 
      less likely than any alternative path of execution that does not include such a statement.

      e.g.
        if (i > 0) [[likely]] {
	  return i * 2;
	} else {
	  return i * 10;
	}

	switch (i) {
	  [[likely]] case 7:
	    return i + 3;
	  case 2:
	    return ++i;
	  default:
	    return i;
	}


> Pack-expansions in lambda init-captures
    template pack is could to extend on lambda init-captures (C++20)

    e.g.
      template<typename _Type, class ..._TypePack>
      void func(_Type &&arg, _TypePack... tp)
      {
        if (sizeof...(tp) != 0)
	  std::cout<<std::forward<_Type>(arg)<<std::endl;

        auto local_func = [&, tp...] (void)
	{
	  return func(tp...);
	};
      }

      void func(void) {};

    //  sizeof... operator is classified as a pack expansion as well.
    //  ellipsis appears on right side means do a pack expansion.
    //    e.g.  (tp + ...) => (tp0 + (tp1 + (tp2 + ...)))
    //	  e.g.  g(std::forward<_TypePack>(tp)...); => 
    //	  	g(std::forward<_TypePackE1>(A1), std::forward<_TypePackE2>(A2), ...);


> removed the requirement to use typename to disambiguate types in many contexts
    e.g.
      struct A {
        typedef UserCustomType int;
      };

      typename A::UserCustomType a;  //  a has type of int,
      	       	       	   	     //  but in C++20,does not need typename keywrod any more.


> consteval specifier and constinit specifier
    consteval - specifies that a function is an immediate function,that is,every call to the
    function must produce a compile-time constant.(contains function template)

    every potentially-evaluated call to the function must produce a compile time constant expression.
    an immediate function is a constexpr function,same as constexpr,a consteval specifier implies inline,
    but consteval may not be applied to destructors,allocation functions,or deallocation functions.
    e.g.
      consteval int sqr(int n) { return n * n; }
      constexpr int x = sqr(3);  //  OK,evaluate sqr(3) produce constant 3 * 3.
      consteval int sqrsqr(int n) { return sqr(sqr(n)); }  //  OK,but not a constant expression,
      		    	       	    	   		   //  because @n is variable.
      //  function enclose a consteval function have to be a consteval function too.

    constinit - asserts that a variable has static initialization, i.e. zero initialization and 
    constant initialization,otherwise the program is ill-formed.

    the constinit specifier declares a variable with static or thread storage duration.
    (have to use it with 'static' or 'thread_local' together)

    if a variable is declared with constinit,its initializing declaration must be applied with constinit.
    (constexpr can produce constant at compile-time)

    if a variable declared with constinit has dynamic initialization(even if it is performed as static
    initialization),the program is ill-formed.

    if no constinit declaration is reachable at the point of the initializing declaration,the program is 
    ill-formed,no diagnostic required.
    !!  constinit cannot be used together with constexpr or consteval.

    when the declared variable is a reference,constinit is equivalent to constexpr.
    when the declared variable is an object,constexpr mandates that the object must have static
    initialization and constant destruction and makes the object const-qualified,but constinit
    does not mandate constant destruction and const-qualified.
    e.g.
      static constinit int x(3);	//  variable x is static and initialized with 3
      thread_local constinit int y(4);	//  variable y is thread_local and initialized with 4
      
      const char *g() { return "dynamic initialization."; }
      constexpr const char *f(bool p) { return p ? "constant initializer" : g(); }
      constinit const char *c = f(true);  //  OK,f(true) returns const char *,and f() is constexpr
      //constinit const char *c = f(false);  //  ERROR,even g() returns const char *,but g() is not constexpr.


> further relaxed constexpr


> signed integers are 2's complement
    ones' complement : -2^(N-1) - 1 -- 2^(N-1) - 1
      3 = 011 (signed)
      -3 = 100 (signed) (inverse all bits)

    two's complement : -2^(N-1) -- 2^(N-1) - 1
      3 = 011 (signed)
      -3 = 101 (signed) (inverse all bits and plus 1)


> bitwise shift operators unified behavior
    the value of a << b is the unique value congruent to a * 2^b modulo 2^N where N
    is the number of bits in the return type.
    that is,bitwise left shift is performed and the bits that get shifted out of the 
    destination type are discarded.
    the value of a >> b is a / 2^b,rounded down.
    in other words,right shift on signed a is arithmetic right shift.


> aggregate initialization using parentheses
    syntax :
      T object = {.des1 = arg1, .des2{arg2} ...};
      T object{.des1 = arg1, .des2{arg2} ...};


> coroutines (C++20)
    A coroutine is a function that can suspend execution to be resumed later.
    coroutines are stackless:
      they suspend execution by returning to the caller and the data that is required to
      resume execution is stored separately from the stack.

    this allows for sequential code that executes asynchronously,and also supports algorithms
    on lazy-computed infinite sequences and other uses.

    a function is a coroutine if its definition contains any of the following :
      the co_await expression to suspend execution until resumed.
      the co_yield expression to suspend execution returning a value.
      the co_return statement to complete execution returning a value.

      //  every coroutine must have a return type that satisfies a number of requirements.
    restrictions :
      coroutines cannot use variadic arguments,plain return statements,or placeholder return
      types.
      consteval functions,constexpr functions,constructors,destructors,and the main function
      cannot be coroutines.

    each coroutine associated with -
      the promise object,manipulated from inside the coroutine,coroutine submits its result or
      exception through this object.
      the coroutine handle,manipulated from outside the coroutine,this is a non-owning handle
      used to resume execution of the coroutine or to destroy the coroutine frame.
      the coroutine state which is internal,dynamically-allocated storage,object that contains -
        the promise object,
	the parameter,all copied by value,
	suspension point,
	local variables and temporaries whose lifetime spans the current suspension point.

    routine execution :
      it will performs the following :
        allocates the coroutine state object via operator new().

	copies all function parameters to the coroutine state,by-value parameters are moved
	or copied,by-reference parameters remain references.

	calls the constructor for the promise object,if the promise type has a constructor that
	takes all coroutine parameters,that constructor is called,with post-copy coroutine arguments,
	otherwise the default constructor is called.

	calls promise.get_return_object() and keeps the result in a local variable,it will be returned
	to the caller when the coroutine first suspends,any exceptions thrown up to and including this 
	step propagate back to the caller,not placed in the promise.

	calls promise.initial_suspend() and co_awaits its result,typical promise types either return a
	std::suspend_always,for lazily-started coroutines,or std::suspend_never,for eagerly-started 
	coroutines.

	when co_await promise.initial_suspend() resumes,starts executing the body of the coroutine.

    when a coroutine reaches a suspension point,the return object obtained earlier is returned to the
    caller/resumer,after implicit conversion to the return type of the coroutine,if necessary.

    when a coroutine reaches the co_return statement,it performs the following :
      calls promise.return_void() for
        co_return;
	co_return <expr>; where expr has type void
	falling off the end of the coroutine,the behavior is undefined if the promise type has no
	promise::return_void() member function in this case.

      or calls promise.return_value(<expr>) for "co_return <expr>;" where expr has non-void type.
      
      destroys all variables with automatic storage duration in reverse order they were created.
      
      calls promise.final_suspend() and co_awaits the result.

    if coroutine state object is destroyed,then destructor of promise object will be called,also
    calls function parameters' destructor,and free memory used by coroutine state,transfers 
    execution back to the caller/resumer.

    coroutine state is allocated dynamically via non-array operator new,if promise type has a class-level
    operator new() for replacement,then calls this,otherwise calls ::new().

    //  the call to operator new() can be optimized out(even if custom allocator is used) if 
     	  the lifetime of the coroutine state is strictly nested within the lifetime of the caller,and
	  the size of coroutine frame is known at the call site.

    promise :
      the promise type is determined by the compiler from the return type of the coroutine using
      std::coroutine_traits.

    co_await :
      the unary operator co_await suspends a coroutine and returns control to the caller.its operand
      is an expression that either is of a class type that defines a member operator co_await or
      may be passed to a non-member operator co_await;or is convertible to such a class type by
      means of the current coroutine's promise::await_transform.

      a co_await expression can only apper in a potentially-evaluated expression within a regular
      function body,and cannot appear -
        in an exception handler,
	in a declaration statement,unless it appears in an initializer of that declaration statement,
	in the simple declaration of an init-statement,unless it appears in an initialize of that
	init-statement,
	in a default argument,or in the initializer of a block-scope variable with static or thread
	storage duration.

      expr is converted to an awaitable as follows :
        if expr is produced by an initial suspend point,a final suspend point,or a yield expression,
	the awaitable is expr,as-is.
	otherwise,if the current coroutine's promise type has the member function await_transform,
	then the awaitable is promise.await_transform(expr).
	otherwise,the awaitable is expr,as-is.
 
      awaiter object is obtained,as follows :
        if overload resolution for operator co_await gives a single best overload,the awaiter is the
	result of that call :
	  awaitable.operator co_await() for member overload,
	  operator co_await(static_cast<Awaitable&&>(awaitable())) for non-member overload.
	otherwise,if overload resolution finds no operator co_await,the awaiter is awaitable,as-is.
	otherwise,if overload resolution is ambiguous,the program is ill-formed.

      awaiter.await_ready() is called,if its result,contextually-converted to bool is false,then,
      the coroutine is suspended,awaiter.await_suspend(handle) is called.

      if await_suspend returns void,control is immediately returned to the caller/resumer of the
      current coroutine.
      if await_suspend returns bool,the value true returns control to the caller/resumer of the
      current coroutine,the value false resumes the current coroutine.
      if await_suspend returns a coroutine handle for some other coroutine,that handle is resumed.
      if await_suspend throws an exception,the exception is caught,the coroutine is resumed,and
      the exception is immediately re-thrown.

      awaiter.await_resume() is called,and its result is the result of the whole "co_await <expr>;" 
      expression.
      if the coroutine was suspended in the co_await expression,and is later resumed,the resume
      point is immediately before the call to awaiter.await_resume().

    co_yield :
      co_yield expression returns a value to the caller and suspends the current coroutine,it is the
      common building block of the resumable generator functions.

      co_yield <expr>;
      co_yield <braced-init-list>;

      it is equivalent to 
        co_await promise.yield_value(expr);

	a typical generator's yield_value would store its argument into the generator object and return
	std::supend_always,transferring control to the caller/resumer.

    e.g.
      #include<coroutine>
      #include<iostream>
      
      struct promise;
      struct coroutine : std::coroutine_handle<promise> {
        using promise_type = ::promise;
      };

      struct promise {
        coroutine get_return_object() { return {coroutine::from_promise(*this)}; }
	std::suspend_always initial_suspend() noexcept { return {}; }
	std::suspend_always final_suspend() noexcept { return {}; }
	void return_void() {}
	void unhandled_exception() {}
      };

      coroutine func()
      {
        coroutine h = [](int i) -> coroutine
	{
	  std::cout<<i;
	  co_return;
	} (0);
	//  there,lambda function is a coroutine,argument is 0.
	//  co_return; returns control to caller/resumer,this statement calls 
	//  promise::return_void
	

	h.resume();
	h.destroy();
      }

      
      